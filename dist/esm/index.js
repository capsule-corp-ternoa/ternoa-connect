import { jsx, jsxs } from 'react/jsx-runtime';
import r$3, { useCallback as useCallback$1, useRef as useRef$1, useDebugValue as useDebugValue$1, useContext as useContext$1, createElement as createElement$1, useMemo as useMemo$1, useState as useState$1, useEffect as useEffect$1, createContext as createContext$2 } from 'react';
import { isApiConnected, getRawApi, query, submitTxBlocking, WaitUntil } from 'ternoa-js';
import { TextEncoder as TextEncoder$1 } from '@polkadot/x-textencoder';
import require$$0$_ from 'zlib';
import * as nodeCrypto from 'crypto';
import nodeCrypto__default from 'crypto';
import { createWasm } from '@polkadot/wasm-crypto-init';
import { getRandomValues } from '@polkadot/x-randomvalues';
import { TextDecoder as TextDecoder$1 } from '@polkadot/x-textdecoder';
import require$$0$Z from 'buffer';
import require$$0$12 from 'os';
import require$$0$$ from 'vm';
import require$$1$19, { EventEmitter as EventEmitter$3 } from 'events';
import require$$0$11 from 'fs';
import require$$0$10 from 'util';
import require$$1$1a from 'tty';
import require$$0$13 from 'lokijs';
import require$$1$1b from 'stream';
import require$$0$14 from 'assert';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

var tslib_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    __extends: __extends,
    get __assign () { return __assign; },
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet
});

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

// Ensure that we are able to run this without any @types/node definitions
// and without having lib: ['dom'] in our TypeScript configuration
// (may not be available in all environments, e.g. Deno springs to mind)

function evaluateThis(fn) {
  return fn('return this');
}
const xglobal = typeof globalThis !== 'undefined' ? globalThis : typeof global$1 !== 'undefined' ? global$1 : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : evaluateThis(Function);

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

// eslint-disable-next-line @typescript-eslint/ban-types

/**
 * @name isFunction
 * @summary Tests for a `function`.
 * @description
 * Checks to see if the input value is a JavaScript function.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isFunction } from '@polkadot/util';
 *
 * isFunction(() => false); // => true
 * ```
 */
function isFunction$2(value) {
  return typeof value === 'function';
}

// Copyright 2017-2022 @polkadot/util authors & contributors
const DEDUPE = 'Either remove and explicitly install matching versions or dedupe using your package manager.\nThe following conflicting packages were found:';

/** @internal */
function getEntry(name) {
  const _global = xglobal;
  if (!_global.__polkadotjs) {
    _global.__polkadotjs = {};
  }
  if (!_global.__polkadotjs[name]) {
    _global.__polkadotjs[name] = [];
  }
  return _global.__polkadotjs[name];
}

/** @internal */
function formatDisplay(all, fmt) {
  let max = 0;
  for (let i = 0; i < all.length; i++) {
    max = Math.max(max, all[i].version.length);
  }
  return all.map(d => `\t${fmt(d.version.padEnd(max), d).join('\t')}`).join('\n');
}

/** @internal */
function formatInfo$2(version, {
  name
}) {
  return [version, name];
}

/** @internal */
function formatVersion(version, {
  path,
  type
}) {
  let extracted;
  if (path && path.length >= 5) {
    const nmIndex = path.indexOf('node_modules');
    extracted = nmIndex === -1 ? path : path.substring(nmIndex);
  } else {
    extracted = '<unknown>';
  }
  return [`${`${type || ''}`.padStart(3)} ${version}`, extracted];
}

/** @internal */
function getPath(infoPath, pathOrFn) {
  if (infoPath) {
    return infoPath;
  } else if (isFunction$2(pathOrFn)) {
    try {
      return pathOrFn() || '';
    } catch (error) {
      return '';
    }
  }
  return pathOrFn || '';
}

/** @internal */
function warn(pre, all, fmt) {
  console.warn(`${pre}\n${DEDUPE}\n${formatDisplay(all, fmt)}`);
}

/**
 * @name detectPackage
 * @summary Checks that a specific package is only imported once
 * @description A `@polkadot/*` version detection utility, checking for one occurence of a package in addition to checking for ddependency versions.
 */
function detectPackage({
  name,
  path,
  type,
  version
}, pathOrFn, deps = []) {
  if (!name.startsWith('@polkadot')) {
    throw new Error(`Invalid package descriptor ${name}`);
  }
  const entry = getEntry(name);
  entry.push({
    path: getPath(path, pathOrFn),
    type,
    version
  });
  if (entry.length !== 1) {
    warn(`${name} has multiple versions, ensure that there is only one installed.`, entry, formatVersion);
  } else {
    const mismatches = deps.filter(d => d && d.version !== version);
    if (mismatches.length) {
      warn(`${name} requires direct dependencies exactly matching version ${version}.`, mismatches, formatInfo$2);
    }
  }
}

// Copyright 2017-2022 @polkadot/x-bigint authors & contributors
const BigInt$1 = typeof xglobal.BigInt === 'function' && typeof xglobal.BigInt.asIntN === 'function' ? xglobal.BigInt : () => Number.NaN;

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

const CHR = '0123456789abcdef';
const U8$1 = new Array(256);
const U16$1 = new Array(256 * 256);
for (let i = 0; i < CHR.length; i++) {
  U8$1[CHR[i].charCodeAt(0) | 0] = i | 0;
  if (i > 9) {
    U8$1[CHR[i].toUpperCase().charCodeAt(0) | 0] = i | 0;
  }
}
for (let i = 0; i < 256; i++) {
  const s = i << 8;
  for (let j = 0; j < 256; j++) {
    U16$1[s | j] = U8$1[i] << 4 | U8$1[j];
  }
}

/**
 * @name hexToU8a
 * @summary Creates a Uint8Array object from a hex string.
 * @description
 * `null` inputs returns an empty `Uint8Array` result. Hex input values return the actual bytes value converted to a Uint8Array. Anything that is not a hex string (including the `0x` prefix) throws an error.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToU8a } from '@polkadot/util';
 *
 * hexToU8a('0x80001f'); // Uint8Array([0x80, 0x00, 0x1f])
 * hexToU8a('0x80001f', 32); // Uint8Array([0x00, 0x80, 0x00, 0x1f])
 * ```
 */
function hexToU8a(value, bitLength = -1) {
  if (!value) {
    return new Uint8Array();
  }
  let s = value.startsWith('0x') ? 2 : 0;
  const decLength = Math.ceil((value.length - s) / 2);
  const endLength = Math.ceil(bitLength === -1 ? decLength : bitLength / 8);
  const result = new Uint8Array(endLength);
  const offset = endLength > decLength ? endLength - decLength : 0;
  for (let i = offset; i < endLength; i++, s += 2) {
    // The big factor here is actually the string lookups. If we do
    // HEX_TO_U16[value.substring()] we get an 10x slowdown. In the
    // same vein using charCodeAt (as opposed to value[s] or value.charAt(s)) is
    // also the faster operation by at least 2x with the character map above
    result[i] = U16$1[value.charCodeAt(s) << 8 | value.charCodeAt(s + 1)];
  }
  return result;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var bn = {exports: {}};

(function (module) {
(function (module, exports) {

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require$$0$Z.Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) ; else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(module, commonjsGlobal);
}(bn));

var BN = bn.exports;

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

const REGEX_HEX_PREFIXED = /^0x[\da-fA-F]+$/;
const REGEX_HEX_NOPREFIX = /^[\da-fA-F]+$/;

/**
 * @name isHex
 * @summary Tests for a hex string.
 * @description
 * Checks to see if the input value is a `0x` prefixed hex string. Optionally (`bitLength` !== -1) checks to see if the bitLength is correct.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isHex } from '@polkadot/util';
 *
 * isHex('0x1234'); // => true
 * isHex('0x1234', 8); // => false
 * ```
 */
function isHex(value, bitLength = -1, ignoreLength) {
  return typeof value === 'string' && (value === '0x' || REGEX_HEX_PREFIXED.test(value)) && (bitLength === -1 ? ignoreLength || value.length % 2 === 0 : value.length === 2 + Math.ceil(bitLength / 4));
}

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isObject
 * @summary Tests for an `object`.
 * @description
 * Checks to see if the input value is a JavaScript object.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isObject } from '@polkadot/util';
 *
 * isObject({}); // => true
 * isObject('something'); // => false
 * ```
 */
function isObject$4(value) {
  return !!value && typeof value === 'object';
}

// Copyright 2017-2022 @polkadot/util authors & contributors
function isOn(...fns) {
  return value => (isObject$4(value) || isFunction$2(value)) && fns.every(f => isFunction$2(value[f]));
}

// Copyright 2017-2022 @polkadot/util authors & contributors
const isToBigInt = /*#__PURE__*/isOn('toBigInt');

// Copyright 2017-2022 @polkadot/util authors & contributors
const isToBn = /*#__PURE__*/isOn('toBn');

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read$8 (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write$8 (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$a = {}.toString;

var isArray$2 = Array.isArray || function (arr) {
  return toString$a.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

function kMaxLength () {
  return Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$1 (arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe$3(this, arg)
  }
  return from$3(this, arg, encodingOrOffset, length)
}

Buffer$1.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr
};

function from$3 (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer$1(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString$5(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$1.from = function (value, encodingOrOffset, length) {
  return from$3(null, value, encodingOrOffset, length)
};

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc$6 (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$1.alloc = function (size, fill, encoding) {
  return alloc$6(null, size, fill, encoding)
};

function allocUnsafe$3 (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe$3(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe$3(null, size)
};

function fromString$5 (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer$1 (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer$1.isBuffer = isBuffer$3;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$1.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$1.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$1.concat = function concat (list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$1.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes$1(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes$1(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$1.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$1.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$1.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$1.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$1.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$1.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$1.compare(this, b) === 0
};

Buffer$1.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes$1(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$1.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$1.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex$1(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read$8(this, offset, true, 23, 4)
};

Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read$8(this, offset, false, 23, 4)
};

Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read$8(this, offset, true, 52, 8)
};

Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read$8(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write$8(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write$8(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex$1 (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes$1 (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$3(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

// Since we run in very different environments, we have to ensure we have all
// the types used here for detection (some of these may require Node definitions,
// which are not available in Deno/browser)

/** true if the environment has proper BigInt support */
const hasBigInt = typeof BigInt$1 === 'function' && typeof BigInt$1.asIntN === 'function';

// NOTE We check the following on globalThis, avoiding specific polyfill detection
// that some bundlers such as parcel would add (this is a check, not a use)

/** true if the environment has support for Buffer (typically Node.js) */
const hasBuffer = typeof xglobal.Buffer !== 'undefined';

/** true if the environment has process available (typically Node.js) */
const hasProcess = typeof xglobal.process === 'object';

/**
 * @name isBuffer
 * @summary Tests for a `Buffer` object instance.
 * @description
 * Checks to see if the input object is an instance of `Buffer`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isBuffer } from '@polkadot/util';
 *
 * console.log('isBuffer', isBuffer(Buffer.from([]))); // => true
 * ```
 */
function isBuffer$2(value) {
  // we do check a function first, since it is slightly faster than isBuffer itself
  return hasBuffer && isFunction$2(value && value.readDoubleLE) && Buffer$1.isBuffer(value);
}

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isU8a
 * @summary Tests for a `Uint8Array` object instance.
 * @description
 * Checks to see if the input object is an instance of `Uint8Array`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isUint8Array } from '@polkadot/util';
 *
 * console.log('isU8a', isU8a([])); // => false
 * ```
 */
function isU8a(value) {
  // here we defer the instanceof check which is actually slightly
  // slower than just checking the constrctor (direct instances)
  return (value && value.constructor) === Uint8Array || value instanceof Uint8Array;
}

// Copyright 2017-2022 @polkadot/util authors & contributors
const encoder = new TextEncoder$1();

/**
 * @name stringToU8a
 * @summary Creates a Uint8Array object from a utf-8 string.
 * @description
 * String input values return the actual encoded `UInt8Array`. `null` or `undefined` values returns an empty encoded array.
 * @example
 * <BR>
 *
 * ```javascript
 * import { stringToU8a } from '@polkadot/util';
 *
 * stringToU8a('hello'); // [0x68, 0x65, 0x6c, 0x6c, 0x6f]
 * ```
 */
function stringToU8a(value) {
  return value ? encoder.encode(value.toString()) : new Uint8Array();
}

// Copyright 2017-2022 @polkadot/util authors & contributors

/**
 * @name u8aToU8a
 * @summary Creates a Uint8Array value from a Uint8Array, Buffer, string or hex input.
 * @description
 * `null` or `undefined` inputs returns a `[]` result, Uint8Array values returns the value, hex strings returns a Uint8Array representation.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToU8a } from '@polkadot/util';
 *
 * u8aToU8a(new Uint8Array([0x12, 0x34]); // => Uint8Array([0x12, 0x34])
 * u8aToU8a(0x1234); // => Uint8Array([0x12, 0x34])
 * ```
 */
function u8aToU8a(value) {
  return isU8a(value) ? value : isHex(value) ? hexToU8a(value) : isBuffer$2(value) || Array.isArray(value) ? new Uint8Array(value) : stringToU8a(value);
}

// Copyright 2017-2022 @polkadot/util authors & contributors

/**
 * @name u8aConcat
 * @summary Creates a concatenated Uint8Array from the inputs.
 * @description
 * Concatenates the input arrays into a single `UInt8Array`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { { u8aConcat } from '@polkadot/util';
 *
 * u8aConcat(
 *   new Uint8Array([1, 2, 3]),
 *   new Uint8Array([4, 5, 6])
 * ); // [1, 2, 3, 4, 5, 6]
 * ```
 */
function u8aConcat(...list) {
  const u8as = new Array(list.length);
  let length = 0;
  for (let i = 0; i < list.length; i++) {
    u8as[i] = u8aToU8a(list[i]);
    length += u8as[i].length;
  }
  return u8aConcatStrict(u8as, length);
}

/**
 * @name u8aConcatStrict
 * @description A strict version of [[u8aConcat]], accepting only Uint8Array inputs
 */
function u8aConcatStrict(u8as, length = 0) {
  let offset = 0;
  if (!length) {
    for (let i = 0; i < u8as.length; i++) {
      length += u8as[i].length;
    }
  }
  const result = new Uint8Array(length);
  for (let i = 0; i < u8as.length; i++) {
    result.set(u8as[i], offset);
    offset += u8as[i].length;
  }
  return result;
}

// Copyright 2017-2022 @polkadot/util authors & contributors

/**
 * @name u8aEq
 * @summary Compares two Uint8Arrays for equality.
 * @description
 * For `UInt8Array` (or hex string) input values true if there is a match.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aEq } from '@polkadot/util';
 *
 * u8aEq(new Uint8Array([0x68, 0x65]), new Uint8Array([0x68, 0x65])); // true
 * ```
 */
function u8aEq(a, b) {
  const u8aa = u8aToU8a(a);
  const u8ab = u8aToU8a(b);
  if (u8aa.length === u8ab.length) {
    const dvA = new DataView(u8aa.buffer, u8aa.byteOffset);
    const dvB = new DataView(u8ab.buffer, u8ab.byteOffset);
    const mod = u8aa.length % 4 | 0;
    const length = u8aa.length - mod | 0;
    for (let i = 0; i < length; i += 4) {
      if (dvA.getUint32(i) !== dvB.getUint32(i)) {
        return false;
      }
    }
    for (let i = length; i < u8aa.length; i++) {
      if (u8aa[i] !== u8ab[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

const U8 = new Array(256);
const U16 = new Array(256 * 256);
for (let n = 0; n < 256; n++) {
  U8[n] = n.toString(16).padStart(2, '0');
}
for (let i = 0; i < 256; i++) {
  const s = i << 8;
  for (let j = 0; j < 256; j++) {
    U16[s | j] = U8[i] + U8[j];
  }
}

/** @internal */
function hex$1(value, result) {
  const mod = value.length % 2 | 0;
  const length = value.length - mod | 0;
  for (let i = 0; i < length; i += 2) {
    result += U16[value[i] << 8 | value[i + 1]];
  }
  if (mod) {
    result += U8[value[length] | 0];
  }
  return result;
}

/**
 * @name u8aToHex
 * @summary Creates a hex string from a Uint8Array object.
 * @description
 * `UInt8Array` input values return the actual hex string. `null` or `undefined` values returns an `0x` string.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToHex } from '@polkadot/util';
 *
 * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f
 * ```
 */
function u8aToHex(value, bitLength = -1, isPrefixed = true) {
  // this is not 100% correct sinmce we support isPrefixed = false....
  const empty = isPrefixed ? '0x' : '';
  if (!value || !value.length) {
    return empty;
  } else if (bitLength > 0) {
    const length = Math.ceil(bitLength / 8);
    if (value.length > length) {
      return `${hex$1(value.subarray(0, length / 2), empty)}…${hex$1(value.subarray(value.length - length / 2), '')}`;
    }
  }
  return hex$1(value, empty);
}

// Copyright 2017-2022 @polkadot/util authors & contributors
const decoder = new TextDecoder$1('utf-8');

/**
 * @name u8aToString
 * @summary Creates a utf-8 string from a Uint8Array object.
 * @description
 * `UInt8Array` input values return the actual decoded utf-8 string. `null` or `undefined` values returns an empty string.
 * @example
 * <BR>
 *
 * ```javascript
 * import { u8aToString } from '@polkadot/util';
 *
 * u8aToString(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // hello
 * ```
 */
function u8aToString(value) {
  return value ? decoder.decode(value) : '';
}

// Copyright 2017-2022 @polkadot/util authors & contributors

/** @internal */
const U8A_WRAP_ETHEREUM = u8aToU8a('\x19Ethereum Signed Message:\n');

/** @internal */
const U8A_WRAP_PREFIX = u8aToU8a('<Bytes>');

/** @internal */
const U8A_WRAP_POSTFIX = u8aToU8a('</Bytes>');
const WRAP_LEN = U8A_WRAP_PREFIX.length + U8A_WRAP_POSTFIX.length;

/** @internal */
function u8aIsWrapped(u8a, withEthereum) {
  return u8a.length >= WRAP_LEN && u8aEq(u8a.subarray(0, U8A_WRAP_PREFIX.length), U8A_WRAP_PREFIX) && u8aEq(u8a.slice(-U8A_WRAP_POSTFIX.length), U8A_WRAP_POSTFIX) || withEthereum && u8a.length >= U8A_WRAP_ETHEREUM.length && u8aEq(u8a.subarray(0, U8A_WRAP_ETHEREUM.length), U8A_WRAP_ETHEREUM);
}

/**
 * @name u8aUnwrapBytes
 * @description Removes all <Bytes>...</Bytes> wrappers from the supplied value
 */
function u8aUnwrapBytes(bytes) {
  const u8a = u8aToU8a(bytes);

  // we don't want to unwrap Ethereum-style wraps
  return u8aIsWrapped(u8a, false) ? u8a.subarray(U8A_WRAP_PREFIX.length, u8a.length - U8A_WRAP_POSTFIX.length) : u8a;
}

/**
 * @name u8aWrapBytes
 * @description Adds a <Bytes>...</Bytes> wrapper to the supplied value (if not already existing)
 */
function u8aWrapBytes(bytes) {
  const u8a = u8aToU8a(bytes);

  // if Ethereum-wrapping, we don't add our wrapping bytes
  return u8aIsWrapped(u8a, true) ? u8a : u8aConcatStrict([U8A_WRAP_PREFIX, u8a, U8A_WRAP_POSTFIX]);
}

// Copyright 2017-2022 @polkadot/util authors & contributors

/**
 * @name hexStripPrefix
 * @summary Strips any leading `0x` prefix.
 * @description
 * Tests for the existence of a `0x` prefix, and returns the value without the prefix. Un-prefixed values are returned as-is.
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexStripPrefix } from '@polkadot/util';
 *
 * console.log('stripped', hexStripPrefix('0x1234')); // => 1234
 * ```
 */
function hexStripPrefix(value) {
  if (!value || value === '0x') {
    return '';
  } else if (REGEX_HEX_PREFIXED.test(value)) {
    return value.substring(2);
  } else if (REGEX_HEX_NOPREFIX.test(value)) {
    return value;
  }
  throw new Error(`Expected hex value to convert, found '${value}'`);
}

// Copyright 2017-2022 @polkadot/util authors & contributors

/**
 * @name hexToBn
 * @summary Creates a BN.js object from a hex string.
 * @description
 * `null` inputs returns a `BN(0)` result. Hex input values return the actual value converted to a BN. Anything that is not a hex string (including the `0x` prefix) throws an error.
 * @param _value The value to convert
 * @param _options Options to pass while converting
 * @param _options.isLe Convert using Little Endian
 * @param _options.isNegative Convert using two's complement
 * @example
 * <BR>
 *
 * ```javascript
 * import { hexToBn } from '@polkadot/util';
 *
 * hexToBn('0x123480001f'); // => BN(0x123480001f)
 * ```
 */
function hexToBn(value, {
  isLe = false,
  isNegative = false
} = {}) {
  if (!value || value === '0x') {
    return new BN(0);
  }
  const stripped = hexStripPrefix(value);
  const bn = new BN(stripped, 16, isLe ? 'le' : 'be');

  // fromTwos takes as parameter the number of bits, which is the hex length
  // multiplied by 4 (2 bytes being 8 bits)
  return isNegative ? bn.fromTwos(stripped.length * 4) : bn;
}

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isBigInt
 * @summary Tests for a `BigInt` object instance.
 * @description
 * Checks to see if the input object is an instance of `BigInt`
 * @example
 * <BR>
 *
 * ```javascript
 * import { isBigInt } from '@polkadot/util';
 *
 * console.log('isBigInt', isBigInt(123_456n)); // => true
 * ```
 */
function isBigInt(value) {
  return typeof value === 'bigint';
}

// Copyright 2017-2022 @polkadot/util authors & contributors

/**
 * @name bnToBn
 * @summary Creates a BN value from a BN, bigint, string (base 10 or hex) or number input.
 * @description
 * `null` inputs returns a `0x0` result, BN values returns the value, numbers returns a BN representation.
 * @example
 * <BR>
 *
 * ```javascript
 * import BN from 'bn.js';
 * import { bnToBn } from '@polkadot/util';
 *
 * bnToBn(0x1234); // => BN(0x1234)
 * bnToBn(new BN(0x1234)); // => BN(0x1234)
 * ```
 */
function bnToBn(value) {
  return value ? BN.isBN(value) ? value : isHex(value) ? hexToBn(value.toString()) : isBigInt(value) ? new BN(value.toString()) : isToBn(value) ? value.toBn() : isToBigInt(value) ? new BN(value.toBigInt().toString()) : new BN(value) : new BN(0);
}

// Copyright 2017-2022 @polkadot/util authors & contributors
const DEFAULT_OPTS = {
  bitLength: -1,
  isLe: true,
  isNegative: false
};

/**
 * @name bnToU8a
 * @summary Creates a Uint8Array object from a BN.
 * @description
 * `null`/`undefined`/`NaN` inputs returns an empty `Uint8Array` result. `BN` input values return the actual bytes value converted to a `Uint8Array`. Optionally convert using little-endian format if `isLE` is set.
 * @example
 * <BR>
 *
 * ```javascript
 * import { bnToU8a } from '@polkadot/util';
 *
 * bnToU8a(new BN(0x1234)); // => [0x12, 0x34]
 * ```
 */
function bnToU8a(value, {
  bitLength = -1,
  isLe = true,
  isNegative = false
} = DEFAULT_OPTS) {
  const valueBn = bnToBn(value);
  const byteLength = bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((bitLength || 0) / 8);
  if (!value) {
    return bitLength === -1 ? new Uint8Array(1) : new Uint8Array(byteLength);
  }
  const output = new Uint8Array(byteLength);
  const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
  output.set(bn.toArray(isLe ? 'le' : 'be', byteLength), 0);
  return output;
}

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isUndefined
 * @summary Tests for a `undefined` values.
 * @description
 * Checks to see if the input value is `undefined`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isUndefined } from '@polkadot/util';
 *
 * console.log('isUndefined', isUndefined(void(0))); // => true
 * ```
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isUndefined$2(value) {
  return value === undefined;
}

// Copyright 2017-2022 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name objectSpread
 * @summary Concats all sources into the destination
 */
function objectSpread(dest, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    const src = sources[i];
    if (src) {
      if (typeof src.entries === 'function') {
        for (const [key, value] of src.entries()) {
          dest[key] = value;
        }
      } else {
        Object.assign(dest, src);
      }
    }
  }
  return dest;
}

/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$1 = BigInt(1);
const _2n$1 = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const CURVE = Object.freeze({
    a: _0n$1,
    b: BigInt(7),
    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: _1n$1,
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
});
function weistrass(x) {
    const { a, b } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
}
const USE_ENDOMORPHISM = CURVE.a === _0n$1;
class ShaError extends Error {
    constructor(message) {
        super(message);
    }
}
class JacobianPoint {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static fromAffine(p) {
        if (!(p instanceof Point$1)) {
            throw new TypeError('JacobianPoint#fromAffine: expected Point');
        }
        return new JacobianPoint(p.x, p.y, _1n$1);
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
        if (!(other instanceof JacobianPoint))
            throw new TypeError('JacobianPoint expected');
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
    }
    negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod(X1 * X1);
        const B = mod(Y1 * Y1);
        const C = mod(B * B);
        const x1b = X1 + B;
        const D = mod(_2n$1 * (mod(x1b * x1b) - A - C));
        const E = mod(_3n * A);
        const F = mod(E * E);
        const X3 = mod(F - _2n$1 * D);
        const Y3 = mod(E * (D - X3) - _8n * C);
        const Z3 = mod(_2n$1 * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
        if (!(other instanceof JacobianPoint))
            throw new TypeError('JacobianPoint expected');
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n$1 || Y2 === _0n$1)
            return this;
        if (X1 === _0n$1 || Y1 === _0n$1)
            return other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n$1) {
            if (r === _0n$1) {
                return this.double();
            }
            else {
                return JacobianPoint.ZERO;
            }
        }
        const HH = mod(H * H);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r * r - HHH - _2n$1 * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === 'bigint' && scalar === _0n$1)
            return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n$1)
            return this;
        if (!USE_ENDOMORPHISM) {
            let p = P0;
            let d = this;
            while (n > _0n$1) {
                if (n & _1n$1)
                    p = p.add(d);
                d = d.double();
                n >>= _1n$1;
            }
            return p;
        }
        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n$1 || k2 > _0n$1) {
            if (k1 & _1n$1)
                k1p = k1p.add(d);
            if (k2 & _1n$1)
                k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n$1;
            k2 >>= _1n$1;
        }
        if (k1neg)
            k1p = k1p.negate();
        if (k2neg)
            k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
    }
    precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < 2 ** (W - 1); i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
            affinePoint = Point$1.BASE;
        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
        if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = JacobianPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.ZERO;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n$1;
            }
            if (wbits === 0) {
                let pr = precomputes[offset];
                if (window % 2)
                    pr = pr.negate();
                f = f.add(pr);
            }
            else {
                let cached = precomputes[offset + Math.abs(wbits) - 1];
                if (wbits < 0)
                    cached = cached.negate();
                p = p.add(cached);
            }
        }
        return { p, f };
    }
    multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
        }
        else {
            const { p, f } = this.wNAF(n, affinePoint);
            point = p;
            fake = f;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
    }
    toAffine(invZ = invert(this.z)) {
        const { x, y, z } = this;
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x * iz2);
        const ay = mod(y * iz3);
        const zz = mod(z * iz1);
        if (zz !== _1n$1)
            throw new Error('invZ was invalid');
        return new Point$1(ax, ay);
    }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n$1);
JacobianPoint.ZERO = new JacobianPoint(_0n$1, _1n$1, _0n$1);
const pointPrecomputes = new WeakMap();
class Point$1 {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    hasEvenY() {
        return this.y % _2n$1 === _0n$1;
    }
    static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x))
            throw new Error('Point is not on curve');
        const y2 = weistrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n$1) === _1n$1;
        if (isShort) {
            if (isYOdd)
                y = mod(-y);
        }
        else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd)
                y = mod(-y);
        }
        const point = new Point$1(x, y);
        point.assertValidity();
        return point;
    }
    static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, 33));
        const y = bytesToNumber(bytes.subarray(33, 65));
        const point = new Point$1(x, y);
        point.assertValidity();
        return point;
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {
            return this.fromCompressedHex(bytes);
        }
        if (len === 65 && header === 0x04)
            return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
        return Point$1.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
        msgHash = ensureBytes(msgHash);
        const h = truncateHash(msgHash);
        const { r, s } = normalizeSignature(signature);
        if (recovery !== 0 && recovery !== 1) {
            throw new Error('Cannot recover signature: invalid recovery bit');
        }
        const prefix = recovery & 1 ? '03' : '02';
        const R = Point$1.fromHex(prefix + numTo32bStr(r));
        const { n } = CURVE;
        const rinv = invert(r, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const Q = Point$1.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
            throw new Error('Cannot recover signature: point at infinify');
        Q.assertValidity();
        return Q;
    }
    toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
            const prefix = this.hasEvenY() ? '02' : '03';
            return `${prefix}${x}`;
        }
        else {
            return `04${x}${numTo32bStr(this.y)}`;
        }
    }
    toHexX() {
        return this.toHex(true).slice(2);
    }
    toRawX() {
        return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
        const msg = 'Point is not on elliptic curve';
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
            throw new Error(msg);
        const left = mod(y * y);
        const right = weistrass(x);
        if (mod(left - right) !== _0n$1)
            throw new Error(msg);
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point$1(this.x, mod(-this.y));
    }
    double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n$1 || a === _1n$1 || this !== Point$1.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
}
Point$1.BASE = new Point$1(CURVE.Gx, CURVE.Gy);
Point$1.ZERO = new Point$1(_0n$1, _0n$1);
function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
}
function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 0x02) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
    }
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
    }
    if (res[0] === 0x00 && res[1] <= 0x7f) {
        throw new Error('Invalid signature integer: trailing length');
    }
    return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 0x30) {
        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
    }
    if (data[1] !== data.length - 2) {
        throw new Error('Invalid signature: incorrect length');
    }
    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    }
    return { r, s };
}
class Signature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromCompact(hex) {
        const arr = hex instanceof Uint8Array;
        const name = 'Signature.fromCompact';
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
            throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature(hexToNumber$1(str.slice(0, 64)), hexToNumber$1(str.slice(64, 128)));
    }
    static fromDER(hex) {
        const arr = hex instanceof Uint8Array;
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
    }
    static fromHex(hex) {
        return this.fromDER(hex);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
            throw new Error('Invalid Signature: r must be 0 < r < n');
        if (!isWithinCurveOrder(s))
            throw new Error('Invalid Signature: s must be 0 < s < n');
    }
    hasHighS() {
        const HALF = CURVE.n >> _1n$1;
        return this.s > HALF;
    }
    normalizeS() {
        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
    }
    toDERRawBytes(isCompressed = false) {
        return hexToBytes(this.toDERHex(isCompressed));
    }
    toDERHex(isCompressed = false) {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        if (isCompressed)
            return sHex;
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const rLen = numberToHexUnpadded(rHex.length / 2);
        const sLen = numberToHexUnpadded(sHex.length / 2);
        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
        return this.toDERRawBytes();
    }
    toHex() {
        return this.toDERHex();
    }
    toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
}
function concatBytes(...arrays) {
    if (!arrays.every((b) => b instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
function numTo32bStr(num) {
    if (typeof num !== 'bigint')
        throw new Error('Expected bigint');
    if (!(_0n$1 <= num && num < POW_2_256))
        throw new Error('Expected number < 2^256');
    return num.toString(16).padStart(64, '0');
}
function numTo32b(num) {
    const b = hexToBytes(numTo32bStr(num));
    if (b.length !== 32)
        throw new Error('Error: expected 32 bytes');
    return b;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber$1(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);
    }
    return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
function bytesToNumber(bytes) {
    return hexToNumber$1(bytesToHex(bytes));
}
function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
    if (typeof num === 'bigint' && isWithinCurveOrder(num))
        return num;
    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
}
function mod(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n$1 ? result : b + result;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n$1) {
        res *= res;
        res %= P;
    }
    return res;
}
function sqrtMod(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = (x * x * x) % P;
    const b3 = (b2 * b2 * x) % P;
    const b6 = (pow2(b3, _3n) * b3) % P;
    const b9 = (pow2(b6, _3n) * b3) % P;
    const b11 = (pow2(b9, _2n$1) * b2) % P;
    const b22 = (pow2(b11, _11n) * b11) % P;
    const b44 = (pow2(b22, _22n) * b22) % P;
    const b88 = (pow2(b44, _44n) * b44) % P;
    const b176 = (pow2(b88, _88n) * b88) % P;
    const b220 = (pow2(b176, _44n) * b44) % P;
    const b223 = (pow2(b220, _3n) * b3) % P;
    const t1 = (pow2(b223, _23n) * b22) % P;
    const t2 = (pow2(t1, _6n) * b2) % P;
    return pow2(t2, _2n$1);
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n$1 || modulo <= _0n$1) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n$1, u = _1n$1;
    while (a !== _0n$1) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        b = a, a = r, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n$1)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n$1)
            return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
    }, _1n$1);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
        if (num === _0n$1)
            return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
    }, inverted);
    return scratch;
}
const divNearest = (a, b) => (a + b / _2n$1) / b;
const ENDO = {
    a1: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
    b1: -_1n$1 * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),
    a2: BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
    b2: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
    POW_2_128: BigInt('0x100000000000000000000000000000000'),
};
function splitScalarEndo(k) {
    const { n } = CURVE;
    const { a1, b1, a2, b2, POW_2_128 } = ENDO;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = mod(k - c1 * a1 - c2 * a2, n);
    let k2 = mod(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
        k1 = n - k1;
    if (k2neg)
        k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
    }
    return { k1neg, k1, k2neg, k2 };
}
function truncateHash(hash) {
    const { n } = CURVE;
    const byteLength = hash.length;
    const delta = byteLength * 8 - 256;
    let h = bytesToNumber(hash);
    if (delta > 0)
        h = h >> BigInt(delta);
    if (h >= n)
        h -= n;
    return h;
}
let _sha256Sync;
let _hmacSha256Sync;
function isWithinCurveOrder(num) {
    return _0n$1 < num && num < CURVE.n;
}
function isValidFieldElement(num) {
    return _0n$1 < num && num < CURVE.P;
}
function normalizePrivateKey(key) {
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
    }
    else if (typeof key === 'string') {
        if (key.length !== 64)
            throw new Error('Expected 32 bytes of private key');
        num = hexToNumber$1(key);
    }
    else if (key instanceof Uint8Array) {
        if (key.length !== 32)
            throw new Error('Expected 32 bytes of private key');
        num = bytesToNumber(key);
    }
    else {
        throw new TypeError('Expected valid private key');
    }
    if (!isWithinCurveOrder(num))
        throw new Error('Expected private key: 0 < key < n');
    return num;
}
function normalizeSignature(signature) {
    if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
    }
    try {
        return Signature.fromDER(signature);
    }
    catch (error) {
        return Signature.fromCompact(signature);
    }
}
function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
    return Point$1.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
Point$1.BASE._setWindowSize(8);
const crypto$e = {
    node: nodeCrypto,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};
const TAGGED_HASH_PREFIXES = {};
const utils$d = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    mod,
    invert,
    isValidPrivateKey(privateKey) {
        try {
            normalizePrivateKey(privateKey);
            return true;
        }
        catch (error) {
            return false;
        }
    },
    _bigintTo32Bytes: numTo32b,
    _normalizePrivateKey: normalizePrivateKey,
    hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024)
            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
        const num = mod(bytesToNumber(hash), CURVE.n - _1n$1) + _1n$1;
        return numTo32b(num);
    },
    randomBytes: (bytesLength = 32) => {
        if (crypto$e.web) {
            return crypto$e.web.getRandomValues(new Uint8Array(bytesLength));
        }
        else if (crypto$e.node) {
            const { randomBytes } = crypto$e.node;
            return Uint8Array.from(randomBytes(bytesLength));
        }
        else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    },
    randomPrivateKey: () => {
        return utils$d.hashToPrivateKey(utils$d.randomBytes(40));
    },
    sha256: async (...messages) => {
        if (crypto$e.web) {
            const buffer = await crypto$e.web.subtle.digest('SHA-256', concatBytes(...messages));
            return new Uint8Array(buffer);
        }
        else if (crypto$e.node) {
            const { createHash } = crypto$e.node;
            const hash = createHash('sha256');
            messages.forEach((m) => hash.update(m));
            return Uint8Array.from(hash.digest());
        }
        else {
            throw new Error("The environment doesn't have sha256 function");
        }
    },
    hmacSha256: async (key, ...messages) => {
        if (crypto$e.web) {
            const ckey = await crypto$e.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);
            const message = concatBytes(...messages);
            const buffer = await crypto$e.web.subtle.sign('HMAC', ckey, message);
            return new Uint8Array(buffer);
        }
        else if (crypto$e.node) {
            const { createHmac } = crypto$e.node;
            const hash = createHmac('sha256', key);
            messages.forEach((m) => hash.update(m));
            return Uint8Array.from(hash.digest());
        }
        else {
            throw new Error("The environment doesn't have hmac-sha256 function");
        }
    },
    sha256Sync: undefined,
    hmacSha256Sync: undefined,
    taggedHash: async (tag, ...messages) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = await utils$d.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return utils$d.sha256(tagP, ...messages);
    },
    taggedHashSync: (tag, ...messages) => {
        if (typeof _sha256Sync !== 'function')
            throw new ShaError('sha256Sync is undefined, you need to set it');
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages);
    },
    precompute(windowSize = 8, point = Point$1.BASE) {
        const cached = point === Point$1.BASE ? point : new Point$1(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
    },
};
Object.defineProperties(utils$d, {
    sha256Sync: {
        configurable: false,
        get() {
            return _sha256Sync;
        },
        set(val) {
            if (!_sha256Sync)
                _sha256Sync = val;
        },
    },
    hmacSha256Sync: {
        configurable: false,
        get() {
            return _hmacSha256Sync;
        },
        set(val) {
            if (!_hmacSha256Sync)
                _hmacSha256Sync = val;
        },
    },
});

// Copyright 2019-2022 @polkadot/wasm-bridge authors & contributors
const DEFAULT_CRYPTO = {
  getRandomValues
};
const DEFAULT_SELF = {
  crypto: DEFAULT_CRYPTO
};

/**
 * @name Wbg
 * @description
 * This defines the internal interfaces that wasm-bindgen used to communicate
 * with the host layer. None of these functions are available to the user, rather
 * they are called internally from the WASM code itself.
 *
 * The interfaces here are exposed in the imports on the created WASM interfaces.
 *
 * Internally the implementation does a thin layer into the supplied bridge.
 */
class Wbg {
  #bridge;
  constructor(bridge) {
    this.#bridge = bridge;
  }

  /** @internal */
  abort = () => {
    throw new Error('abort');
  };

  /** @internal */
  __wbindgen_is_undefined = idx => {
    return this.#bridge.getObject(idx) === undefined;
  };

  /** @internal */
  __wbindgen_throw = (ptr, len) => {
    throw new Error(this.#bridge.getString(ptr, len));
  };

  /** @internal */
  __wbg_self_1b7a39e3a92c949c = () => {
    return this.#bridge.addObject(DEFAULT_SELF);
  };

  /** @internal */
  __wbg_require_604837428532a733 = (ptr, len) => {
    throw new Error(`Unable to require ${this.#bridge.getString(ptr, len)}`);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_crypto_968f1772287e2df0 = _idx => {
    return this.#bridge.addObject(DEFAULT_CRYPTO);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_getRandomValues_a3d34b4fee3c2869 = _idx => {
    return this.#bridge.addObject(DEFAULT_CRYPTO.getRandomValues);
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_getRandomValues_f5e14ab7ac8e995d = (_arg0, ptr, len) => {
    DEFAULT_CRYPTO.getRandomValues(this.#bridge.getU8a(ptr, len));
  };

  /** @internal */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  __wbg_randomFillSync_d5bd2d655fdf256a = (_idx, _ptr, _len) => {
    throw new Error('randomFillsync is not available');

    // getObject(idx).randomFillSync(getU8a(ptr, len));
  };

  /** @internal */
  __wbindgen_object_drop_ref = idx => {
    this.#bridge.takeObject(idx);
  };
}

// Copyright 2019-2022 @polkadot/wasm-bridge authors & contributors

/**
 * @name Bridge
 * @description
 * Creates a bridge between the JS and WASM environments.
 *
 * For any bridge it is passed an function white is then called internally at the
 * time of initialization. This affectively implements the layer between WASM and
 * the native environment, providing all the plumbing needed for the Wbg classes.
 */
class Bridge {
  #cachegetInt32;
  #cachegetUint8;
  #createWasm;
  #heap;
  #heapNext;
  #wasm;
  #wasmError;
  #wasmPromise;
  #wbg;
  #type;
  constructor(createWasm) {
    this.#createWasm = createWasm;
    this.#cachegetInt32 = null;
    this.#cachegetUint8 = null;
    this.#heap = new Array(32).fill(undefined).concat(undefined, null, true, false);
    this.#heapNext = this.#heap.length;
    this.#type = 'none';
    this.#wasm = null;
    this.#wasmError = null;
    this.#wasmPromise = null;
    this.#wbg = {
      ...new Wbg(this)
    };
  }

  /** @description Returns the init error */
  get error() {
    return this.#wasmError;
  }

  /** @description Returns the init type */
  get type() {
    return this.#type;
  }

  /** @description Returns the created wasm interface */
  get wasm() {
    return this.#wasm;
  }

  /** @description Performs the wasm initialization */
  async init(createWasm) {
    if (!this.#wasmPromise || createWasm) {
      this.#wasmPromise = (createWasm || this.#createWasm)(this.#wbg);
    }
    const {
      error,
      type,
      wasm
    } = await this.#wasmPromise;
    this.#type = type;
    this.#wasm = wasm;
    this.#wasmError = error;
    return this.#wasm;
  }

  /**
   * @internal
   * @description Gets an object from the heap
   */
  getObject(idx) {
    return this.#heap[idx];
  }

  /**
   * @internal
   * @description Removes an object from the heap
   */
  dropObject(idx) {
    if (idx < 36) {
      return;
    }
    this.#heap[idx] = this.#heapNext;
    this.#heapNext = idx;
  }

  /**
   * @internal
   * @description Retrieves and removes an object to the heap
   */
  takeObject(idx) {
    const ret = this.getObject(idx);
    this.dropObject(idx);
    return ret;
  }

  /**
   * @internal
   * @description Adds an object to the heap
   */
  addObject(obj) {
    if (this.#heapNext === this.#heap.length) {
      this.#heap.push(this.#heap.length + 1);
    }
    const idx = this.#heapNext;
    this.#heapNext = this.#heap[idx];
    this.#heap[idx] = obj;
    return idx;
  }

  /**
   * @internal
   * @description Retrieve an Int32 in the WASM interface
   */
  getInt32() {
    if (this.#cachegetInt32 === null || this.#cachegetInt32.buffer !== this.#wasm.memory.buffer) {
      this.#cachegetInt32 = new Int32Array(this.#wasm.memory.buffer);
    }
    return this.#cachegetInt32;
  }

  /**
   * @internal
   * @description Retrieve an Uint8Array in the WASM interface
   */
  getUint8() {
    if (this.#cachegetUint8 === null || this.#cachegetUint8.buffer !== this.#wasm.memory.buffer) {
      this.#cachegetUint8 = new Uint8Array(this.#wasm.memory.buffer);
    }
    return this.#cachegetUint8;
  }

  /**
   * @internal
   * @description Retrieves an Uint8Array in the WASM interface
   */
  getU8a(ptr, len) {
    return this.getUint8().subarray(ptr / 1, ptr / 1 + len);
  }

  /**
   * @internal
   * @description Retrieves a string in the WASM interface
   */
  getString(ptr, len) {
    return u8aToString(this.getU8a(ptr, len));
  }

  /**
   * @internal
   * @description Allocates an Uint8Array in the WASM interface
   */
  allocU8a(arg) {
    const ptr = this.#wasm.__wbindgen_malloc(arg.length * 1);
    this.getUint8().set(arg, ptr / 1);
    return [ptr, arg.length];
  }

  /**
   * @internal
   * @description Allocates a string in the WASM interface
   */
  allocString(arg) {
    return this.allocU8a(stringToU8a(arg));
  }

  /**
   * @internal
   * @description Retrieves an Uint8Array from the WASM interface
   */
  resultU8a() {
    const r0 = this.getInt32()[8 / 4 + 0];
    const r1 = this.getInt32()[8 / 4 + 1];
    const ret = this.getU8a(r0, r1).slice();
    this.#wasm.__wbindgen_free(r0, r1 * 1);
    return ret;
  }

  /**
   * @internal
   * @description Retrieve a string from the WASM interface
   */
  resultString() {
    return u8aToString(this.resultU8a());
  }
}

// Copyright 2019-2022 @polkadot/wasm-crypto authors & contributors

/**
 * @name bridge
 * @description
 * The JS <-> WASM bridge that is in operation. For the specific package
 * it is a global, i.e. all operations happens on this specific bridge
 */
const bridge = new Bridge(createWasm);

/**
 * @name initBridge
 * @description
 * Creates a new bridge interface with the (optional) initialization function
 */
async function initBridge(createWasm) {
  return bridge.init(createWasm);
}

// Copyright 2019-2022 @polkadot/wasm-crypto authors & contributors

// Removes the first parameter (expected as WasmCryptoInstance) and leaves the
// rest of the parameters in-tack. This allows us to dynamically create a function
// return from the withWasm helper

/**
 * @internal
 * @description
 * This create an extenal interface function from the signature, all the while checking
 * the actual bridge wasm interface to ensure it has been initialized.
 *
 * This means that we can call it
 *
 *   withWasm(wasm: WasmCryptoInstance, a: number, b: string) => Uint8Array
 *
 * and in this case it will create an interface function with the signarure
 *
 *   (a: number, b: string) => Uint8Array
 */
function withWasm(fn) {
  return (...params) => {
    if (!bridge.wasm) {
      throw new Error('The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');
    }
    return fn(bridge.wasm, ...params);
  };
}
const ed25519Verify$1 = /*#__PURE__*/withWasm((wasm, signature, message, pubkey) => {
  const ret = wasm.ext_ed_verify(...bridge.allocU8a(signature), ...bridge.allocU8a(message), ...bridge.allocU8a(pubkey));
  return ret !== 0;
});
const secp256k1Compress$1 = /*#__PURE__*/withWasm((wasm, pubkey) => {
  wasm.ext_secp_pub_compress(8, ...bridge.allocU8a(pubkey));
  return bridge.resultU8a();
});
const secp256k1Expand$1 = /*#__PURE__*/withWasm((wasm, pubkey) => {
  wasm.ext_secp_pub_expand(8, ...bridge.allocU8a(pubkey));
  return bridge.resultU8a();
});
const secp256k1Recover$1 = /*#__PURE__*/withWasm((wasm, msgHash, sig, recovery) => {
  wasm.ext_secp_recover(8, ...bridge.allocU8a(msgHash), ...bridge.allocU8a(sig), recovery);
  return bridge.resultU8a();
});
const sr25519Verify$1 = /*#__PURE__*/withWasm((wasm, signature, message, pubkey) => {
  const ret = wasm.ext_sr_verify(...bridge.allocU8a(signature), ...bridge.allocU8a(message), ...bridge.allocU8a(pubkey));
  return ret !== 0;
});
const blake2b$1 = /*#__PURE__*/withWasm((wasm, data, key, size) => {
  wasm.ext_blake2b(8, ...bridge.allocU8a(data), ...bridge.allocU8a(key), size);
  return bridge.resultU8a();
});
const keccak256 = /*#__PURE__*/withWasm((wasm, data) => {
  wasm.ext_keccak256(8, ...bridge.allocU8a(data));
  return bridge.resultU8a();
});
const keccak512 = /*#__PURE__*/withWasm((wasm, data) => {
  wasm.ext_keccak512(8, ...bridge.allocU8a(data));
  return bridge.resultU8a();
});
function isReady() {
  return !!bridge.wasm;
}
async function waitReady() {
  try {
    const wasm = await initBridge();
    return !!wasm;
  } catch {
    return false;
  }
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
function cryptoWaitReady() {
  return waitReady().then(() => {
    if (!isReady()) {
      throw new Error('Unable to initialize @polkadot/util-crypto');
    }
    return true;
  }).catch(() => false);
}

function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
function bytes$b(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash$2(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes$b(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
const assert$1 = {
    number,
    bool,
    bytes: bytes$b,
    hash: hash$2,
    exists,
    output,
};

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!isLE)
    throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}

const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};

/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function assertNumber(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
}
function chain(...args) {
    const wrap = (a, b) => (c) => a(b(c));
    const encode = Array.from(args)
        .reverse()
        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);
    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);
    return { encode, decode };
}
function alphabet$1(alphabet) {
    return {
        encode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('alphabet.encode input should be an array of numbers');
            return digits.map((i) => {
                assertNumber(i);
                if (i < 0 || i >= alphabet.length)
                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
                return alphabet[i];
            });
        },
        decode: (input) => {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('alphabet.decode input should be array of strings');
            return input.map((letter) => {
                if (typeof letter !== 'string')
                    throw new Error(`alphabet.decode: not string element=${letter}`);
                const index = alphabet.indexOf(letter);
                if (index === -1)
                    throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
                return index;
            });
        },
    };
}
function join(separator = '') {
    if (typeof separator !== 'string')
        throw new Error('join separator should be string');
    return {
        encode: (from) => {
            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))
                throw new Error('join.encode input should be array of strings');
            for (let i of from)
                if (typeof i !== 'string')
                    throw new Error(`join.encode: non-string input=${i}`);
            return from.join(separator);
        },
        decode: (to) => {
            if (typeof to !== 'string')
                throw new Error('join.decode input should be string');
            return to.split(separator);
        },
    };
}
function padding(bits, chr = '=') {
    assertNumber(bits);
    if (typeof chr !== 'string')
        throw new Error('padding chr should be string');
    return {
        encode(data) {
            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of data)
                if (typeof i !== 'string')
                    throw new Error(`padding.encode: non-string input=${i}`);
            while ((data.length * bits) % 8)
                data.push(chr);
            return data;
        },
        decode(input) {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of input)
                if (typeof i !== 'string')
                    throw new Error(`padding.decode: non-string input=${i}`);
            let end = input.length;
            if ((end * bits) % 8)
                throw new Error('Invalid padding: string should have whole number of bytes');
            for (; end > 0 && input[end - 1] === chr; end--) {
                if (!(((end - 1) * bits) % 8))
                    throw new Error('Invalid padding: string has too much padding');
            }
            return input.slice(0, end);
        },
    };
}
function normalize$1(fn) {
    if (typeof fn !== 'function')
        throw new Error('normalize fn should be function');
    return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
    if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data))
        throw new Error('convertRadix: data should be array');
    if (!data.length)
        return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data);
    digits.forEach((d) => {
        assertNumber(d);
        if (d < 0 || d >= from)
            throw new Error(`Wrong integer: ${d}`);
    });
    while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
            const digit = digits[i];
            const digitBase = from * carry + digit;
            if (!Number.isSafeInteger(digitBase) ||
                (from * carry) / from !== carry ||
                digitBase - digit !== from * carry) {
                throw new Error('convertRadix: carry overflow');
            }
            carry = digitBase % to;
            digits[i] = Math.floor(digitBase / to);
            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)
                throw new Error('convertRadix: carry overflow');
            if (!done)
                continue;
            else if (!digits[i])
                pos = i;
            else
                done = false;
        }
        res.push(carry);
        if (done)
            break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
    return res.reverse();
}
const gcd = (a, b) => (!b ? a : gcd(b, a % b));
const radix2carry = (from, to) => from + (to - gcd(from, to));
function convertRadix2(data, from, to, padding) {
    if (!Array.isArray(data))
        throw new Error('convertRadix2: data should be array');
    if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0;
    const mask = 2 ** to - 1;
    const res = [];
    for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
            res.push(((carry >> (pos - to)) & mask) >>> 0);
        carry &= 2 ** pos - 1;
    }
    carry = (carry << (to - pos)) & mask;
    if (!padding && pos >= from)
        throw new Error('Excess padding');
    if (!padding && carry)
        throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0)
        res.push(carry >>> 0);
    return res;
}
function radix(num) {
    assertNumber(num);
    return {
        encode: (bytes) => {
            if (!(bytes instanceof Uint8Array))
                throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), 2 ** 8, num);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix.decode input should be array of strings');
            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        },
    };
}
function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32)
        throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error('radix2: carry overflow');
    return {
        encode: (bytes) => {
            if (!(bytes instanceof Uint8Array))
                throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix2.decode input should be array of strings');
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
    };
}
function unsafeWrapper(fn) {
    if (typeof fn !== 'function')
        throw new Error('unsafeWrapper fn should be function');
    return function (...args) {
        try {
            return fn.apply(null, args);
        }
        catch (e) { }
    };
}
const base16$4 = chain(radix2(4), alphabet$1('0123456789ABCDEF'), join(''));
const base32$5 = chain(radix2(5), alphabet$1('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
chain(radix2(5), alphabet$1('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
chain(radix2(5), alphabet$1('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize$1((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
const base64$4 = chain(radix2(6), alphabet$1('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
const base64url$1 = chain(radix2(6), alphabet$1('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
const genBase58 = (abc) => chain(radix(58), alphabet$1(abc), join(''));
const base58$4 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
const base58xmr = {
    encode(data) {
        let res = '';
        for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += base58$4.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = base58$4.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
                if (block[j] !== 0)
                    throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    },
};
const BECH_ALPHABET = chain(alphabet$1('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);
    for (let v of words)
        chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        if (typeof prefix !== 'string')
            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))
            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        prefix = prefix.toLowerCase();
        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
    }
    function decode(str, limit = 90) {
        if (typeof str !== 'string')
            throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || (limit !== false && str.length > limit))
            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words = str.slice(sepIndex + 1);
        if (_words.length < 6)
            throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(_words).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
    }
    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
genBech32('bech32');
genBech32('bech32m');
const utf8$2 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str),
};
const hex = chain(radix2(4), alphabet$1('0123456789abcdef'), join(''), normalize$1((s) => {
    if (typeof s !== 'string' || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
const CODERS = {
    utf8: utf8$2, hex, base16: base16$4, base32: base32$5, base64: base64$4, base64url: base64url$1, base58: base58$4, base58xmr
};
`Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors

// re-export the type so *.d.ts files don't have ../src imports

/** @internal */
function createDecode({
  coder,
  ipfs
}, validate) {
  return (value, ipfsCompat) => {
    validate(value, ipfsCompat);
    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);
  };
}

/** @internal */
function createEncode({
  coder,
  ipfs
}) {
  return (value, ipfsCompat) => {
    const out = coder.encode(u8aToU8a(value));
    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;
  };
}

/** @internal */
function createValidate({
  chars,
  ipfs,
  type
}) {
  return (value, ipfsCompat) => {
    if (!value || typeof value !== 'string') {
      throw new Error(`Expected non-null, non-empty ${type} string input`);
    }
    if (ipfs && ipfsCompat && value[0] !== ipfs) {
      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
    }
    for (let i = ipfsCompat ? 1 : 0; i < value.length; i++) {
      if (!(chars.includes(value[i]) || value[i] === '=' && (i === value.length - 1 || !chars.includes(value[i + 1])))) {
        throw new Error(`Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
      }
    }
    return true;
  };
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
const config$1 = {
  chars: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  coder: base58$4,
  ipfs: 'z',
  type: 'base58'
};

/**
 * @name base58Validate
 * @summary Validates a base58 value.
 * @description
 * Validates that the supplied value is valid base58, throwing exceptions if not
 */
const base58Validate = /*#__PURE__*/createValidate(config$1);

/**
 * @name base58Decode
 * @summary Decodes a base58 value.
 * @description
 * From the provided input, decode the base58 and return the result as an `Uint8Array`.
 */
const base58Decode = /*#__PURE__*/createDecode(config$1, base58Validate);

/**
* @name base58Encode
* @summary Creates a base58 value.
* @description
* From the provided input, create the base58 and return the result as a string.
*/
const base58Encode = /*#__PURE__*/createEncode(config$1);

// prettier-ignore
const SIGMA = new Uint8Array([
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
    // For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
]);
class BLAKE2 extends Hash {
    constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.length = 0;
        this.pos = 0;
        this.finished = false;
        this.destroyed = false;
        assert$1.number(blockLen);
        assert$1.number(outputLen);
        assert$1.number(keyLen);
        if (outputLen < 0 || outputLen > keyLen)
            throw new Error('Blake2: outputLen bigger than keyLen');
        if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))
            throw new Error(`Key should be up 1..${keyLen} byte long or undefined`);
        if (opts.salt !== undefined && opts.salt.length !== saltLen)
            throw new Error(`Salt should be ${saltLen} byte long or undefined`);
        if (opts.personalization !== undefined && opts.personalization.length !== persLen)
            throw new Error(`Personalization should be ${persLen} byte long or undefined`);
        this.buffer32 = u32((this.buffer = new Uint8Array(blockLen)));
    }
    update(data) {
        assert$1.exists(this);
        // Main difference with other hashes: there is flag for last block,
        // so we cannot process current block before we know that there
        // is the next one. This significantly complicates logic and reduces ability
        // to do zero-copy processing
        const { blockLen, buffer, buffer32 } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            // If buffer is full and we still have input (don't process last block, same as blake2s)
            if (this.pos === blockLen) {
                this.compress(buffer32, 0, false);
                this.pos = 0;
            }
            const take = Math.min(blockLen - this.pos, len - pos);
            const dataOffset = data.byteOffset + pos;
            // full block && aligned to 4 bytes && not last in input
            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
                const data32 = new Uint32Array(data.buffer, dataOffset, Math.floor((len - pos) / 4));
                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
                    this.length += blockLen;
                    this.compress(data32, pos32, false);
                }
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            this.length += take;
            pos += take;
        }
        return this;
    }
    digestInto(out) {
        assert$1.exists(this);
        assert$1.output(out, this);
        const { pos, buffer32 } = this;
        this.finished = true;
        // Padding
        this.buffer.subarray(pos).fill(0);
        this.compress(buffer32, 0, true);
        const out32 = u32(out);
        this.get().forEach((v, i) => (out32[i] = v));
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        const { buffer, length, finished, destroyed, outputLen, pos } = this;
        to || (to = new this.constructor({ dkLen: outputLen }));
        to.set(...this.get());
        to.length = length;
        to.finished = finished;
        to.destroyed = destroyed;
        to.outputLen = outputLen;
        to.buffer.set(buffer);
        to.pos = pos;
        return to;
    }
}

// Same as SHA-512 but LE
// prettier-ignore
const IV = new Uint32Array([
    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,
    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
]);
// Temporary buffer
const BUF = new Uint32Array(32);
// Mixing function G splitted in two halfs
function G1(a, b, c, d, msg, x) {
    // NOTE: V is LE here
    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore
    let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore
    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore
    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore
    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = u64.add3L(Al, Bl, Xl);
    Ah = u64.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    // v[d] = rotr(v[d] ^ v[a], 32)
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });
    // v[c] = (v[c] + v[d]) | 0;
    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));
    // v[b] = rotr(v[b] ^ v[c], 24)
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });
    (BUF[2 * a] = Al), (BUF[2 * a + 1] = Ah);
    (BUF[2 * b] = Bl), (BUF[2 * b + 1] = Bh);
    (BUF[2 * c] = Cl), (BUF[2 * c + 1] = Ch);
    (BUF[2 * d] = Dl), (BUF[2 * d + 1] = Dh);
}
function G2(a, b, c, d, msg, x) {
    // NOTE: V is LE here
    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore
    let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore
    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore
    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore
    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = u64.add3L(Al, Bl, Xl);
    Ah = u64.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    // v[d] = rotr(v[d] ^ v[a], 16)
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });
    // v[c] = (v[c] + v[d]) | 0;
    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));
    // v[b] = rotr(v[b] ^ v[c], 63)
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });
    (BUF[2 * a] = Al), (BUF[2 * a + 1] = Ah);
    (BUF[2 * b] = Bl), (BUF[2 * b + 1] = Bh);
    (BUF[2 * c] = Cl), (BUF[2 * c + 1] = Ch);
    (BUF[2 * d] = Dl), (BUF[2 * d + 1] = Dh);
}
class BLAKE2b extends BLAKE2 {
    constructor(opts = {}) {
        super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);
        // Same as SHA-512, but LE
        this.v0l = IV[0] | 0;
        this.v0h = IV[1] | 0;
        this.v1l = IV[2] | 0;
        this.v1h = IV[3] | 0;
        this.v2l = IV[4] | 0;
        this.v2h = IV[5] | 0;
        this.v3l = IV[6] | 0;
        this.v3h = IV[7] | 0;
        this.v4l = IV[8] | 0;
        this.v4h = IV[9] | 0;
        this.v5l = IV[10] | 0;
        this.v5h = IV[11] | 0;
        this.v6l = IV[12] | 0;
        this.v6h = IV[13] | 0;
        this.v7l = IV[14] | 0;
        this.v7h = IV[15] | 0;
        const keyLength = opts.key ? opts.key.length : 0;
        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);
        if (opts.salt) {
            const salt = u32(toBytes(opts.salt));
            this.v4l ^= salt[0];
            this.v4h ^= salt[1];
            this.v5l ^= salt[2];
            this.v5h ^= salt[3];
        }
        if (opts.personalization) {
            const pers = u32(toBytes(opts.personalization));
            this.v6l ^= pers[0];
            this.v6h ^= pers[1];
            this.v7l ^= pers[2];
            this.v7h ^= pers[3];
        }
        if (opts.key) {
            // Pad to blockLen and update
            const tmp = new Uint8Array(this.blockLen);
            tmp.set(toBytes(opts.key));
            this.update(tmp);
        }
    }
    // prettier-ignore
    get() {
        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
    }
    // prettier-ignore
    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
        this.v0l = v0l | 0;
        this.v0h = v0h | 0;
        this.v1l = v1l | 0;
        this.v1h = v1h | 0;
        this.v2l = v2l | 0;
        this.v2h = v2h | 0;
        this.v3l = v3l | 0;
        this.v3h = v3h | 0;
        this.v4l = v4l | 0;
        this.v4h = v4h | 0;
        this.v5l = v5l | 0;
        this.v5h = v5h | 0;
        this.v6l = v6l | 0;
        this.v6h = v6h | 0;
        this.v7l = v7l | 0;
        this.v7h = v7h | 0;
    }
    compress(msg, offset, isLast) {
        this.get().forEach((v, i) => (BUF[i] = v)); // First half from state.
        BUF.set(IV, 16); // Second half from IV.
        let { h, l } = u64.fromBig(BigInt(this.length));
        BUF[24] = IV[8] ^ l; // Low word of the offset.
        BUF[25] = IV[9] ^ h; // High word.
        // Invert all bits for last block
        if (isLast) {
            BUF[28] = ~BUF[28];
            BUF[29] = ~BUF[29];
        }
        let j = 0;
        const s = SIGMA;
        for (let i = 0; i < 12; i++) {
            G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);
            G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);
            G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);
            G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);
            G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);
            G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);
            G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);
            G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);
            G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);
            G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);
            G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);
            G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);
            G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);
            G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);
            G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);
            G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);
        }
        this.v0l ^= BUF[0] ^ BUF[16];
        this.v0h ^= BUF[1] ^ BUF[17];
        this.v1l ^= BUF[2] ^ BUF[18];
        this.v1h ^= BUF[3] ^ BUF[19];
        this.v2l ^= BUF[4] ^ BUF[20];
        this.v2h ^= BUF[5] ^ BUF[21];
        this.v3l ^= BUF[6] ^ BUF[22];
        this.v3h ^= BUF[7] ^ BUF[23];
        this.v4l ^= BUF[8] ^ BUF[24];
        this.v4h ^= BUF[9] ^ BUF[25];
        this.v5l ^= BUF[10] ^ BUF[26];
        this.v5h ^= BUF[11] ^ BUF[27];
        this.v6l ^= BUF[12] ^ BUF[28];
        this.v6h ^= BUF[13] ^ BUF[29];
        this.v7l ^= BUF[14] ^ BUF[30];
        this.v7h ^= BUF[15] ^ BUF[31];
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer32.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
/**
 * BLAKE2b - optimized for 64-bit platforms. JS doesn't have uint64, so it's slower than BLAKE2s.
 * @param msg - message that would be hashed
 * @param opts - dkLen, key, salt, personalization
 */
const blake2b = wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors

/** @internal */
function createDualHasher(wa, js) {
  return (value, bitLength = 256, onlyJs) => {
    const u8a = u8aToU8a(value);
    return !hasBigInt || !onlyJs && isReady() ? wa[bitLength](u8a) : js[bitLength](u8a);
  };
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors

/**
 * @name blake2AsU8a
 * @summary Creates a blake2b u8a from the input.
 * @description
 * From a `Uint8Array` input, create the blake2b and return the result as a u8a with the specified `bitLength`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { blake2AsU8a } from '@polkadot/util-crypto';
 *
 * blake2AsU8a('abc'); // => [0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d]
 * ```
 */
function blake2AsU8a(data, bitLength = 256, key, onlyJs) {
  const byteLength = Math.ceil(bitLength / 8);
  const u8a = u8aToU8a(data);
  return !hasBigInt || !onlyJs && isReady() ? blake2b$1(u8a, u8aToU8a(key), byteLength) : blake2b(u8a, {
    dkLen: byteLength,
    key: key || undefined
  });
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
const SS58_PREFIX = stringToU8a('SS58PRE');
function sshash(key) {
  return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
function checkAddressChecksum(decoded) {
  const ss58Length = decoded[0] & 0b01000000 ? 2 : 1;
  const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 0b00111111) << 2 | decoded[1] >> 6 | (decoded[1] & 0b00111111) << 8;

  // 32/33 bytes public + 2 bytes checksum + prefix
  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
  const length = decoded.length - (isPublicKey ? 2 : 1);

  // calculate the hash and do the checksum byte checks
  const hash = sshash(decoded.subarray(0, length));
  const isValid = (decoded[0] & 0b10000000) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);
  return [isValid, length, ss58Length, ss58Decoded];
}

// Copyright (C) 2021-2022 Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var knownSubstrate = [
	{
		"prefix": 0,
		"network": "polkadot",
		"displayName": "Polkadot Relay Chain",
		"symbols": [
			"DOT"
		],
		"decimals": [
			10
		],
		"standardAccount": "*25519",
		"website": "https://polkadot.network"
	},
	{
		"prefix": 1,
		"network": "BareSr25519",
		"displayName": "Bare 32-bit Schnorr/Ristretto (S/R 25519) public key.",
		"symbols": [],
		"decimals": [],
		"standardAccount": "Sr25519",
		"website": null
	},
	{
		"prefix": 2,
		"network": "kusama",
		"displayName": "Kusama Relay Chain",
		"symbols": [
			"KSM"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://kusama.network"
	},
	{
		"prefix": 3,
		"network": "BareEd25519",
		"displayName": "Bare 32-bit Ed25519 public key.",
		"symbols": [],
		"decimals": [],
		"standardAccount": "Ed25519",
		"website": null
	},
	{
		"prefix": 4,
		"network": "katalchain",
		"displayName": "Katal Chain",
		"symbols": [],
		"decimals": [],
		"standardAccount": "*25519",
		"website": null
	},
	{
		"prefix": 5,
		"network": "astar",
		"displayName": "Astar Network",
		"symbols": [
			"ASTR"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://astar.network"
	},
	{
		"prefix": 6,
		"network": "bifrost",
		"displayName": "Bifrost",
		"symbols": [
			"BNC"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://bifrost.finance/"
	},
	{
		"prefix": 7,
		"network": "edgeware",
		"displayName": "Edgeware",
		"symbols": [
			"EDG"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://edgewa.re"
	},
	{
		"prefix": 8,
		"network": "karura",
		"displayName": "Karura",
		"symbols": [
			"KAR"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://karura.network/"
	},
	{
		"prefix": 9,
		"network": "reynolds",
		"displayName": "Laminar Reynolds Canary",
		"symbols": [
			"REY"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "http://laminar.network/"
	},
	{
		"prefix": 10,
		"network": "acala",
		"displayName": "Acala",
		"symbols": [
			"ACA"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://acala.network/"
	},
	{
		"prefix": 11,
		"network": "laminar",
		"displayName": "Laminar",
		"symbols": [
			"LAMI"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "http://laminar.network/"
	},
	{
		"prefix": 12,
		"network": "polymesh",
		"displayName": "Polymesh",
		"symbols": [
			"POLYX"
		],
		"decimals": [
			6
		],
		"standardAccount": "*25519",
		"website": "https://polymath.network/"
	},
	{
		"prefix": 13,
		"network": "integritee",
		"displayName": "Integritee",
		"symbols": [
			"TEER"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://integritee.network"
	},
	{
		"prefix": 14,
		"network": "totem",
		"displayName": "Totem",
		"symbols": [
			"TOTEM"
		],
		"decimals": [
			0
		],
		"standardAccount": "*25519",
		"website": "https://totemaccounting.com"
	},
	{
		"prefix": 15,
		"network": "synesthesia",
		"displayName": "Synesthesia",
		"symbols": [
			"SYN"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://synesthesia.network/"
	},
	{
		"prefix": 16,
		"network": "kulupu",
		"displayName": "Kulupu",
		"symbols": [
			"KLP"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://kulupu.network/"
	},
	{
		"prefix": 17,
		"network": "dark",
		"displayName": "Dark Mainnet",
		"symbols": [],
		"decimals": [],
		"standardAccount": "*25519",
		"website": null
	},
	{
		"prefix": 18,
		"network": "darwinia",
		"displayName": "Darwinia Network",
		"symbols": [
			"RING",
			"KTON"
		],
		"decimals": [
			9,
			9
		],
		"standardAccount": "*25519",
		"website": "https://darwinia.network/"
	},
	{
		"prefix": 19,
		"network": "watr",
		"displayName": "Watr Protocol",
		"symbols": [
			"WATR"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://www.watr.org"
	},
	{
		"prefix": 20,
		"network": "stafi",
		"displayName": "Stafi",
		"symbols": [
			"FIS"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://stafi.io"
	},
	{
		"prefix": 22,
		"network": "dock-pos-mainnet",
		"displayName": "Dock Mainnet",
		"symbols": [
			"DCK"
		],
		"decimals": [
			6
		],
		"standardAccount": "*25519",
		"website": "https://dock.io"
	},
	{
		"prefix": 23,
		"network": "shift",
		"displayName": "ShiftNrg",
		"symbols": [],
		"decimals": [],
		"standardAccount": "*25519",
		"website": null
	},
	{
		"prefix": 24,
		"network": "zero",
		"displayName": "ZERO",
		"symbols": [
			"ZERO"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://zero.io"
	},
	{
		"prefix": 25,
		"network": "zero-alphaville",
		"displayName": "ZERO Alphaville",
		"symbols": [
			"ZERO"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://zero.io"
	},
	{
		"prefix": 26,
		"network": "jupiter",
		"displayName": "Jupiter",
		"symbols": [
			"jDOT"
		],
		"decimals": [
			10
		],
		"standardAccount": "*25519",
		"website": "https://jupiter.patract.io"
	},
	{
		"prefix": 27,
		"network": "kabocha",
		"displayName": "Kabocha",
		"symbols": [
			"KAB"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://kabocha.network"
	},
	{
		"prefix": 28,
		"network": "subsocial",
		"displayName": "Subsocial",
		"symbols": [],
		"decimals": [],
		"standardAccount": "*25519",
		"website": null
	},
	{
		"prefix": 29,
		"network": "cord",
		"displayName": "CORD Network",
		"symbols": [
			"DHI",
			"WAY"
		],
		"decimals": [
			12,
			12
		],
		"standardAccount": "*25519",
		"website": "https://cord.network/"
	},
	{
		"prefix": 30,
		"network": "phala",
		"displayName": "Phala Network",
		"symbols": [
			"PHA"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://phala.network"
	},
	{
		"prefix": 31,
		"network": "litentry",
		"displayName": "Litentry Network",
		"symbols": [
			"LIT"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://litentry.com/"
	},
	{
		"prefix": 32,
		"network": "robonomics",
		"displayName": "Robonomics",
		"symbols": [
			"XRT"
		],
		"decimals": [
			9
		],
		"standardAccount": "*25519",
		"website": "https://robonomics.network"
	},
	{
		"prefix": 33,
		"network": "datahighway",
		"displayName": "DataHighway",
		"symbols": [],
		"decimals": [],
		"standardAccount": "*25519",
		"website": null
	},
	{
		"prefix": 34,
		"network": "ares",
		"displayName": "Ares Protocol",
		"symbols": [
			"ARES"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://www.aresprotocol.com/"
	},
	{
		"prefix": 35,
		"network": "vln",
		"displayName": "Valiu Liquidity Network",
		"symbols": [
			"USDv"
		],
		"decimals": [
			15
		],
		"standardAccount": "*25519",
		"website": "https://valiu.com/"
	},
	{
		"prefix": 36,
		"network": "centrifuge",
		"displayName": "Centrifuge Chain",
		"symbols": [
			"CFG"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://centrifuge.io/"
	},
	{
		"prefix": 37,
		"network": "nodle",
		"displayName": "Nodle Chain",
		"symbols": [
			"NODL"
		],
		"decimals": [
			11
		],
		"standardAccount": "*25519",
		"website": "https://nodle.io/"
	},
	{
		"prefix": 38,
		"network": "kilt",
		"displayName": "KILT Spiritnet",
		"symbols": [
			"KILT"
		],
		"decimals": [
			15
		],
		"standardAccount": "*25519",
		"website": "https://kilt.io/"
	},
	{
		"prefix": 39,
		"network": "mathchain",
		"displayName": "MathChain mainnet",
		"symbols": [
			"MATH"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://mathwallet.org"
	},
	{
		"prefix": 40,
		"network": "mathchain-testnet",
		"displayName": "MathChain testnet",
		"symbols": [
			"MATH"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://mathwallet.org"
	},
	{
		"prefix": 41,
		"network": "poli",
		"displayName": "Polimec Chain",
		"symbols": [],
		"decimals": [],
		"standardAccount": "*25519",
		"website": "https://polimec.io/"
	},
	{
		"prefix": 42,
		"network": "substrate",
		"displayName": "Substrate",
		"symbols": [],
		"decimals": [],
		"standardAccount": "*25519",
		"website": "https://substrate.io/"
	},
	{
		"prefix": 43,
		"network": "BareSecp256k1",
		"displayName": "Bare 32-bit ECDSA SECP-256k1 public key.",
		"symbols": [],
		"decimals": [],
		"standardAccount": "secp256k1",
		"website": null
	},
	{
		"prefix": 44,
		"network": "chainx",
		"displayName": "ChainX",
		"symbols": [
			"PCX"
		],
		"decimals": [
			8
		],
		"standardAccount": "*25519",
		"website": "https://chainx.org/"
	},
	{
		"prefix": 45,
		"network": "uniarts",
		"displayName": "UniArts Network",
		"symbols": [
			"UART",
			"UINK"
		],
		"decimals": [
			12,
			12
		],
		"standardAccount": "*25519",
		"website": "https://uniarts.me"
	},
	{
		"prefix": 46,
		"network": "reserved46",
		"displayName": "This prefix is reserved.",
		"symbols": [],
		"decimals": [],
		"standardAccount": null,
		"website": null
	},
	{
		"prefix": 47,
		"network": "reserved47",
		"displayName": "This prefix is reserved.",
		"symbols": [],
		"decimals": [],
		"standardAccount": null,
		"website": null
	},
	{
		"prefix": 48,
		"network": "neatcoin",
		"displayName": "Neatcoin Mainnet",
		"symbols": [
			"NEAT"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://neatcoin.org"
	},
	{
		"prefix": 49,
		"network": "picasso",
		"displayName": "Picasso",
		"symbols": [
			"PICA"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://picasso.composable.finance"
	},
	{
		"prefix": 50,
		"network": "composable",
		"displayName": "Composable",
		"symbols": [
			"LAYR"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://composable.finance"
	},
	{
		"prefix": 51,
		"network": "oak",
		"displayName": "OAK Network",
		"symbols": [
			"OAK",
			"TUR"
		],
		"decimals": [
			10,
			10
		],
		"standardAccount": "*25519",
		"website": "https://oak.tech"
	},
	{
		"prefix": 52,
		"network": "KICO",
		"displayName": "KICO",
		"symbols": [
			"KICO"
		],
		"decimals": [
			14
		],
		"standardAccount": "*25519",
		"website": "https://dico.io"
	},
	{
		"prefix": 53,
		"network": "DICO",
		"displayName": "DICO",
		"symbols": [
			"DICO"
		],
		"decimals": [
			14
		],
		"standardAccount": "*25519",
		"website": "https://dico.io"
	},
	{
		"prefix": 54,
		"network": "cere",
		"displayName": "Cere Network",
		"symbols": [
			"CERE"
		],
		"decimals": [
			10
		],
		"standardAccount": "*25519",
		"website": "https://cere.network"
	},
	{
		"prefix": 55,
		"network": "xxnetwork",
		"displayName": "xx network",
		"symbols": [
			"XX"
		],
		"decimals": [
			9
		],
		"standardAccount": "*25519",
		"website": "https://xx.network"
	},
	{
		"prefix": 56,
		"network": "pendulum",
		"displayName": "Pendulum chain",
		"symbols": [
			"PEN"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://pendulumchain.org/"
	},
	{
		"prefix": 57,
		"network": "amplitude",
		"displayName": "Amplitude chain",
		"symbols": [
			"AMPE"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://pendulumchain.org/"
	},
	{
		"prefix": 63,
		"network": "hydradx",
		"displayName": "HydraDX",
		"symbols": [
			"HDX"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://hydradx.io"
	},
	{
		"prefix": 65,
		"network": "aventus",
		"displayName": "AvN Mainnet",
		"symbols": [
			"AVT"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://aventus.io"
	},
	{
		"prefix": 66,
		"network": "crust",
		"displayName": "Crust Network",
		"symbols": [
			"CRU"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://crust.network"
	},
	{
		"prefix": 67,
		"network": "genshiro",
		"displayName": "Genshiro Network",
		"symbols": [
			"GENS",
			"EQD",
			"LPT0"
		],
		"decimals": [
			9,
			9,
			9
		],
		"standardAccount": "*25519",
		"website": "https://genshiro.equilibrium.io"
	},
	{
		"prefix": 68,
		"network": "equilibrium",
		"displayName": "Equilibrium Network",
		"symbols": [
			"EQ"
		],
		"decimals": [
			9
		],
		"standardAccount": "*25519",
		"website": "https://equilibrium.io"
	},
	{
		"prefix": 69,
		"network": "sora",
		"displayName": "SORA Network",
		"symbols": [
			"XOR"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://sora.org"
	},
	{
		"prefix": 71,
		"network": "p3d",
		"displayName": "3DP network",
		"symbols": [
			"P3D"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://3dpass.org"
	},
	{
		"prefix": 72,
		"network": "p3dt",
		"displayName": "3DP test network",
		"symbols": [
			"P3Dt"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://3dpass.org"
	},
	{
		"prefix": 73,
		"network": "zeitgeist",
		"displayName": "Zeitgeist",
		"symbols": [
			"ZTG"
		],
		"decimals": [
			10
		],
		"standardAccount": "*25519",
		"website": "https://zeitgeist.pm"
	},
	{
		"prefix": 77,
		"network": "manta",
		"displayName": "Manta network",
		"symbols": [
			"MANTA"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://manta.network"
	},
	{
		"prefix": 78,
		"network": "calamari",
		"displayName": "Calamari: Manta Canary Network",
		"symbols": [
			"KMA"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://manta.network"
	},
	{
		"prefix": 81,
		"network": "sora_dot_para",
		"displayName": "SORA Polkadot Parachain",
		"symbols": [
			"XOR"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://sora.org"
	},
	{
		"prefix": 88,
		"network": "polkadex",
		"displayName": "Polkadex Mainnet",
		"symbols": [
			"PDEX"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://polkadex.trade"
	},
	{
		"prefix": 89,
		"network": "polkadexparachain",
		"displayName": "Polkadex Parachain",
		"symbols": [
			"PDEX"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://polkadex.trade"
	},
	{
		"prefix": 90,
		"network": "frequency",
		"displayName": "Frequency",
		"symbols": [
			"FRQCY"
		],
		"decimals": [
			8
		],
		"standardAccount": "*25519",
		"website": "https://www.frequency.xyz"
	},
	{
		"prefix": 92,
		"network": "anmol",
		"displayName": "Anmol Network",
		"symbols": [
			"ANML"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://anmol.network/"
	},
	{
		"prefix": 93,
		"network": "fragnova",
		"displayName": "Fragnova Network",
		"symbols": [
			"NOVA"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://fragnova.com"
	},
	{
		"prefix": 98,
		"network": "polkasmith",
		"displayName": "PolkaSmith Canary Network",
		"symbols": [
			"PKS"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://polkafoundry.com"
	},
	{
		"prefix": 99,
		"network": "polkafoundry",
		"displayName": "PolkaFoundry Network",
		"symbols": [
			"PKF"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://polkafoundry.com"
	},
	{
		"prefix": 100,
		"network": "ibtida",
		"displayName": "Anmol Network Ibtida Canary network",
		"symbols": [
			"IANML"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://anmol.network/"
	},
	{
		"prefix": 101,
		"network": "origintrail-parachain",
		"displayName": "OriginTrail Parachain",
		"symbols": [
			"OTP"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://parachain.origintrail.io/"
	},
	{
		"prefix": 105,
		"network": "pontem-network",
		"displayName": "Pontem Network",
		"symbols": [
			"PONT"
		],
		"decimals": [
			10
		],
		"standardAccount": "*25519",
		"website": "https://pontem.network"
	},
	{
		"prefix": 110,
		"network": "heiko",
		"displayName": "Heiko",
		"symbols": [
			"HKO"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://parallel.fi/"
	},
	{
		"prefix": 113,
		"network": "integritee-incognito",
		"displayName": "Integritee Incognito",
		"symbols": [],
		"decimals": [],
		"standardAccount": "*25519",
		"website": "https://integritee.network"
	},
	{
		"prefix": 117,
		"network": "tinker",
		"displayName": "Tinker",
		"symbols": [
			"TNKR"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://invarch.network"
	},
	{
		"prefix": 126,
		"network": "joystream",
		"displayName": "Joystream",
		"symbols": [
			"JOY"
		],
		"decimals": [
			10
		],
		"standardAccount": "*25519",
		"website": "https://www.joystream.org"
	},
	{
		"prefix": 128,
		"network": "clover",
		"displayName": "Clover Finance",
		"symbols": [
			"CLV"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://clover.finance"
	},
	{
		"prefix": 129,
		"network": "dorafactory-polkadot",
		"displayName": "Dorafactory Polkadot Network",
		"symbols": [
			"DORA"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://dorafactory.org"
	},
	{
		"prefix": 131,
		"network": "litmus",
		"displayName": "Litmus Network",
		"symbols": [
			"LIT"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://litentry.com/"
	},
	{
		"prefix": 136,
		"network": "altair",
		"displayName": "Altair",
		"symbols": [
			"AIR"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://centrifuge.io/"
	},
	{
		"prefix": 137,
		"network": "vara",
		"displayName": "Vara Network",
		"symbols": [
			"VARA"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://vara-network.io/"
	},
	{
		"prefix": 172,
		"network": "parallel",
		"displayName": "Parallel",
		"symbols": [
			"PARA"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://parallel.fi/"
	},
	{
		"prefix": 252,
		"network": "social-network",
		"displayName": "Social Network",
		"symbols": [
			"NET"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://social.network"
	},
	{
		"prefix": 255,
		"network": "quartz_mainnet",
		"displayName": "QUARTZ by UNIQUE",
		"symbols": [
			"QTZ"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://unique.network"
	},
	{
		"prefix": 268,
		"network": "pioneer_network",
		"displayName": "Pioneer Network by Bit.Country",
		"symbols": [
			"NEER"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://bit.country"
	},
	{
		"prefix": 420,
		"network": "sora_kusama_para",
		"displayName": "SORA Kusama Parachain",
		"symbols": [
			"XOR"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://sora.org"
	},
	{
		"prefix": 789,
		"network": "geek",
		"displayName": "GEEK Network",
		"symbols": [
			"GEEK"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://geek.gl"
	},
	{
		"prefix": 1110,
		"network": "efinity",
		"displayName": "Efinity",
		"symbols": [
			"EFI"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://efinity.io/"
	},
	{
		"prefix": 1221,
		"network": "peaq",
		"displayName": "Peaq Network",
		"symbols": [
			"PEAQ"
		],
		"decimals": [
			18
		],
		"standardAccount": "Sr25519",
		"website": "https://www.peaq.network/"
	},
	{
		"prefix": 1222,
		"network": "krest",
		"displayName": "Krest Network",
		"symbols": [
			"KREST"
		],
		"decimals": [
			18
		],
		"standardAccount": "Sr25519",
		"website": "https://www.peaq.network/"
	},
	{
		"prefix": 1284,
		"network": "moonbeam",
		"displayName": "Moonbeam",
		"symbols": [
			"GLMR"
		],
		"decimals": [
			18
		],
		"standardAccount": "secp256k1",
		"website": "https://moonbeam.network"
	},
	{
		"prefix": 1285,
		"network": "moonriver",
		"displayName": "Moonriver",
		"symbols": [
			"MOVR"
		],
		"decimals": [
			18
		],
		"standardAccount": "secp256k1",
		"website": "https://moonbeam.network"
	},
	{
		"prefix": 1328,
		"network": "ajuna",
		"displayName": "Ajuna Network",
		"symbols": [
			"AJUN"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://ajuna.io"
	},
	{
		"prefix": 1337,
		"network": "bajun",
		"displayName": "Bajun Network",
		"symbols": [
			"BAJU"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://ajuna.io"
	},
	{
		"prefix": 1985,
		"network": "seals",
		"displayName": "Seals Network",
		"symbols": [
			"SEAL"
		],
		"decimals": [
			9
		],
		"standardAccount": "*25519",
		"website": "https://seals.app"
	},
	{
		"prefix": 2007,
		"network": "kapex",
		"displayName": "Kapex",
		"symbols": [
			"KAPEX"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://totemaccounting.com"
	},
	{
		"prefix": 2009,
		"network": "cloudwalk_mainnet",
		"displayName": "CloudWalk Network Mainnet",
		"symbols": [
			"CWN"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://explorer.mainnet.cloudwalk.io"
	},
	{
		"prefix": 2032,
		"network": "interlay",
		"displayName": "Interlay",
		"symbols": [
			"INTR"
		],
		"decimals": [
			10
		],
		"standardAccount": "*25519",
		"website": "https://interlay.io/"
	},
	{
		"prefix": 2092,
		"network": "kintsugi",
		"displayName": "Kintsugi",
		"symbols": [
			"KINT"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://interlay.io/"
	},
	{
		"prefix": 2106,
		"network": "bitgreen",
		"displayName": "Bitgreen",
		"symbols": [
			"BBB"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://bitgreen.org/"
	},
	{
		"prefix": 2112,
		"network": "chainflip",
		"displayName": "Chainflip",
		"symbols": [
			"FLIP"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://chainflip.io/"
	},
	{
		"prefix": 2114,
		"network": "Turing",
		"displayName": "Turing Network",
		"symbols": [
			"TUR"
		],
		"decimals": [
			10
		],
		"standardAccount": "*25519",
		"website": "https://oak.tech/turing/home/"
	},
	{
		"prefix": 2207,
		"network": "SNOW",
		"displayName": "SNOW: ICE Canary Network",
		"symbols": [
			"ICZ"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://icenetwork.io"
	},
	{
		"prefix": 2208,
		"network": "ICE",
		"displayName": "ICE Network",
		"symbols": [
			"ICY"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://icenetwork.io"
	},
	{
		"prefix": 2254,
		"network": "subspace_testnet",
		"displayName": "Subspace testnet",
		"symbols": [
			"tSSC"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://subspace.network"
	},
	{
		"prefix": 4006,
		"network": "tangle",
		"displayName": "Tangle Network",
		"symbols": [
			"TNT"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://www.webb.tools/"
	},
	{
		"prefix": 4450,
		"network": "g1",
		"displayName": "Ğ1",
		"symbols": [
			"G1"
		],
		"decimals": [
			2
		],
		"standardAccount": "*25519",
		"website": "https://duniter.org"
	},
	{
		"prefix": 5234,
		"network": "humanode",
		"displayName": "Humanode Network",
		"symbols": [
			"HMND"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://humanode.io"
	},
	{
		"prefix": 6094,
		"network": "subspace",
		"displayName": "Subspace",
		"symbols": [
			"SSC"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://subspace.network"
	},
	{
		"prefix": 7007,
		"network": "tidefi",
		"displayName": "Tidefi",
		"symbols": [
			"TDFY"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://tidefi.com"
	},
	{
		"prefix": 7013,
		"network": "gm",
		"displayName": "GM",
		"symbols": [
			"FREN",
			"GM",
			"GN"
		],
		"decimals": [
			12,
			0,
			0
		],
		"standardAccount": "*25519",
		"website": "https://gmordie.com"
	},
	{
		"prefix": 7391,
		"network": "unique_mainnet",
		"displayName": "Unique Network",
		"symbols": [
			"UNQ"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://unique.network"
	},
	{
		"prefix": 8883,
		"network": "sapphire_mainnet",
		"displayName": "Sapphire by Unique",
		"symbols": [
			"QTZ"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://unique.network"
	},
	{
		"prefix": 9072,
		"network": "hashed",
		"displayName": "Hashed Network",
		"symbols": [
			"HASH"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://hashed.network"
	},
	{
		"prefix": 9807,
		"network": "dentnet",
		"displayName": "DENTNet",
		"symbols": [
			"DENTX"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://www.dentnet.io"
	},
	{
		"prefix": 9935,
		"network": "t3rn",
		"displayName": "t3rn",
		"symbols": [
			"TRN"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://t3rn.io/"
	},
	{
		"prefix": 10041,
		"network": "basilisk",
		"displayName": "Basilisk",
		"symbols": [
			"BSX"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://bsx.fi"
	},
	{
		"prefix": 11330,
		"network": "cess-testnet",
		"displayName": "CESS Testnet",
		"symbols": [
			"TCESS"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://cess.cloud"
	},
	{
		"prefix": 11331,
		"network": "cess",
		"displayName": "CESS",
		"symbols": [
			"CESS"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://cess.cloud"
	},
	{
		"prefix": 11486,
		"network": "luhn",
		"displayName": "Luhn Network",
		"symbols": [
			"LUHN"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://luhn.network"
	},
	{
		"prefix": 11820,
		"network": "contextfree",
		"displayName": "Automata ContextFree",
		"symbols": [
			"CTX"
		],
		"decimals": [
			18
		],
		"standardAccount": "*25519",
		"website": "https://ata.network"
	},
	{
		"prefix": 12191,
		"network": "nftmart",
		"displayName": "NFTMart",
		"symbols": [
			"NMT"
		],
		"decimals": [
			12
		],
		"standardAccount": "*25519",
		"website": "https://nftmart.io"
	}
];

// Copyright 2017-2022 @polkadot/networks authors & contributors
// SPDX-License-Identifier: Apache-2.0

// NOTE: In the case where the network was hard-spooned and multiple genesisHashes
// are provided, it needs to be in reverse order, i.e. most-recent first, oldest
// last. This make lookups for the current a simple genesisHash[0]
// (See Kusama as an example)
const knownGenesis = {
  acala: ['0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c'],
  ajuna: ['0xe358eb1d11b31255a286c12e44fe6780b7edb171d657905a97e39f71d9c6c3ee'],
  'aleph-node': ['0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e'],
  astar: ['0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6'],
  basilisk: ['0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755'],
  bifrost: ['0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b'],
  'bifrost-kusama': ['0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed'],
  centrifuge: ['0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82', '0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5'],
  composable: ['0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d'],
  darwinia: ['0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6'],
  'dock-mainnet': ['0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae', '0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9'],
  edgeware: ['0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b'],
  equilibrium: ['0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925'],
  genshiro: ['0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243'],
  hydradx: ['0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d',
  // HydraDX Parachain
  '0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc',
  // Snakenet Gen3-1
  '0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9',
  // Snakenet Gen3
  '0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047',
  // Snakenet Gen2
  '0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2' // Snakenet Gen1
  ],

  'interlay-parachain': ['0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72'],
  karura: ['0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b'],
  khala: ['0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d'],
  kulupu: ['0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba'],
  kusama: ['0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe',
  // Kusama CC3,
  '0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636',
  // Kusama CC2
  '0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf' // Kusama CC1
  ],

  'nodle-para': ['0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21'],
  origintrail: ['0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174'],
  parallel: ['0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97'],
  phala: ['0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736'],
  picasso: ['0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c'],
  polkadex: ['0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c'],
  polkadot: ['0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3'],
  polymesh: ['0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063'],
  rococo: ['0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e', '0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897', '0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770', '0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff', '0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a', '0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9', '0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779', '0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215', '0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9', '0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147', '0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd', '0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299'],
  sora: ['0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5'],
  stafi: ['0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80'],
  statemine: ['0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a'],
  statemint: ['0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f'],
  subsocial: ['0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8'],
  unique: ['0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31'],
  vtb: ['0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f', '0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa'],
  westend: ['0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e'],
  xxnetwork: ['0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa']
};

// Copyright 2017-2022 @polkadot/networks authors & contributors
// SPDX-License-Identifier: Apache-2.0

// these are icon overrides
const knownIcon = {
  centrifuge: 'polkadot',
  kusama: 'polkadot',
  polkadot: 'polkadot',
  sora: 'polkadot',
  statemine: 'polkadot',
  statemint: 'polkadot',
  westmint: 'polkadot'
};

// Copyright 2017-2022 @polkadot/networks authors & contributors
// SPDX-License-Identifier: Apache-2.0

// These match up with the keys of the ledgerApps object in the @polkadot/hw-ledger/defaults.ts
// and maps to the known slip44 (minus the `0x8` hard derivation flag)
//
// NOTE: Any network here needs to have a genesisHash attached in the ./genesis.ts config
const knownLedger = {
  acala: 0x00000313,
  ajuna: 0x00000162,
  'aleph-node': 0x00000283,
  astar: 0x0000032a,
  bifrost: 0x00000314,
  'bifrost-kusama': 0x00000314,
  centrifuge: 0x000002eb,
  composable: 0x00000162,
  darwinia: 0x00000162,
  'dock-mainnet': 0x00000252,
  edgeware: 0x0000020b,
  equilibrium: 0x05f5e0fd,
  genshiro: 0x05f5e0fc,
  hydradx: 0x00000162,
  'interlay-parachain': 0x00000162,
  karura: 0x000002ae,
  khala: 0x000001b2,
  kusama: 0x000001b2,
  'nodle-para': 0x000003eb,
  origintrail: 0x00000162,
  parallel: 0x00000162,
  phala: 0x00000162,
  polkadex: 0x0000031f,
  polkadot: 0x00000162,
  polymesh: 0x00000253,
  sora: 0x00000269,
  stafi: 0x0000038b,
  statemine: 0x000001b2,
  // common-good on Kusama, shares derivation
  statemint: 0x00000162,
  // common-good on Polkadot, shares derivation
  unique: 0x00000162,
  vtb: 0x000002b6,
  xxnetwork: 0x000007a3
};

// Copyright 2017-2022 @polkadot/networks authors & contributors
// SPDX-License-Identifier: Apache-2.0

// testnets should not allow selection
const knownTestnet = {
  '': true,
  // this is the default non-network entry
  'cess-testnet': true,
  'dock-testnet': true,
  jupiter: true,
  'mathchain-testnet': true,
  p3dt: true,
  subspace_testnet: true,
  'zero-alphaville': true
};

// Copyright 2017-2022 @polkadot/networks authors & contributors

// These are known prefixes that are not sorted
const UNSORTED = [0, 2, 42];
const TESTNETS = ['testnet'];
function toExpanded(o) {
  const network = o.network || '';
  const nameParts = network.replace(/_/g, '-').split('-');
  const n = o;

  // ledger additions
  n.slip44 = knownLedger[network];
  n.hasLedgerSupport = !!n.slip44;

  // general items
  n.genesisHash = knownGenesis[network] || [];
  n.icon = knownIcon[network] || 'substrate';

  // filtering
  n.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
  n.isIgnored = n.isTestnet || !(o.standardAccount && o.decimals && o.decimals.length && o.symbols && o.symbols.length) && o.prefix !== 42;
  return n;
}
function filterSelectable({
  genesisHash,
  prefix
}) {
  return !!genesisHash.length || prefix === 42;
}
function filterAvailable(n) {
  return !n.isIgnored && !!n.network;
}
function sortNetworks(a, b) {
  const isUnSortedA = UNSORTED.includes(a.prefix);
  const isUnSortedB = UNSORTED.includes(b.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a.displayName.localeCompare(b.displayName) : isUnSortedA ? -1 : 1;
}

// This is all the Substrate networks with our additional information
const allNetworks = knownSubstrate.map(toExpanded);

// The list of available/claimed prefixes
//   - no testnets
//   - we only include those where we have a standardAccount
//   - sort by name, however we keep 0, 2, 42 first in the list
const availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);

// A filtered list of those chains we have details about (genesisHashes)
availableNetworks.filter(filterSelectable);

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
const defaults = {
  allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
  // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
  allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
  allowedPrefix: availableNetworks.map(({
    prefix
  }) => prefix),
  prefix: 42
};

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
  if (!encoded) {
    throw new Error('Invalid empty address passed');
  }
  if (isU8a(encoded) || isHex(encoded)) {
    return u8aToU8a(encoded);
  }
  try {
    const decoded = base58Decode(encoded);
    if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
      throw new Error('Invalid decoded address length');
    }
    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
    if (!isValid && !ignoreChecksum) {
      throw new Error('Invalid decoded address checksum');
    } else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {
      throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
    }
    return decoded.slice(ss58Length, endPos);
  } catch (error) {
    throw new Error(`Decoding ${encoded}: ${error.message}`);
  }
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
const BN_BE_256_OPTS = {
  bitLength: 256,
  isLe: false
};

var naclFast = {exports: {}};

(function (module) {
(function(nacl) {

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (typeof commonjsRequire !== 'undefined') {
    // Node.js.
    crypto = nodeCrypto__default;
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(module.exports ? module.exports : (self.nacl = self.nacl || {}));
}(naclFast));

var nacl = naclFast.exports;

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors

/**
 * @name ed25519Sign
 * @summary Verifies the signature on the supplied message.
 * @description
 * Verifies the `signature` on `message` with the supplied `publicKey`. Returns `true` on sucess, `false` otherwise.
 * @example
 * <BR>
 *
 * ```javascript
 * import { ed25519Verify } from '@polkadot/util-crypto';
 *
 * ed25519Verify([...], [...], [...]); // => true/false
 * ```
 */
function ed25519Verify(message, signature, publicKey, onlyJs) {
  const messageU8a = u8aToU8a(message);
  const publicKeyU8a = u8aToU8a(publicKey);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length}, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  return !onlyJs && isReady() ? ed25519Verify$1(signatureU8a, messageU8a, publicKeyU8a) : nacl.sign.detached.verify(messageU8a, signatureU8a, publicKeyU8a);
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors

/**
 * @name sr25519Verify
 * @description Verifies the signature of `message`, using the supplied pair
 */
function sr25519Verify(message, signature, publicKey) {
  const publicKeyU8a = u8aToU8a(publicKey);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  return sr25519Verify$1(signatureU8a, u8aToU8a(message), publicKeyU8a);
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
function encodeAddress(key, ss58Format = defaults.prefix) {
  // decode it, this means we can re-encode an address
  const u8a = decodeAddress(key);
  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {
    throw new Error('Out of range ss58Format specified');
  } else if (!defaults.allowedDecodedLengths.includes(u8a.length)) {
    throw new Error(`Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(', ')}`);
  }
  const input = u8aConcat(ss58Format < 64 ? [ss58Format] : [(ss58Format & 0b0000000011111100) >> 2 | 0b01000000, ss58Format >> 8 | (ss58Format & 0b0000000000000011) << 6], u8a);
  return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
}

// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        assert$1.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        assert$1.exists(this);
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        assert$1.exists(this, false);
        assert$1.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        assert$1.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        assert$1.output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
gen(0x06, 136, 256 / 8);
gen(0x06, 104, 384 / 8);
gen(0x06, 72, 512 / 8);
gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = gen(0x01, 136, 256 / 8);
gen(0x01, 104, 384 / 8);
const keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
genShake(0x1f, 168, 128 / 8);
genShake(0x1f, 136, 256 / 8);

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors

/**
 * @name keccakAsU8a
 * @summary Creates a keccak Uint8Array from the input.
 * @description
 * From either a `string` or a `Buffer` input, create the keccak and return the result as a `Uint8Array`.
 * @example
 * <BR>
 *
 * ```javascript
 * import { keccakAsU8a } from '@polkadot/util-crypto';
 *
 * keccakAsU8a('123'); // => Uint8Array
 * ```
 */
const keccakAsU8a = /*#__PURE__*/createDualHasher({
  256: keccak256,
  512: keccak512
}, {
  256: keccak_256,
  512: keccak_512
});

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
function hasher$5(hashType, data, onlyJs) {
  return hashType === 'keccak' ? keccakAsU8a(data, undefined, onlyJs) : blake2AsU8a(data, undefined, undefined, onlyJs);
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
function secp256k1Compress(publicKey, onlyJs) {
  if (publicKey.length === 33) {
    return publicKey;
  }
  if (publicKey.length !== 65) {
    throw new Error('Invalid publicKey provided');
  }
  return !hasBigInt || !onlyJs && isReady() ? secp256k1Compress$1(publicKey) : Point$1.fromHex(publicKey).toRawBytes(true);
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
function secp256k1Expand(publicKey, onlyJs) {
  if (publicKey.length === 65) {
    return publicKey.subarray(1);
  }
  if (publicKey.length !== 33) {
    throw new Error('Invalid publicKey provided');
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Expand$1(publicKey).subarray(1);
  }
  const {
    x,
    y
  } = Point$1.fromHex(publicKey);
  return u8aConcat(bnToU8a(x, BN_BE_256_OPTS), bnToU8a(y, BN_BE_256_OPTS));
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors

/**
 * @name secp256k1Recover
 * @description Recovers a publicKey from the supplied signature
 */
function secp256k1Recover(msgHash, signature, recovery, hashType = 'blake2', onlyJs) {
  const sig = u8aToU8a(signature).subarray(0, 64);
  const msg = u8aToU8a(msgHash);
  const publicKey = !hasBigInt || !onlyJs && isReady() ? secp256k1Recover$1(msg, sig, recovery) : recoverPublicKey(msg, Signature.fromCompact(sig).toRawBytes(), recovery);
  if (!publicKey) {
    throw new Error('Unable to recover publicKey from signature');
  }
  return hashType === 'keccak' ? secp256k1Expand(publicKey, onlyJs) : secp256k1Compress(publicKey, onlyJs);
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors

/**
 * @name secp256k1Verify
 * @description Verifies the signature of `message`, using the supplied pair
 */
function secp256k1Verify(msgHash, signature, address, hashType = 'blake2', onlyJs) {
  const sig = u8aToU8a(signature);
  if (sig.length !== 65) {
    throw new Error(`Expected signature with 65 bytes, ${sig.length} found instead`);
  }
  const publicKey = secp256k1Recover(hasher$5(hashType, msgHash), sig, sig[64], hashType, onlyJs);
  const signerAddr = hasher$5(hashType, publicKey, onlyJs);
  const inputAddr = u8aToU8a(address);

  // for Ethereum (keccak) the last 20 bytes is the address
  return u8aEq(publicKey, inputAddr) || (hashType === 'keccak' ? u8aEq(signerAddr.slice(-20), inputAddr.slice(-20)) : u8aEq(signerAddr, inputAddr));
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
function getH160(u8a) {
  if ([33, 65].includes(u8a.length)) {
    u8a = keccakAsU8a(secp256k1Expand(u8a));
  }
  return u8a.slice(-20);
}
function ethereumEncode(addressOrPublic) {
  if (!addressOrPublic) {
    return '0x';
  }
  const u8aAddress = u8aToU8a(addressOrPublic);
  if (![20, 32, 33, 65].includes(u8aAddress.length)) {
    throw new Error('Invalid address or publicKey passed');
  }
  const address = u8aToHex(getH160(u8aAddress), -1, false);
  const hash = u8aToHex(keccakAsU8a(address), -1, false);
  let result = '';
  for (let i = 0; i < 40; i++) {
    result = `${result}${parseInt(hash[i], 16) > 7 ? address[i].toUpperCase() : address[i]}`;
  }
  return `0x${result}`;
}

// Copyright 2017-2022 @polkadot/util-crypto authors & contributors
const secp256k1VerifyHasher = hashType => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType);
const VERIFIERS_ECDSA = [['ecdsa', secp256k1VerifyHasher('blake2')], ['ethereum', secp256k1VerifyHasher('keccak')]];
const VERIFIERS = [['ed25519', ed25519Verify], ['sr25519', sr25519Verify], ...VERIFIERS_ECDSA];
const CRYPTO_TYPES = ['ed25519', 'sr25519', 'ecdsa'];
function verifyDetect(result, {
  message,
  publicKey,
  signature
}, verifiers = VERIFIERS) {
  result.isValid = verifiers.some(([crypto, verify]) => {
    try {
      if (verify(message, signature, publicKey)) {
        result.crypto = crypto;
        return true;
      }
    } catch (error) {
      // do nothing, result.isValid still set to false
    }
    return false;
  });
  return result;
}
function verifyMultisig(result, {
  message,
  publicKey,
  signature
}) {
  if (![0, 1, 2].includes(signature[0])) {
    throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);
  }
  const type = CRYPTO_TYPES[signature[0]] || 'none';
  result.crypto = type;
  try {
    result.isValid = {
      ecdsa: () => verifyDetect(result, {
        message,
        publicKey,
        signature: signature.subarray(1)
      }, VERIFIERS_ECDSA).isValid,
      ed25519: () => ed25519Verify(message, signature.subarray(1), publicKey),
      none: () => {
        throw Error('no verify for `none` crypto type');
      },
      sr25519: () => sr25519Verify(message, signature.subarray(1), publicKey)
    }[type]();
  } catch (error) {
    // ignore, result.isValid still set to false
  }
  return result;
}
function getVerifyFn(signature) {
  return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length) ? verifyMultisig : verifyDetect;
}
function signatureVerify(message, signature, addressOrPublicKey) {
  const signatureU8a = u8aToU8a(signature);
  if (![64, 65, 66].includes(signatureU8a.length)) {
    throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);
  }
  const publicKey = decodeAddress(addressOrPublicKey);
  const input = {
    message: u8aToU8a(message),
    publicKey,
    signature: signatureU8a
  };
  const result = {
    crypto: 'none',
    isValid: false,
    isWrapped: u8aIsWrapped(input.message, true),
    publicKey
  };
  const isWrappedBytes = u8aIsWrapped(input.message, false);
  const verifyFn = getVerifyFn(signatureU8a);
  verifyFn(result, input);
  if (result.crypto !== 'none' || result.isWrapped && !isWrappedBytes) {
    return result;
  }
  input.message = isWrappedBytes ? u8aUnwrapBytes(input.message) : u8aWrapBytes(input.message);
  return verifyFn(result, input);
}

// Copyright 2019-2022 @polkadot/extension-dapp authors & contributors
// SPDX-License-Identifier: Apache-2.0

function documentReadyPromise(creator) {
  return new Promise(resolve => {
    if (document.readyState === 'complete') {
      resolve(creator());
    } else {
      window.addEventListener('load', () => resolve(creator()));
    }
  });
}

// Copyright 2019-2022 @polkadot/extension-dapp authors & contributors

// just a helper (otherwise we cast all-over, so shorter and more readable)
const win = window;

// don't clobber the existing object, but ensure non-undefined
win.injectedWeb3 = win.injectedWeb3 || {};

// true when anything has been injected and is available
function web3IsInjected() {
  return Object.values(win.injectedWeb3).filter(({
    connect,
    enable
  }) => !!(connect || enable)).length !== 0;
}

// helper to throw a consistent error when not enabled
function throwError(method) {
  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);
}

// internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>
function mapAccounts(source, list, ss58Format) {
  return list.map(({
    address,
    genesisHash,
    name,
    type
  }) => ({
    address: address.length === 42 ? address : encodeAddress(decodeAddress(address), ss58Format),
    meta: {
      genesisHash,
      name,
      source
    },
    type
  }));
}

// internal helper to filter accounts
function filterAccounts(list, genesisHash, type) {
  return list.filter(a => (!a.type || !type || type.includes(a.type)) && (!a.genesisHash || !genesisHash || a.genesisHash === genesisHash));
}

// have we found a properly constructed window.injectedWeb3
web3IsInjected();

// we keep the last promise created around (for queries)
let web3EnablePromise = null;
function getWindowExtensions(originName) {
  return Promise.all(Object.entries(win.injectedWeb3).map(([nameOrHash, {
    connect,
    enable,
    version
  }]) => Promise.resolve().then(() => connect
  // new style, returning all info
  ? connect(originName) : enable
  // previous interface, leakages on name/version
  ? enable(originName).then(e => objectSpread({
    name: nameOrHash,
    version: version || 'unknown'
  }, e)) : Promise.reject(new Error('No connect(..) or enable(...) hook found'))).catch(({
    message
  }) => {
    console.error(`Error initializing ${nameOrHash}: ${message}`);
  }))).then(exts => exts.filter(e => !!e));
}

// enables all the providers found on the injected window interface
function web3Enable(originName, compatInits = []) {
  if (!originName) {
    throw new Error('You must pass a name for your app to the web3Enable function');
  }
  const initCompat = compatInits.length ? Promise.all(compatInits.map(c => c().catch(() => false))) : Promise.resolve([true]);
  web3EnablePromise = documentReadyPromise(() => initCompat.then(() => getWindowExtensions(originName).then(values => values.map(e => {
    // if we don't have an accounts subscriber, add a single-shot version
    if (!e.accounts.subscribe) {
      e.accounts.subscribe = cb => {
        e.accounts.get().then(cb).catch(console.error);
        return () => {
          // no ubsubscribe needed, this is a single-shot
        };
      };
    }
    return e;
  })).catch(() => []).then(values => {
    const names = values.map(({
      name,
      version
    }) => `${name}/${version}`);
    web3IsInjected();
    console.info(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);
    return values;
  })));
  return web3EnablePromise;
}

// retrieve all the accounts across all providers
async function web3Accounts({
  accountType,
  extensions,
  genesisHash,
  ss58Format
} = {}) {
  if (!web3EnablePromise) {
    return throwError('web3Accounts');
  }
  const accounts = [];
  const sources = await web3EnablePromise;
  const retrieved = await Promise.all(sources.filter(({
    name: source
  }) => !extensions || extensions.includes(source)).map(async ({
    accounts,
    name: source
  }) => {
    try {
      const list = await accounts.get();
      return mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format);
    } catch (error) {
      // cannot handle this one
      return [];
    }
  }));
  retrieved.forEach(result => {
    accounts.push(...result);
  });
  console.info(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}`);
  return accounts;
}

var VIEWS = {
    EXTENSIONS: 'EXTENSIONS',
    ACCOUNTS: 'ACCOUNTS',
    WALLETS: 'WALLETS',
};
var EXTENSIONS_LIST = {
    talisman: {
        name: 'Talisman',
        logo: 'data:image/svg+xml;base64,CjxzdmcgZmlsbD0ibm9uZSIgaGVpZ2h0PSI2NCIgdmlld0JveD0iMCAwIDY0IDY0IiB3aWR0aD0iNjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggY2xpcC1ydWxlPSJldmVub2RkIiBkPSJtNTAuMTE2MSAzNS42NjMxYy42MDgxIDEuMzI0MyAyLjM5ODcgMS43OTIgMy40MjkxLjc2MTZsMS44ODk3LTEuODg5N2MxLjk1MjYtMS45NTI2IDUuMTE4NC0xLjk1MjYgNy4wNzExIDAgMS45NTI2IDEuOTUyNiAxLjk1MjYgNS4xMTg1IDAgNy4wNzExbC0xNS4yNzIxIDE1LjI3MmMtMy42Njg3IDQuMzU1LTkuMTYyNiA3LjEyMTktMTUuMzAyNyA3LjEyMTktNi40MDI5IDAtMTIuMTAzMS0zLjAwODktMTUuNzYzNy03LjY4OTlsLTE0LjcwMzEtMTQuNzAzMWMtMS45NTI2MjctMS45NTI2LTEuOTUyNjI3LTUuMTE4NCAwLTcuMDcxIDEuOTUyNjItMS45NTI2IDUuMTE4NDQtMS45NTI2IDcuMDcxMDYgMGwxLjg2MTA0IDEuODYxYzEuMDA3OSAxLjAwNzkgMi43NTc2LjU1NDUgMy4zNTMtLjc0MDYuMTE3Ni0uMjU1OS4xODE1LS41MzA1LjE4MTUtLjgxMjF2LTIyLjg0NDRjMC0yLjc2MTM5IDIuMjM4Ni00Ljk5OTk2IDUtNC45OTk5NnM1IDIuMjM4NTcgNSA0Ljk5OTk2djExLjU1NjVjMCAuOTk0NCAxLjAxODcgMS42Njk0IDEuOTY2OCAxLjM2OTcuNjAwMS0uMTg5NiAxLjAzMzctLjczNiAxLjAzMzctMS4zNjUzdi0xOC41NjA3OWMwLTIuNzYxNDIgMi4yMzg1LTQuOTk5OTg5NDMgNS00Ljk5OTk5MDE1IDIuNzYxNC0uMDAwMDAwNzMgNSAyLjIzODU3MDE1IDUgNC45OTk5OTAxNXYxOC41NjExOWMwIC42MjkyLjQzMzQgMS4xNzU0IDEuMDMzMyAxLjM2NS45NDc5LjI5OTYgMS45NjYzLS4zNzUyIDEuOTY2My0xLjM2OTN2LTExLjU1N2MwLTIuNzYxMzkgMi4yMzg1LTQuOTk5OTYgNS00Ljk5OTk2IDIuNzYxNCAwIDQuOTk5OSAyLjIzODU3IDQuOTk5OSA0Ljk5OTk2bC4wMDAxIDIyLjgzNTFjMCAuMjg3Mi4wNjUyLjU2NzEuMTg1LjgyODF6IiBmaWxsPSIjZmQ0ODQ4IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48cGF0aCBkPSJtNDcuOTMxOSA0NS45OTk5cy03LjE2MzUgMTAtMTYgMTBjLTguODM2NiAwLTE2LTEwLTE2LTEwczcuMTYzNC0xMCAxNi0xMGM4LjgzNjUgMCAxNiAxMCAxNiAxMHoiIGZpbGw9IiNkNWZmNWMiLz48ZyBzdHJva2U9IiNmZDQ4NDgiPjxwYXRoIGQ9Im0zOS40MzE1IDQ2LjAwMDFjMCA0LjE0MTktMy4zNTc3IDcuNDk5Ni03LjQ5OTYgNy40OTk2cy03LjQ5OTYtMy4zNTc3LTcuNDk5Ni03LjQ5OTYgMy4zNTc3LTcuNDk5NiA3LjQ5OTYtNy40OTk2IDcuNDk5NiAzLjM1NzcgNy40OTk2IDcuNDk5NnoiIHN0cm9rZS13aWR0aD0iMS4wMDA3OCIvPjxwYXRoIGQ9Im0zNi40MzEyIDQ2LjAwMDRjMCAyLjQ4NS0yLjAxNDUgNC40OTk2LTQuNDk5NiA0LjQ5OTYtMi40ODUgMC00LjQ5OTYtMi4wMTQ2LTQuNDk5Ni00LjQ5OTYgMC0yLjQ4NTEgMi4wMTQ2LTQuNDk5NyA0LjQ5OTYtNC40OTk3IDIuNDg1MSAwIDQuNDk5NiAyLjAxNDYgNC40OTk2IDQuNDk5N3oiIHN0cm9rZS13aWR0aD0iMS4wMDA3OCIvPjxwYXRoIGQ9Im00Mi40MzEyIDQ2LjAwMDFjMCA1Ljc5ODctNC43MDA4IDEwLjQ5OTYtMTAuNDk5NiAxMC40OTk2LTUuNzk4NyAwLTEwLjQ5OTYtNC43MDA4LTEwLjQ5OTYtMTAuNDk5NnM0LjcwMDktMTAuNDk5NiAxMC40OTk2LTEwLjQ5OTZjNS43OTg4IDAgMTAuNDk5NiA0LjcwMDggMTAuNDk5NiAxMC40OTk2eiIgc3Ryb2tlLXdpZHRoPSIxLjAwMDc4Ii8+PHBhdGggZD0ibTQ1LjQzMTIgNDZjMCA3LjQ1NTctNi4wNDM5IDEzLjQ5OTYtMTMuNDk5NiAxMy40OTk2LTcuNDU1NiAwLTEzLjQ5OTYtNi4wNDM5LTEzLjQ5OTYtMTMuNDk5NiAwLTcuNDU1NiA2LjA0NC0xMy40OTk2IDEzLjQ5OTYtMTMuNDk5NiA3LjQ1NTcgMCAxMy40OTk2IDYuMDQ0IDEzLjQ5OTYgMTMuNDk5NnoiIHN0cm9rZS13aWR0aD0iMS4wMDA3OCIvPjxwYXRoIGQ9Im0zMy40MzE1IDQ1Ljk5OTljMCAuODI4Mi0uNjcxNCAxLjQ5OTYtMS40OTk2IDEuNDk5NnMtMS40OTk2LS42NzE0LTEuNDk5Ni0xLjQ5OTYuNjcxNC0xLjQ5OTYgMS40OTk2LTEuNDk5NiAxLjQ5OTYuNjcxNCAxLjQ5OTYgMS40OTk2eiIgZmlsbD0iIzE2MmJlYiIgc3Ryb2tlLXdpZHRoPSIxLjAwMDc4Ii8+PC9nPjxlbGxpcHNlIGN4PSIzMS45MzE5IiBjeT0iNDUuOTk5OSIgZmlsbD0iI2ZkNDg0OCIgcng9IjIiIHJ5PSIyIi8+PHBhdGggZD0ibTE2LjY1MTYgNDYuMTIyYy0uMDM0Mi0uMDQzOS0uMDY1Ny0uMDg0Ni0uMDk0NC0uMTIyMS4wMjg3LS4wMzc0LjA2MDItLjA3ODEuMDk0NC0uMTIyLjIwODYtLjI2NzYuNTE3Ni0uNjUxNy45MTY0LTEuMTEzNC43OTgtLjkyNDEgMS45NTI0LTIuMTU1NiAzLjM3NzItMy4zODU4IDIuODY1MS0yLjQ3MzggNi43NDk2LTQuODc4NCAxMC45ODY3LTQuODc4NCA0LjIzNyAwIDguMTIxNiAyLjQwNDYgMTAuOTg2NyA0Ljg3ODQgMS40MjQ3IDEuMjMwMiAyLjU3OTEgMi40NjE3IDMuMzc3MiAzLjM4NTguMzk4Ny40NjE3LjcwNzguODQ1OC45MTYzIDEuMTEzNC4wMzQzLjA0MzguMDY1OC4wODQ2LjA5NDUuMTIyLS4wMjg3LjAzNzUtLjA2MDIuMDc4Mi0uMDk0NS4xMjIxLS4yMDg1LjI2NzYtLjUxNzYuNjUxNy0uOTE2MyAxLjExMzQtLjc5ODEuOTI0MS0xLjk1MjUgMi4xNTU2LTMuMzc3MiAzLjM4NTgtMi44NjUxIDIuNDczOC02Ljc0OTcgNC44NzgzLTEwLjk4NjcgNC44NzgzLTQuMjM3MSAwLTguMTIxNi0yLjQwNDUtMTAuOTg2Ny00Ljg3ODMtMS40MjQ4LTEuMjMwMi0yLjU3OTItMi40NjE3LTMuMzc3Mi0zLjM4NTgtLjM5ODgtLjQ2MTctLjcwNzgtLjg0NTgtLjkxNjQtMS4xMTM0eiIgc3Ryb2tlPSIjZDVmZjVjIiBzdHJva2Utd2lkdGg9IjEuMDAwNzgiLz48L3N2Zz4=',
        download_url: 'https://chrome.google.com/webstore/detail/talisman-polkadot-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld',
        documentation_url: 'https://docs.talisman.xyz/talisman/explore-the-paraverse/talisman-wallet',
    },
    'subwallet-js': {
        name: 'Subwallet',
        logo: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM0IiBoZWlnaHQ9IjEzNCIgdmlld0JveD0iMCAwIDEzNCAxMzQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxtYXNrIGlkPSJtYXNrMF82OTlfNTEwMSIgc3R5bGU9Im1hc2stdHlwZTphbHBoYSIgbWFza1VuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeD0iMCIgeT0iMCIgd2lkdGg9IjEzNCIgaGVpZ2h0PSIxMzQiPgo8cmVjdCB3aWR0aD0iMTM0IiBoZWlnaHQ9IjEzNCIgZmlsbD0iI0M0QzRDNCIvPgo8L21hc2s+CjxnIG1hc2s9InVybCgjbWFzazBfNjk5XzUxMDEpIj4KPHBhdGggZD0iTTg3Ljk2MTUgNjQuMzIwMUw4Ny45NDU2IDQ3Ljc0NTVMMjcuMTE5MSAxNi4yMjM2VjY0LjMwNDFMNjYuMDU4OSA4NS4xMDZMODAuMjg4NCA3OC44MzY3TDM3LjQ0MDMgNTYuMTA0NkwzNy40NzIyIDM3Ljg4N0w4Ny45NjE1IDY0LjMyMDFaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfNjk5XzUxMDEpIi8+CjxwYXRoIGQ9Ik01MC43NjA3IDQ0Ljg0MjFWNTAuNTA1MkwzNy4zOTI2IDU2LjIzMjFMMzcuNDg4MyAzNy42NjM2TDUwLjc2MDcgNDQuODQyMVoiIGZpbGw9InVybCgjcGFpbnQxX2xpbmVhcl82OTlfNTEwMSkiLz4KPHBhdGggZD0iTTUwLjgwOTUgOTEuODIyTDgwLjI4OTUgNzguODM2OEwzNy40NDE0IDU2LjIxNjNMNTAuNjgxOSA1MC41MDU0TDEwNS43NjUgNzkuMjgzNUw1MC45MjEyIDEwMy4yMTJMNTAuODA5NSA5MS44MjJaIiBmaWxsPSJ1cmwoI3BhaW50Ml9saW5lYXJfNjk5XzUxMDEpIi8+CjxwYXRoIGQ9Ik0zNy40ODg2IDg3Ljk3NzNMNTAuNjQ5MyA4Mi4yOTgyTDUwLjkzNjUgMTAzLjE5NkwxMDUuNzY1IDc5LjI4MzJWOTcuMTE4TDM3LjM3NyAxMjcuMDc3TDM3LjQ4ODYgODcuOTc3M1oiIGZpbGw9InVybCgjcGFpbnQzX2xpbmVhcl82OTlfNTEwMSkiLz4KPHBhdGggZD0iTTI3LjExOTEgODIuNTg1N0wzNy40NDAzIDg3Ljk3NzZMMzcuMzc2NSAxMjcuMDEzTDI3LjExOTEgMTIxLjg2VjgyLjU4NTdaIiBmaWxsPSJ1cmwoI3BhaW50NF9saW5lYXJfNjk5XzUxMDEpIi8+CjxwYXRoIGQ9Ik00MC4xNTIyIDc2Ljc3OTFMNTAuNjQ4OSA4Mi4yOTg2TDM3LjQ0MDMgODcuOTc3NkwyNy4xMTkxIDgyLjU4NTdMNDAuMTUyMiA3Ni43NzkxWiIgZmlsbD0idXJsKCNwYWludDVfbGluZWFyXzY5OV81MTAxKSIvPgo8cGF0aCBkPSJNMTA1Ljc2NSA1Ni41OTkzTDEwNS43MDIgMzkuOTEzMUw4Ny45Nzg1IDQ3Ljc0NTdWNjQuMzM2MkwxMDUuNzY1IDU2LjU5OTNaIiBmaWxsPSJ1cmwoI3BhaW50Nl9saW5lYXJfNjk5XzUxMDEpIi8+CjxwYXRoIGQ9Ik0yNy4xMTkxIDE2LjIyMzdMNDUuMDMzNyA3Ljk3NjMyTDEwNS43MzIgMzkuODgxMUw4Ny45Nzc1IDQ3Ljc0NTZMMjcuMTE5MSAxNi4yMjM3WiIgZmlsbD0idXJsKCNwYWludDdfbGluZWFyXzY5OV81MTAxKSIvPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNjk5XzUxMDEiIHgxPSIxMS45MDA2IiB5MT0iNTAuNjY0OCIgeDI9IjExOS4zNzIiIHkyPSI1MC42NjQ4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRkQ0QjIiLz4KPHN0b3Agb2Zmc2V0PSIwLjM2IiBzdG9wLWNvbG9yPSIjOUFDRUI3Ii8+CjxzdG9wIG9mZnNldD0iMC42NyIgc3RvcC1jb2xvcj0iIzQ3QzhCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuODkiIHN0b3AtY29sb3I9IiMxNEM1QkUiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDBDNEJGIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl82OTlfNTEwMSIgeDE9IjQ0LjA3NjYiIHkxPSI2Mi44NTI0IiB4Mj0iNDQuMDc2NiIgeTI9IjIxLjIxNjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzAwRkVDRiIvPgo8c3RvcCBvZmZzZXQ9IjAuMDgiIHN0b3AtY29sb3I9IiMwMEU1RDAiLz4KPHN0b3Agb2Zmc2V0PSIwLjI0IiBzdG9wLWNvbG9yPSIjMDBBNUQxIi8+CjxzdG9wIG9mZnNldD0iMC40OCIgc3RvcC1jb2xvcj0iIzAwNDBENCIvPgo8c3RvcCBvZmZzZXQ9IjAuNTQiIHN0b3AtY29sb3I9IiMwMDI1RDUiLz4KPHN0b3Agb2Zmc2V0PSIxIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl82OTlfNTEwMSIgeDE9IjM3LjQ0MTQiIHkxPSI3Ni44NTg3IiB4Mj0iMTQ2Ljg5MSIgeTI9Ijc2Ljg1ODciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZERUM5RiIvPgo8c3RvcCBvZmZzZXQ9IjAuMDgiIHN0b3AtY29sb3I9IiNFNEQ4QTQiLz4KPHN0b3Agb2Zmc2V0PSIwLjI0IiBzdG9wLWNvbG9yPSIjQTRBNkIyIi8+CjxzdG9wIG9mZnNldD0iMC40NyIgc3RvcC1jb2xvcj0iIzNGNTdDOCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjEiIHN0b3AtY29sb3I9IiMwMDI1RDUiLz4KPHN0b3Agb2Zmc2V0PSIxIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQzX2xpbmVhcl82OTlfNTEwMSIgeDE9IjE1LjA1OTYiIHkxPSIxMDMuMTgiIHgyPSIxNTUuMDEiIHkyPSIxMDMuMTgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjA1IiBzdG9wLWNvbG9yPSIjNjJBNUZGIi8+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzEwMzJEMSIvPgo8c3RvcCBvZmZzZXQ9IjEiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDRfbGluZWFyXzY5OV81MTAxIiB4MT0iNjI4Ljc0MSIgeTE9IjMyNDQuOTMiIHgyPSI3OTcuNzgyIiB5Mj0iMzI0Ny4xMiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjRkZENEIyIi8+CjxzdG9wIG9mZnNldD0iMC4zNiIgc3RvcC1jb2xvcj0iIzlBQ0VCNyIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiM0N0M4QkIiLz4KPHN0b3Agb2Zmc2V0PSIwLjg5IiBzdG9wLWNvbG9yPSIjMTRDNUJFIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAwQzRCRiIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NV9saW5lYXJfNjk5XzUxMDEiIHgxPSIyNC41OTg3IiB5MT0iODIuMzc4MyIgeDI9IjcyLjU4MzQiIHkyPSI4Mi4zNzgzIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMEZFQ0YiLz4KPHN0b3Agb2Zmc2V0PSIwLjA4IiBzdG9wLWNvbG9yPSIjMDBFNUQwIi8+CjxzdG9wIG9mZnNldD0iMC4yNSIgc3RvcC1jb2xvcj0iIzAwQTVEMSIvPgo8c3RvcCBvZmZzZXQ9IjAuNDkiIHN0b3AtY29sb3I9IiMwMDQwRDQiLz4KPHN0b3Agb2Zmc2V0PSIwLjU2IiBzdG9wLWNvbG9yPSIjMDAyNUQ1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ2X2xpbmVhcl82OTlfNTEwMSIgeDE9IjcwLjk1NzMiIHkxPSI1Mi41OTUyIiB4Mj0iMTg5LjA2OSIgeTI9IjUwLjQ1NzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzAwRkVDRiIvPgo8c3RvcCBvZmZzZXQ9IjAuMDUiIHN0b3AtY29sb3I9IiMwMEU1RDAiLz4KPHN0b3Agb2Zmc2V0PSIwLjE1IiBzdG9wLWNvbG9yPSIjMDBBNUQxIi8+CjxzdG9wIG9mZnNldD0iMC4yOSIgc3RvcC1jb2xvcj0iIzAwNDBENCIvPgo8c3RvcCBvZmZzZXQ9IjAuMzMiIHN0b3AtY29sb3I9IiMwMDI1RDUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDdfbGluZWFyXzY5OV81MTAxIiB4MT0iMjcuMTE5MSIgeTE9IjI3Ljg2ODkiIHgyPSIxNzMuNjQyIiB5Mj0iMjcuODY4OSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjRkZENEFGIi8+CjxzdG9wIG9mZnNldD0iMC4xIiBzdG9wLWNvbG9yPSIjRTZENUJBIi8+CjxzdG9wIG9mZnNldD0iMC4zMSIgc3RvcC1jb2xvcj0iI0E3RDZENSIvPgo8c3RvcCBvZmZzZXQ9IjAuNjEiIHN0b3AtY29sb3I9IiM0M0Q5RkYiLz4KPHN0b3Agb2Zmc2V0PSIwLjYzIiBzdG9wLWNvbG9yPSIjMzdCMUQwIi8+CjxzdG9wIG9mZnNldD0iMC42NSIgc3RvcC1jb2xvcj0iIzJCOENBNSIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiMyMTZCN0QiLz4KPHN0b3Agb2Zmc2V0PSIwLjciIHN0b3AtY29sb3I9IiMxODRFNUIiLz4KPHN0b3Agb2Zmc2V0PSIwLjcyIiBzdG9wLWNvbG9yPSIjMTAzNTNGIi8+CjxzdG9wIG9mZnNldD0iMC43NSIgc3RvcC1jb2xvcj0iIzBBMjIyOCIvPgo8c3RvcCBvZmZzZXQ9IjAuNzgiIHN0b3AtY29sb3I9IiMwNjEzMTYiLz4KPHN0b3Agb2Zmc2V0PSIwLjgyIiBzdG9wLWNvbG9yPSIjMDIwODA5Ii8+CjxzdG9wIG9mZnNldD0iMC44OCIgc3RvcC1jb2xvcj0iIzAxMDIwMiIvPgo8c3RvcCBvZmZzZXQ9IjEiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K',
        download_url: 'https://subwallet.app/download.html',
        documentation_url: 'https://docs.subwallet.app/user-guide/create-an-account/create-a-new-account-wallet',
    },
    'polkadot-js': {
        name: 'Polkadot.{js}',
        logo: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjE1IDE1IDE0MCAxNDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDE3MCAxNzA7em9vbTogMTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LmJnMHtmaWxsOiNGRjhDMDB9IC5zdDB7ZmlsbDojRkZGRkZGfTwvc3R5bGU+PGc+PGNpcmNsZSBjbGFzcz0iYmcwIiBjeD0iODUiIGN5PSI4NSIgcj0iNzAiPjwvY2lyY2xlPjxnPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik04NSwzNC43Yy0yMC44LDAtMzcuOCwxNi45LTM3LjgsMzcuOGMwLDQuMiwwLjcsOC4zLDIsMTIuM2MwLjksMi43LDMuOSw0LjIsNi43LDMuM2MyLjctMC45LDQuMi0zLjksMy4zLTYuNyBjLTEuMS0zLjEtMS42LTYuNC0xLjUtOS43QzU4LjEsNTcuNiw2OS41LDQ2LDgzLjYsNDUuM2MxNS43LTAuOCwyOC43LDExLjcsMjguNywyNy4yYzAsMTQuNS0xMS40LDI2LjQtMjUuNywyNy4yIGMwLDAtNS4zLDAuMy03LjksMC43Yy0xLjMsMC4yLTIuMywwLjQtMywwLjVjLTAuMywwLjEtMC42LTAuMi0wLjUtMC41bDAuOS00LjRMODEsNzMuNGMwLjYtMi44LTEuMi01LjYtNC02LjIgYy0yLjgtMC42LTUuNiwxLjItNi4yLDRjMCwwLTExLjgsNTUtMTEuOSw1NS42Yy0wLjYsMi44LDEuMiw1LjYsNCw2LjJjMi44LDAuNiw1LjYtMS4yLDYuMi00YzAuMS0wLjYsMS43LTcuOSwxLjctNy45IGMxLjItNS42LDUuOC05LjcsMTEuMi0xMC40YzEuMi0wLjIsNS45LTAuNSw1LjktMC41YzE5LjUtMS41LDM0LjktMTcuOCwzNC45LTM3LjdDMTIyLjgsNTEuNiwxMDUuOCwzNC43LDg1LDM0Ljd6IE04Ny43LDEyMS43IGMtMy40LTAuNy02LjgsMS40LTcuNSw0LjljLTAuNywzLjQsMS40LDYuOCw0LjksNy41YzMuNCwwLjcsNi44LTEuNCw3LjUtNC45QzkzLjMsMTI1LjcsOTEuMiwxMjIuNCw4Ny43LDEyMS43eiI+PC9wYXRoPjwvZz48L2c+PC9zdmc+Cg==',
        download_url: 'https://polkadot.js.org/extension/',
        documentation_url: 'https://polkadot.js.org/extension/',
    },
};
var WALLETS_LIST = {
    ternoa: {
        key: 'ternoa',
        name: 'Ternoa Wallet',
        logo: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAZABkAMBIgACEQEDEQH/xAAcAAEAAgMBAQEAAAAAAAAAAAAABwgEBQYDAQL/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQID/9oADAMBAAIQAxAAAAGIB1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8H0AAAAAAAAAAAAAAAAAAABmSTEVbWw3T5QD1EsJeE2fUI0XzfDl9b3QinmZ8VVTTXD56yrqXI101ooAAAAAAAAAAAAASLHDS5JWyyxMszQAAAAAAHh7iLYftlh1UdKUXbnwUAAAAAAAAAAyMixUaKRznQAAB+D9/mKop0sz+aorLg/upknZTKx8iUAABw3cipODaeuW5pRoAAAAAAAA2ONZKMjojnQAAAPOvvXwluBoAB1VkKiynlOIxQAAGq2oqvo7U1m3NeNAAAAAABIUdzJJzoAAAD591xWTTnWAAAPbxFu8nlOr5UAAABxfaCnv5lmJukCgAAAAMu0sZTDihkAAAA1e0/JT1sdd1gAAA/ZZTrcLN5UAAAADHq1a2NqgQdIAAAAysWT4mjNOdAAAAAAhmIbd1t3OWGgACR+TsxlsRigAAAAPP0FU9PM8MdIFAAALLV5tjh+xmgAAAAAMTLEFRrb/C1KkLJ/KrhIM4bCNdsTNAAAAAAA01VLiVf1ObGwAAHf2FiGXudCAAAAAAAAAAAAAAAAAAEITfHFQEOkAAAsHIPJdbyo503HCQrqtycevq+LiIZmbFAOcgarKfKiLLdqiC3aogt2qILdqiC3aogt2qILiKtTrL2AgRMd1xkH/ncnzuqk55bVynV4rleq1RVB8+9IFAAWi6Lnuh5VWSxVTNQNgFk62S3E0+Ptx3OwHqDpAoAAAAABl4gtnsY4kflebrBNELbgaAbu01PrS5b/Ey8XFqJ9OkCgALN9Twnd8rhVJuHXTU4YbAJgiGz+XR8n1n4xafOl5rpAoAAAAAAbeJrkLFyudiiErV1a3PEaALUwDZnBrdlzebV76dIFAATdK0CT3zrV7RFZuUuHzWpWHJsP09cHJJigayFZ9VVP8ANriVRWuFPPm01ewUBtftqfXCqP21qK8zVvChDgO/FR8O3XLblbuknfpjUboxXAd/DlQ8OkAAA3dqKeWmw3wzQAAAAAAKoara6rpAoIt/6+XrzoAAAAAACtthqmankNgAAExQ7t4ta8/TnQAAAAAAKoara6rpAoIt/wCvl686AAAAAABGsC9ZyfSBQAAAE9yTVW0fO+4gAAAAACqGq2uq6QKCLf8Ar5evOgAAAAAOP6+tVciOkAAAAATDD3pFwHK9VzoAAAAAFUNVtdV0gUEW/wDXy9edAAAAAGmOOgXMw+kCgAAAAANxZupnU5WbYmXigAAAD8FUtXkY/SBQ+FwPXVbXlQAAAB5nlWzacHuBoAAAAAAAB1liqk7/ACtK0O+xQAAHIdbXCuMHSAATxJlVrP8AO5QgAAaszq/67ktwNAAAAAAAAAAMqbYIRcL9Vnk3Fkty/wCY6ryjGL66+LzcCgAHbcSi3GZU+U8WXXI5MdKjyN6k6Cta3AoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xAAsEAACAQMCBAcBAAIDAAAAAAAEBQMBAgYAMBAUIEAHERITFTM1ISNQMXCA/9oACAEBAAEFAv8AtsRccXoXEGUuoMLHpqHFFFmrECizVFCymqp1ddXoFF2pcVT36nwsauisPYR6LVMRP9IIKSXItw6e/QCFWHqlKUptVp56OSrTdMcNupo4AsG/vgxSDJlGH2W6GHgGj7CaKOaxviI8umABQEvdoMXIN0AEMDD2hQ0BUL7FJINVpWle3HglImx3GYQtutaUpIwBj1YyAvrbdbdTayDHh2VpwhARHarwyDyUCYdVBs33W2WusujiqazPMu4CHGC3J8vu84JY54tlwrGZjOFpKwrs1wU55aNUOrG2b7qWW5Q/kYS9WPOp1U4s8RI+yzAHYCulk6szsR4ZCJ8dURKhNrPmdYodjAmdYidpwugZhsQ5gC+wwxLyY+27Kqa12B5boJxZbZxtrKk9rMO6lbbt7C1HOmbbO/2121iN/uY7t52o9u/dDHkKKWBxgA7ba31q9rD7PRjm2TDGRA4BvXMNzw/XfzcrTzozHqIw2I7LpJAoKDB7mdreZX7YkF5RQQ9ggm74gLa+vYwVbUlhu32232Ogqr2e14fBe6dvEQxzw5EnmVFdSZYQ0LXiQgib3iIF5xbWIicoj3yh4SoHWJkQ1ljkiv4WW3X3JsVMKuXhDgD77oWhqutK0rsLR+aYW0pbb2JIoxNsmMpr9R4ymsqMGKLTssnG5R5sYHB7rz/UeIsHpM2PDiH/ABf6jxBh9abYwKP0IeJJEA0ZWXrIq2ZoHWq12tYV6rpoba8xBrmINcxBrmINcxBrmINcxBrmINcxBrmINcxBrmINUnhr1snC9fqXNAqVGzFbJUQoYuPjlkfuY/sYhb6ce4PWkKoNmwKYkcKfyuJ5Hf6+LxsMqHaPmJ91f7vLnDEC7HXsDaPjluR3QX3VrddwAMJBnxxxE2F4N7fWr2Map5IeGUMKsG3TiLCp6jU0lsMLg6Vif2AZMohS4qw0HWSHfHKK1rWvQjPvXM7a0ut0ZTzE2Mb/AAtMr/aX9XhxJX3tZlLWLHuy8Ppa3pdeJElaQdWOyVlR6K/g2xid3qx/R0fvB3U8runw3hr56y2Cs+P9lgMNYkevEaGtwfUihqOn0zu9K7YwWT14/wAMyW1BZ9Flt19+Or/jVWrqUutyNXerYdgoAmZHCw2Dj6chWsFs8UkE3Ri625i04ZNJ7aHY8OZfMLgyCgYCO0Jqy/gNBMTLi+OUArxYhDHjNMSOguuVM7a/GMtfGMtfGMdVp5V6bVzC634xlr4xlqitlWq7FGRNyhYKsH45Pj9jOhgpAc3BMlNZyKFw6wThnkvtodjw+n9DbjX+0KRKSbo8YS21FFGFs2nH63TF9WyQPARZLjKa+o2PqB7raUtpx8R59lCRyjjsXH63TF9XYZmTzD7ZQF86o7Bx+t0xfVvmzWjCTSXSzbPh2b2Lj9bpi+rfz8z2Fm0nMqAyjvtks33H63TF9W/lh/PudvBGPMr99x+t0xfVvZYx+PU7iU+9axgksmh3nH63TF9W7X+Uytn8k03cDbb7j9bpi+rdzhtygm9FffFJjbWxqDuuP1umL6txufCtBNJlMK307CZYauMhOE3HH63TF9W2RLHBDkjeRqb2OOuJVJQs8RUG1dWltpUnuk9KiahCvavutssyt7cyl7PHXcymYIqAwbZy03kknVgBtJlmzNJHDFlGQXsru1StilU6dqK0g661pSmWtfk2HUjYXrGI00REHWxOGXj5A9IayduKRMLOhyqArX/PTJfbHZlWSc3TYxh9IrkEIhKg6X2Sir9MTiT5+6UZAwW0DzFfLSzIE99JMhTWUOzISyjZyczrtLmBa+VfmcdaQ5Gmlpc9UW0My5XDRvk7A6n/AI6//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EAB4RAAEEAwEBAQAAAAAAAAAAAAEAAhIgEBEwQFBg/9oACAECAQE/AftyW1vG1tSW/AXct9SbBqio2B5E2aKOFgfgu8QPZpo48BV3GSkpcW1PkFTiKiiMAKKioqKioqKIzFR4Ny7o3LrFNy7o3LrHElLO1JSpJSROZKWBV3kbU+QWPiHpHAjwAciKihqB00tY1aONID8l/8QARhAAAQIDAggJCgUDAwUAAAAAAQIDAAQRITASICIxQEFRcRATIzIzUmGSsQUUQmJyc4GRocEkNFOT0UNQghVj4XCAovDx/9oACAEBAAY/Av8Aq3+HlXV9uDZFXVNMjfUxy824r2RSMppbm9cWSLXxFY/IsdyPyLHci2Ra+AixlSNy45CadRvFYqy4079DHLyjqRtpUf2TAlmVuHsEBU88Gh1UWmAUSyVK6y7TFgpd2xy0qjC6ybDBVITFfUc/mMGaYW320s0/ipZpTiuyA55RXhn9NOaA2w0ltI1AaCUOoStJ1EQXJBXEr6h5scXNMqQdR1HTA9OVYY2ekqA1LNBCfHRS1MNpcQdREKf8nVcb1t6xuihBB0hLLDZWtWYCEzE4A7MbNSLupsii5tgf5iKJnGD/AJxVJBHZdl1qjUz1tR3wWJlsoWProyZeXRhKP0jJGG+ee5dFSiABnJgs+TkhxQ/qHN8IrMTLiuytnDhS8w4jcqA15SRZ+qgeIgOsrStCsxF1xT6bfRWM6Y4l8WeivUrREy8umqj8hHFtCqzz17boqUQAM5gy8uoplU/+eOLSuXJy2/4hD7KgpCxUG6MvMIqk5jrEFl0VSeYvUoaEhllJUtZoBGDznldIu7T5OaVlOWuezsuT5OdVkOWt9irtUu9/irqmFyz4opP17dB88mE/iHBYD6KbyYmDmUuzdquUPNmikKwhDbycziQoXeE2AJlu1B29kFKgQRYRf+dPJ5Bk95V5MuD0WlH6XcoTqTT5G8/1NhOSqx4du2+bl2hVazQQ3KtZkD53k0ga2VeF3KV1gn63i2XU4SFihEOSq/ROSdo1Xq/KTic+S19ze0MPyyvQWRcpbQKqUaCGZcZm0BN7542OVl8/am8bl2+c4qghqXb5raaXyPKTSbOa79jc+euJ5JjN2qvihQqCKGHpU5knJ9nVduTqhktDBTvN+tl1IUhYoRFLVS6ujX9scMsjJ9NepIhEswKISPnfsz6Rank1/a7ZBFFuZavjoCmX2wtCs4MF3yfyzfUPOH8xgOoUhWxQpw4KElSjqAgOTlZZnZ6RgMSzYQgfXQH5brIs3xQ5xcsS/wCosCAkZhoWDMMNuj1kxXzQJ9lREflK71GKS8u037KdDmWxmKsMfG54w5mkFX2/tMtMj00lJ+FzNv7VBP8AaUu623AftchXXcUcTjX3UNo2qMUaS8/2gUEZco+kdhBjBYmBh9Rdhx6KdQDvjpm+9HTN96Omb70dM33o6ZvvR0zfejpm+9HTN96Omb70dM33o6ZvvR0zfeigeb72PSZmAF9QWmOTlX1DtoIo628z20qI4yWeQ6n1TiTY2Iwvlcyns1+vDxy8pZsQjaYL0y4VbBqHDUQiR8oLwq2NunwOJhu5TiuYgZzBw3y231EGgvwWJhWD1FGqYwacXMJ5zf3GIqQkFUcHSObOwQVKJJOcnhD0s6UK8YwrEPo6RH34ZpG1pXhcyfuhwuLrySDgN7sZCnDV1rIXwLdWaJQMIw5NOa+aNg0FEwwrBWg1EMzTeZxNeB19PSc1G8wSTUnPitTKTk1osbUwFC0HgdHqG5k/dJ4JhwZ0tKP0x5tnVgpVwTFPSon66Gts/wBN0gcEo1qKlH/3548ms5+KHA77JuZQ+pTgfa67ZT9IIOcY03MaslHBMpTnSMP5aHxhHSuFQ8OCWfGZCyD8f/mPKtKzpaFeCYVsbV4XLY6ilD68Knkp5B84Sew6xihCAVKJoAIblz0nOXv4CkioNhhTdDxK7WldmgolmRn5x6o2w2w0KIQmg4HpU51DJOw6oUy6kpWg0IxUJI5FvKcP24ZxX+2RczLHVcr8+FUvMJqlX0gkoLrGpxI8eENS7S3FnUkQJucwVzPojUj/AJxCxMt4aT8xBVJkTLezMqKGQmf2zH5CZ/bMfkJn9sx+Qmf2zFCKHGCkyMyQcx4sx+Qmf2zH5CZ/bMUEhM/tmAX0iWb2qz/KOKl0WnnLOdWJ5xL0RNAfBe+C1MtKbUNo4RxSClrW6oWQJdgdqlHOo8KkfqLCblxk/wBVvwxKGMJySbrtTk+EV81wt6zGBLsNtJ9UUu5v3y/HGTuusB9pDidihWK+aYPsqIjCRJIJ9fKigFBiSssO1ZuZZ+tgXQ7jZoU375fjjJ3aC7TM1RAupd/WU0Vv0Gb98vxxk7tAdfXmQkqhbq+cs4Run5BR/wBxH30Gb98vxxk7tATKpOU+q32RdszQzJVlbtcJWk1SoVGgTfvl+OMndoDikmrbfJo+F4ZNw8pL5vZ0Cb98vxxk7r9ZSaPO5Df83rU0nMLFjamEutnCQsVBv5v3y/HGTuv1FB5BrJb/AJvv9MfV2sn7X8375fjjJ3X3mTKuWeGV6qb9LjailSTUEQF2B5Fjib6b98vxxk7r1cy9q5qesdkOTL5qtZqdATMs7lJ6whEzLqqhX0vZv3y/HGTuvFPOqCEJFSTGFalhFjafvoVbVML6RH3EJfYWFtqFhF2VHMIdd66yrGlnh6TST9LsrWoJSLSTHm8uSJRB7526JS1yXUctv7iEzEu4FoVdPEHLd5NPxx1SajlsKs9k3SnXVhCEipJgy0tVEoD8XNGw2DVB57ZzKjjJdWUOc2c6bipNBFGj+HayUdu046JlNqcy07RCH2VBTaxUG4L804EJ1bTujBtblgclv+dIS/LuKbcTmIhLE/gsPZsP0VfxjFa1BKRnJhUlIkhjMtzr/wDFzxLtVyqjaNae0Ql+XcS42rMRjFlikxM9UGxO+OOmnCtWrYN2lhCF8az+m59opMNusK3YQiyfa+NkWzzZ9m2CJRhx5W1WSI/EO8nqbTYm74yVeUjaNR3iAmellJPWatHyiydSn2wRFvlBjvRyPGTB9VNB9YLbdJZo6kG0/H/s7//EACwQAAECAwYHAQEBAQEBAAAAAAEAESExQTBRYXGBoRAgQJGxwfDx0VDhcID/2gAIAQEAAT8h/wDLtVr/AJhYMhlA7jBNWLXhKOF7hIBiWMh0R8JqX9spp2yDwGLCGxvGUbKXCBOwbcp4YFO8H+JhquVmZBfOph5IYCf1FN4QYCzADACMkOJcKG8E3J9JFnSiJkZdeOG+gyzNFfHr8GZqpbamXQz+7PghtdphfxYEiOwesAPpEN/BBj6bCOY9LOSi6Q6oxT/3IzGECCIjqDYOYNCJhw18q842biAAqSjbtuKHszIhK+onsxyBCAjRD2qSxaBeDUdMclN3BecEyAAxBE4C4WQCbOQwCheWI4clUVCpN2GgRJJiStkFk4yOybbMlB8UQ7LOe4NkbMBlI2CKn5ShAw6R5Z4mjUnBBdZsRP8AlkC87kMAEb1zQgSvOGHOChMa3uFMCXKyAqzg3gqdGAh+jDomsrFegMWi2Jm4YCzZVBfBlRq9WM8JvnMGo3FmIhjMQjRITlfzoNAwPQiELJT6JsyWDlFCJIyjDZYl2Bs0F15V6g9mwgJ3U80f87gRBFvOtDAiFAZCdoWGCC0KzKTRL3gtKxxgJUa5G2YzH/bRCkAjDeqbQs4CjuVLIgE3dTNoAYVOqCn7yHL/AJrVuojwp8C1EcDghih8SzKm1iZ4HHiYBeqFoa1YnsRgze07QQ0IoUbCDjbAOQwGqfDWM9TnE+Xafa2G6PANQnJI07yjZohXlt2Hm3IzafUFFRArJ3YjnIPATh+rBd8+RVJxNvNuNAx3ebKig2DWi8N0AA3MGjume92UOh/N634j8vj49gqqgJeOmq7l9CvJqegKIRNpRG6IAEQC9iYWJrk8dkMkADDosEACKNxT4GKdjTx3tN0OAOjZM2mYvNizg3YYPP8AktgmrEnHmxYJEQegf3/kwM2Yf+hYwx/st65DENTaBHpwP1n8TZvQgGBh0tsz058AAEQvx6/Hr8evx6/Hr8evx6/Hr8evx6/Hr8eiTgbgHO9UM8OPaIxeokZx0Dajshu/lxs7uT40E9izry7iPE4Zm1H+SJDKZh3AcSICEEVdFG4G8xehffI6+s0X0MUHieXfVTqiJOSTrauXmUdjE11ofSJGBHMZjcHjkkIwP6HGii4WIcniEt7jDARUKCEAclgw4jOCUQSsGD9txF4yUB6K6nl1TnAPXtI6huD8ZS3AByioljZ/LHQm2O56OBUpCMuNRoeByYAhtw/uiM2KciZnlMgYxVJooIAcEXcMSvDYURP90OBy5gDMEiXLnXmEfRMMQSOBrNj2ZB+jcA0ACAeADmLdAAOcVNyCdIeuBurvFYxOlsFuBRswWrEQSYjHmcYUmJiT64C0JFAZnOz9HBiOUA3oeArH0Kc4EzMLEhzwxvyCVhUc+Ve+J6TgzQ5QGpMGiShAgcHbzn2lpwHiDYNQiSIQ3y5mOhKEiduFUk30IeA4NpjJjEu6IIafQjlOpcFM1NSlwvoaawQsIsSu1/zjQmwiZ0IxTxy0xsFON7gaIVFAx/ri5ArpI1bwaFUcBcAaGBUZ9meF9N6X03pfLekYhAJgjmCgZwRh2X03pfTelEg/VFWhYr6Q9rvpEsT65DgldSBTFiqAfp2RrxiZqUDleckU1PuwPGKEd+f1YvWhAzL+E8gBgBBR0EObpeCitwGjysAIDs3xr/L/AFbX4ssJ/MN12fQnlCgHqR8kGjAkAOSKdXxx7sXWYL3R5QLh+h+Nf5Qtr8dCxycWiidzY5FCdXFyMDv0Pxr/AChbX46CCEeaBEScnNJeygRIQNvTofjX+ULa/HQXKuah3azek7ocNiAWAEFQeg+Nf5Qtr8dBiGMpMdTaRwYT6nLtLoPjX+ULa/FvcZiMXM9AtXiSdjWmEFeBGqDb/Gv8oW1+LYg4SwCiCuY1+o7Ww9YQe/vb/Gv8oW1+LbFdwMaveVuEI49EEI5TkWN4wNt8a/yhbX4tThSMCdEFp9fLgMB0BbCQIswqApjDdSqDja/Gv8v9W1+LR12ZoABVFHB3sT0U42mfBCfsis8cFgOV+mAX5TJEGd4zm3sx6BdmACI4FFMZhcOkxKMS9nlS1TkUwNxshMALVm2fnpCE1Bu9k+gozABFgyliHDDpoxvifyOKhc40scMbAyGAHJJUVJfxfzoOdycEMZ8x7zCCpWNUWASIkq3BUq6xUZ43z46idBR/QQihB37NkCAcRB5QXvctgAspMI4B8exYa7hzfhwpuMH9Hme4BCYsXoInp0o3BTqxBRYgGaY8IUq17IjsnoDnPkjo4KB8QqLcfupqsOcFjSutm/8ApxdsKqg2bcRHcp8E7vIhOzQO8IkFy+QQjUyhrH+W/wDjv//aAAwDAQACAAMAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAKLke++SjIAAAAAAAAAAAAAAGt88888888sSKAAAAAAAAAAAMO8884Mx70888+mAAAAAAAAAU88888hCCCn8888smAAAAAAAC288888iCCCSU8888+KAAAAAAQ888888KCCCGc88888aAAAAAGc888888tCCCf8888888oAAAAH8888888sNPdc88888883AAAAC88888888888888888884AAAA+4BX+88rDDDDDT484TV86KAAAe7CCRoCAAAAAAAQWTCCx8iAAAe7CCLoKAAAAAAACWjCCT+CAAAe8nJ88c/vKAEd/M88NF84AAAAz88888888CAC88888888xAAAAA08888888CAC88888888oAAAAA28888888CAC8888888yAAAAAAA0888888CAC8888888oAAAAAAAD088888qAU8888845AAAAAAAAAH0888wAAA88888ZAAAAAAAAAAAAu6YCAAASO+6gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//EABwRAAICAwEBAAAAAAAAAAAAAAERACAQMEBQYP/aAAgBAwEBPxD21FRRcK1LjccfMaDxx4BoNo0qKLSajrcdHHHHHHHRx6DkbDkXORsORoUVFFRRUUVxyH5IcB1Pc9rw7P5X/8QAIBEBAAICAwEBAAMAAAAAAAAAAQARIDAhMUEQUUBQYP/aAAgBAgEBPxD+6UO4/iLlpbLS8P1APW9a7n4ahkG+tlEW+8UflRiNdSzVRFvH0cPQys0LXMW+cgxSnEa5g2Xmua2PeVTWS0Xo8MKCtCsxXmkXsrH8aV5j3/iPnHtAuH6iPJRw/FdABT4F8EB7EeRKh3i9w+/RxAtrUlNQcX9PuXaPz6uKg1zBvSttxcV9fkO8e/w/UT5Fvl+CNAI/Brkh+4/n4ecR7pNY9xFlaTWKMjTeg1G3NLKiVmahRou1OVXLqtiYG3A0408uxD3Fkpg2BXBgl9xXkpg2Af5L/8QALBABAAEDAgQHAQADAQEBAAAAAREAITFBUTBhcYEQIECRobHwwVDR4fFwgP/aAAgBAQABPxD/AOXSUk/xaYo7wML4L5UI2MjB2gfNRupAX5l+aPQDW97CFCCJ1mfajo/f5Vm9P4xTIZdx9ylEs1LHZUo50K+FgfmiSfianZk+ac14fak961hyf4MQ5sKk/Qu0SqIXG7Ls7DUaNrNzcZB2ogW4CD4qaHzzU1NaNGRRinNDvYaPFbpbegH2d6asZgldNle/r0FkaQuuAc1orCkkcq29kHWjIpAQ+PQhVGCmOjQ41m7Xsa9tuVN5QhJc47P3y9WSsF1qzMlsPkOLu35UHPrrxvkXm+kmhG5BHcbPMpOgTNizdpNm/Wn0CrhTIjcfUXmj+Lz5BqtiougFSXI4N3agAgsHBimF2TCDu1CS8yXsNHlXSN+WkJrBA9zh4siaUwLPyKUyWXQYSbnpnLFKxrn0H/lGwDzT8Loe/CUK4IEyq2CpiiKpfc6m3JrEaAXJEQVMEPO9Clymg/ZJdUwlGQGBAecLJzh0asbAEP7TThA3GohuFtuYauqQvc+tE1MnpL01nwcvQfOC9B7OP/A40DHCXiWJCJVdAKjXlFjd/k2Xb+ceIpZEOZsPs4aNM1/I77JhNG3CL0khbR6ZPnWmXSopLybDXQ8o9Ec52fV9BldCjnKM98ViDvl4etX20kd4S8ubgy99oUSPIpj7OHPTdOY/6jUtWO+pycnUP9Nz0MA4G8NcOWZ2xwyRIC60H1+epi9hwUuHxoIfVfCPQQ++G7wSnDKNtGzfelgtgSkImiPHxdxtzvzMjnBvQAQWDhptLvmo+albuXhT4Owx/gOIVhHsJrRbe4h1eNGvcaE5XISvIoNYSO73fmsvEuyE3Nio4QNo7MK+E4mAsIoIaveMnMezZ5jxSv8ALRQxdWx5O9PEmmMG42ajkPOc5fdDwRgC3KwHu1ErAk1jT3SeKMMhyyY91nKeJPC5HSwryCV5FdsPPEK81u8azEB8izckuenBayZTtCsOlls8bcGmUMQj1KNqTfzh7MPMeGd8yHEVxz47LsItiQ/+6U2mLgI3l0+bJy8zVWHmkV1WmS8paPzHDqLq1S68cMhtNZkekjhViVD1rHwh6QdvQX5zQDzNk0S5TthMAFsmAez1pvCw0HYD4u9SGmeUjRwyCBS2MZ73cquUgYvrFXTd9BM66aCXsCkXonkJZPfgyTrF3yfYNGoWZgAg9F/5IgMlM0ltvtBRchbX7MKtTqL69UJfRIJDWBHUsR49EnbgnMt0cr4FT/iBiUNthJ2XtwTuKnyR/Wn/ABAhTk2wq+eCBazKbxD5OF059InLyL0iwIhv0WNDqy3anaT7rA5aR9LHcfOpLsvPZa/F/wBr8X/a/F/2vxf9r8X/AGvxf9r8X/a/F/2vxf8Aa/F/2vxf9r8X/aBoeE17TQiSeaxpplr70ewoSqbTXtLQNasQx1VQ7VZJJsMrkg+S3UsTqH88EDSF38GviXyKOELXYZXtlpURWUOyYfLq+KyWkMETUSh4GsgrIZHArzZ3PEg6QDAsvJ1XaWkkJfgNBDLzTS165WTUtS1LUtS1LUtS1LUtS1LQEgEq7TEgOy1usHnSDL5CYJXUyZ1bvjNZWbXr9/oF8PHdQJcqt18UXOTiN1ZNmkYJg8jiW6/hs6L4TmCH6qrz04BF7nvLwWCsENQhYRzkfKKMkEwlSMde3YF+qnnPgWvf7ZPYqV2bbCbfQzuy+hIaQuGMhqFk1KtVe3c/QTt4CrFJ1jsTQ/dc2WZVdVfKAgHEIgpyLnMKKSfGKJE6ngCeDe7osR52htNr2PhL6L7IHzTLcVnzMdmeYHwnheNOTZvcSejfFEo2PO6vfws2G+f3h52pMp1j4Qo2lfKhm/Azo+0fx4GXPXVh8tS5rN0Rh81nSCdj4Q+/wJaqtQ/iejKbqdqQPv4Ug0FtfJ7w83SrhzBpAOy+H/jSprF04Fy5C9w+PEPMI7jfkQ3OT5ZJokFMAG60g6g/NidhA5eBTwbkMQj1K08pRZmbzITo6+hsSXgk+wMGrBXR89pF+bl5+DAypP8AgAJ5VaNiKshP9Op5UbtuyzJuiI2l0oAAWDwCfhaVcx++Cna4k5Cfb8YyimyLl6D/AI2qRE0sjQFK+ttmhHHg9VYFLqxYObBUOh79l0exoMG/kvESxaHODfs2qU/FcPswdQSdqcjHYnuE+fEsWTJasm4EjkTIjh8x1hoo1xHQ+JYsbaeCP7ozFsmOc036ihzrDBTa7RoIDQ8kFVk24yDAwdjbCwWi2OfAOYp4YzQBleh6/wAXclMnGATssfBgLeMfQJm4S/HBnHrU7mTyF4BoRJEq/MeUHdlLvRpwb/DlrW8cpp1glevnioqKjzADJQH58KioqPO/W/8AVQaX3Dn2cIHalBvJEHo0+KBXsHABoB5CdMh0D7+DvkVvcOhKgAYSfTCMjqV+Ps9CffnUPtDtwbl4Ew0y+l3/ABz6YRkdSvx9noFm7OUY71Pouc0vl4RZqCtmDOjPu+mEZHUr8fZ6A1oOBmz7sPd4a9wUDlD3Kcwq8TQ4BInb0ojI6lfj7OOsEtBp2WxRi7r0jiYt5Jvme6eiKfSCMjqV+Ps453voWAWu4zvG9deJ2iGoOsFzmFXZJDhJH0gjI6lfj7OMoMKVcAU9s69CPxluQ4wBj9Gs/cO5oekEZHUr8fZxgsdRdnZcm8cpduPARMQtInRoTTA9mxdw7mnoxGR1K/H2cWZyTZCvmOXQl0qazyaHAtAgDY9BgDoBb/tDo0HCRjQ4egbJ6IQZKOXP2OIvsccEu/8ANaRlSTtCyPvbEHX0McQ8PRiDAXuWdEH9piRHR2TCNx4c7g3dAJWkRz7s/wBeUywoJE8dAHaRw1evABEqrYArfLiINHbqdW8R6OS4M6xhlsEyYwdEDgUvutQyGo3OFbm36wozpP1jzyv2LN11DpG7Wp4KnlDhsqtXjKMoGw6azvbwHpYbCJyE15JgX3ktQGLSaDNBrsFn44CuBQIAuquAoE5VQjg5pByN3zm+5sDd4sORWNmh6fSYTI2eBYmHk0WanLqwU3d1ZeYY7BjRe76dcYTCPMTCtRkanicWR8XXJs9DpRFwUiXEqPGKTGEyNlVsFA/hQyE75uc8hnga2HjXk3/rkhyPlpkDmJkGowmtR5Q5iPZt6nW3il+mTDsjYfLqr6rOa38zw+S9kXkphTieRy+1QDNSYR9gNQpLUT0GqGE7CF3i7OUHWk0PnTazJWbpduHNUxpE0T3MmiUPUWnDmudigSwZaHWA+antHW+0mlFDgzPOK3QandsOLNGhjcA3n/8AHf8A/9k=',
    },
};

var styles$9 = {
    container: {
        height: '100%',
        width: '100%',
        overflowX: 'hidden',
        overflowY: 'auto',
    },
};

var styles$8 = {
    container: {
        flex: 1,
        borderWidth: 1,
        borderColor: '#3817B8',
        borderRadius: 8,
        color: '#FFF',
        padding: 8,
        margin: 8,
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
    },
    accountInfo: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'flex-start',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
    },
    accountName: {
        marginLeft: 8,
        fontSize: 16,
        fontWeight: '900',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
    },
    extensionLogo: {
        height: 16,
        width: 16,
    },
};

// Copyright 2017-2022 @polkadot/ui-settings authors & contributors
// SPDX-License-Identifier: Apache-2.0

// Do not edit, auto-generated by @polkadot/dev

const packageInfo$2 = {
  name: '@polkadot/ui-settings',
  path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto',
  type: 'esm',
  version: '2.9.14'
};

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
// SPDX-License-Identifier: Apache-2.0

// Do not edit, auto-generated by @polkadot/dev

const packageInfo$1 = {
  name: '@polkadot/ui-shared',
  path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto',
  type: 'esm',
  version: '2.9.14'
};

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
var others = [packageInfo$2, packageInfo$1];

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
// SPDX-License-Identifier: Apache-2.0

// Do not edit, auto-generated by @polkadot/dev

const packageInfo = {
  name: '@polkadot/react-identicon',
  path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto',
  type: 'esm',
  version: '2.9.14'
};

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
detectPackage(packageInfo, null, others);

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
// SPDX-License-Identifier: Apache-2.0

// Copyright 2016 Dan Finlay

const COLORS = [
// https://sashat.me/2017/01/11/list-of-20-simple-distinct-colors/
'#ffe119', '#4363d8', '#f58231', '#fabebe', '#e6beff', '#800000', '#000075', '#a9a9a9', '#ffffff', '#000000'];
const SHAPE_COUNT = 5;

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
// SPDX-License-Identifier: Apache-2.0

// Copyright 2016 Dan Finlay

const SVG_NS = 'http://www.w3.org/2000/svg';
function svg$2(type) {
  return document.createElementNS(SVG_NS, type);
}

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
function circle$1(r, cx, cy) {
  const elem = svg$2('circle');
  elem.setAttributeNS('', 'cx', `${cx}`);
  elem.setAttributeNS('', 'cy', `${cy}`);
  elem.setAttributeNS('', 'r', `${r}`);
  return elem;
}

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
function circle(seeder, fill, diameter, count) {
  const center = diameter / 2;
  const angle = seeder() * 360;
  const radius = (SHAPE_COUNT - count) / SHAPE_COUNT * (diameter / 2) + diameter / 8 * seeder();
  const offset = diameter / 4 * (seeder() + (count + 1) / SHAPE_COUNT);
  const cx = offset * Math.sin(angle) + center;
  const cy = offset * Math.cos(angle) + center;
  const svg = circle$1(radius, cx, cy);
  svg.setAttributeNS('', 'fill', fill);
  return svg;
}

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
function element(size, type = 'svg', x = 0, y = 0) {
  const elem = svg$2(type);
  elem.setAttributeNS('', 'x', `${x}`);
  elem.setAttributeNS('', 'y', `${y}`);
  elem.setAttributeNS('', 'width', `${size}`);
  elem.setAttributeNS('', 'height', `${size}`);
  return elem;
}

var colorString$3 = {exports: {}};

var colorName$2 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var colorName$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), colorName$2, {
    'default': colorName$2
}));

var require$$0$Y = /*@__PURE__*/getAugmentedNamespace(colorName$3);

var simpleSwizzle$2 = {exports: {}};

var isArrayish$1 = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var isArrayish$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), isArrayish$1, {
    'default': isArrayish$1
}));

var require$$0$X = /*@__PURE__*/getAugmentedNamespace(isArrayish$2);

var isArrayish = require$$0$X;

var concat$3 = Array.prototype.concat;
var slice$2 = Array.prototype.slice;

var swizzle$1 = simpleSwizzle$2.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat$3.call(results, slice$2.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle$1.wrap = function (fn) {
	return function () {
		return fn(swizzle$1(arguments));
	};
};

var simpleSwizzle = simpleSwizzle$2.exports;

var simpleSwizzle$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), simpleSwizzle$2.exports, {
    'default': simpleSwizzle
}));

var require$$1$18 = /*@__PURE__*/getAugmentedNamespace(simpleSwizzle$1);

/* MIT license */

var colorNames = require$$0$Y;
var swizzle = require$$1$18;
var hasOwnProperty$1 = Object.hasOwnProperty;

var reverseNames = Object.create(null);

// create a list of reverse color names
for (var name$4 in colorNames) {
	if (hasOwnProperty$1.call(colorNames, name$4)) {
		reverseNames[colorNames[name$4]] = name$4;
	}
}

var cs = colorString$3.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var keyword = /^(\w+)$/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!hasOwnProperty$1.call(colorNames, match[1])) {
			return null;
		}

		rgb = colorNames[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = Math.round(num).toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

var colorString$1 = colorString$3.exports;

var colorString$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), colorString$3.exports, {
    'default': colorString$1
}));

var require$$0$W = /*@__PURE__*/getAugmentedNamespace(colorString$2);

var conversions$8 = {exports: {}};

/* MIT license */

var cssKeywords$1 = require$$0$Y;

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords$1 = {};
for (var key in cssKeywords$1) {
	if (cssKeywords$1.hasOwnProperty(key)) {
		reverseKeywords$1[cssKeywords$1[key]] = key;
	}
}

var convert$6 = conversions$8.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert$6) {
	if (convert$6.hasOwnProperty(model)) {
		if (!('channels' in convert$6[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert$6[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert$6[model].labels.length !== convert$6[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert$6[model].channels;
		var labels = convert$6[model].labels;
		delete convert$6[model].channels;
		delete convert$6[model].labels;
		Object.defineProperty(convert$6[model], 'channels', {value: channels});
		Object.defineProperty(convert$6[model], 'labels', {value: labels});
	}
}

convert$6.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert$6.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert$6.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert$6.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert$6.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance$1(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert$6.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords$1[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords$1) {
		if (cssKeywords$1.hasOwnProperty(keyword)) {
			var value = cssKeywords$1[keyword];

			// Compute comparative distance
			var distance = comparativeDistance$1(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert$6.keyword.rgb = function (keyword) {
	return cssKeywords$1[keyword];
};

convert$6.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert$6.rgb.lab = function (rgb) {
	var xyz = convert$6.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert$6.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert$6.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert$6.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert$6.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert$6.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert$6.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert$6.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert$6.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert$6.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert$6.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert$6.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert$6.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert$6.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert$6.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert$6.rgb.ansi16(convert$6.hsv.rgb(args), args[2]);
};

convert$6.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert$6.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert$6.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert$6.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$6.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert$6.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert$6.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert$6.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert$6.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert$6.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert$6.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert$6.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$6.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert$6.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert$6.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert$6.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$6.gray.hsl = convert$6.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert$6.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert$6.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert$6.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert$6.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$6.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

var conversions$6 = conversions$8.exports;

var conversions$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), conversions$8.exports, {
    'default': conversions$6
}));

var require$$0$V = /*@__PURE__*/getAugmentedNamespace(conversions$7);

var conversions$5 = require$$0$V;

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph$1() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions$5);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS$1(fromModel) {
	var graph = buildGraph$1();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions$5[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link$1(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion$1(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions$5[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link$1(conversions$5[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route$4 = function (fromModel) {
	var graph = deriveBFS$1(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion$1(toModel, graph);
	}

	return conversion;
};

var route$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), route$4, {
    'default': route$4
}));

var require$$1$17 = /*@__PURE__*/getAugmentedNamespace(route$5);

var conversions$4 = require$$0$V;
var route$3 = require$$1$17;

var convert$5 = {};

var models$1 = Object.keys(conversions$4);

function wrapRaw$1(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded$1(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models$1.forEach(function (fromModel) {
	convert$5[fromModel] = {};

	Object.defineProperty(convert$5[fromModel], 'channels', {value: conversions$4[fromModel].channels});
	Object.defineProperty(convert$5[fromModel], 'labels', {value: conversions$4[fromModel].labels});

	var routes = route$3(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert$5[fromModel][toModel] = wrapRounded$1(fn);
		convert$5[fromModel][toModel].raw = wrapRaw$1(fn);
	});
});

var colorConvert$2 = convert$5;

var colorConvert$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), colorConvert$2, {
    'default': colorConvert$2
}));

var require$$1$16 = /*@__PURE__*/getAugmentedNamespace(colorConvert$3);

var colorString = require$$0$W;
var convert$4 = require$$1$16;

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert$4).forEach(function (model) {
	hashedModelKeys[_slice.call(convert$4[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert$4)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert$4[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert$4[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert$4[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert$4[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert$4[this.model].channels;
		var labels = convert$4[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert$4[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert$4).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert$4[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert$4[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

var color = Color;

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
const WOBBLE = 30;
function colors$3(seeder) {
  const amount = seeder() * WOBBLE - WOBBLE / 2;
  const all = COLORS.map(hex => color(hex).rotate(amount));
  return (alpha = 1) => {
    const index = Math.floor(all.length * seeder());
    return all.splice(index, 1)[0].alpha(alpha).string();
  };
}

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
// SPDX-License-Identifier: Apache-2.0

// Copyright 2016 Dan Finlay

function container(diameter, background = 'white', className = '', _style = {}) {
  const element = document.createElement('div');
  const style = Object.assign({
    background,
    borderRadius: `${diameter / 2}px`,
    display: 'inline-block',
    height: `${diameter}px`,
    margin: '0px',
    overflow: 'hidden',
    padding: '0px',
    width: `${diameter}px`
  }, _style);
  element.className = className;
  element.style.background = background;
  Object.keys(style).forEach(key => {
    element.style[key] = style[key];
  });
  return element;
}

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
const DIVISOR = 256 * 256;
function seeder(_seed = new Uint8Array(32)) {
  const seed = isU8a(_seed) ? _seed : stringToU8a(_seed);
  let index = seed[Math.floor(seed.length / 2)] % seed.length - 1;
  const next = () => {
    index += 1;
    if (index === seed.length) {
      index = 0;
    }
    return seed[index];
  };
  return () => {
    return (next() * 256 + next()) / DIVISOR;
  };
}

// Copyright 2017-2022 @polkadot/ui-shared authors & contributors
function beachballIcon(seed, {
  size = 256
}, className = '', style) {
  const seeder$1 = seeder(seed);
  const colorGen = colors$3(seeder$1);
  const outer = container(size, 'white', className, style);
  const container$1 = container(size, colorGen());
  const svg = element(size);
  outer.appendChild(container$1);
  container$1.appendChild(svg);
  for (let count = 0; count < SHAPE_COUNT; count++) {
    const fill = colorGen();
    const shape = circle(seeder$1, fill, size, count);
    svg.appendChild(shape);
  }
  return outer;
}

// Copyright 2018-2022 @polkadot/ui-shared authors & contributors
const blake2 = value => blake2AsU8a(value, 512);
const S$1 = 64;
const C$2 = S$1 / 2;
const Z$1 = S$1 / 64 * 5;

/* eslint-disable sort-keys */
const SCHEMA = {
  target: {
    colors: [0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 1],
    freq: 1
  },
  cube: {
    colors: [0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 5],
    freq: 20
  },
  quazar: {
    colors: [1, 2, 3, 1, 2, 4, 5, 5, 4, 1, 2, 3, 1, 2, 4, 5, 5, 4, 0],
    freq: 16
  },
  flower: {
    colors: [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 3],
    freq: 32
  },
  cyclic: {
    colors: [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6],
    freq: 32
  },
  vmirror: {
    colors: [0, 1, 2, 3, 4, 5, 3, 4, 2, 0, 1, 6, 7, 8, 9, 7, 8, 6, 10],
    freq: 128
  },
  hmirror: {
    colors: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 8, 6, 7, 5, 3, 4, 2, 11],
    freq: 128
  }
};
/* eslint-enable sort-keys */

const OUTER_CIRCLE = {
  cx: C$2,
  cy: C$2,
  fill: '#eee',
  r: C$2
};
let zeroHash = new Uint8Array();
function getRotation(isSixPoint) {
  const r = isSixPoint ? C$2 / 8 * 5 : C$2 / 4 * 3;
  const rroot3o2 = r * Math.sqrt(3) / 2;
  const ro2 = r / 2;
  const rroot3o4 = r * Math.sqrt(3) / 4;
  const ro4 = r / 4;
  const r3o4 = r * 3 / 4;
  return {
    r,
    r3o4,
    ro2,
    ro4,
    rroot3o2,
    rroot3o4
  };
}
function getCircleXY(isSixPoint) {
  const {
    r,
    r3o4,
    ro2,
    ro4,
    rroot3o2,
    rroot3o4
  } = getRotation(isSixPoint);
  return [[C$2, C$2 - r], [C$2, C$2 - ro2], [C$2 - rroot3o4, C$2 - r3o4], [C$2 - rroot3o2, C$2 - ro2], [C$2 - rroot3o4, C$2 - ro4], [C$2 - rroot3o2, C$2], [C$2 - rroot3o2, C$2 + ro2], [C$2 - rroot3o4, C$2 + ro4], [C$2 - rroot3o4, C$2 + r3o4], [C$2, C$2 + r], [C$2, C$2 + ro2], [C$2 + rroot3o4, C$2 + r3o4], [C$2 + rroot3o2, C$2 + ro2], [C$2 + rroot3o4, C$2 + ro4], [C$2 + rroot3o2, C$2], [C$2 + rroot3o2, C$2 - ro2], [C$2 + rroot3o4, C$2 - ro4], [C$2 + rroot3o4, C$2 - r3o4], [C$2, C$2]];
}
function findScheme(d) {
  let cum = 0;
  const schema = Object.values(SCHEMA).find(schema => {
    cum += schema.freq;
    return d < cum;
  });
  if (!schema) {
    throw new Error('Unable to find schema');
  }
  return schema;
}
function addressToId(address) {
  if (!zeroHash.length) {
    zeroHash = blake2(new Uint8Array(32));
  }
  return blake2(decodeAddress(address)).map((x, i) => (x + 256 - zeroHash[i]) % 256);
}
function getColors(address) {
  const total = Object.values(SCHEMA).map(s => s.freq).reduce((a, b) => a + b);
  const id = addressToId(address);
  const d = Math.floor((id[30] + id[31] * 256) % total);
  const rot = id[28] % 6 * 3;
  const sat = Math.floor(id[29] * 70 / 256 + 26) % 80 + 30;
  const scheme = findScheme(d);
  const palette = Array.from(id).map((x, i) => {
    const b = (x + i % 28 * 58) % 256;
    if (b === 0) {
      return '#444';
    } else if (b === 255) {
      return 'transparent';
    }
    const h = Math.floor(b % 64 * 360 / 64);
    const l = [53, 15, 35, 75][Math.floor(b / 64)];
    return `hsl(${h}, ${sat}%, ${l}%)`;
  });
  return scheme.colors.map((_, i) => palette[scheme.colors[i < 18 ? (i + rot) % 18 : 18]]);
}

/**
 * @description Generate a array of the circles that make up an identicon
 */
function polkadotIcon(address, {
  isAlternative
}) {
  const xy = getCircleXY(isAlternative);
  let colors;
  try {
    // in some cases, e.g. RN where crypto may not be initialized, chaos can
    // happen when hashing, in these cases we just fill with a placeholder
    colors = getColors(address);
  } catch {
    colors = new Array(xy.length).fill('#ddd');
  }
  return [OUTER_CIRCLE].concat(xy.map(([cx, cy], index) => ({
    cx,
    cy,
    fill: colors[index],
    r: Z$1
  })));
}

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
function Identicon$6({
  address,
  className = '',
  size,
  style
}) {
  const updateElem = useCallback$1(node => {
    node && node.appendChild(beachballIcon(address, {
      isAlternative: false,
      size
    }));
  }, [address, size]);
  return /*#__PURE__*/jsx("div", {
    className: className,
    ref: updateElem,
    style: style
  });
}
const Beachball = /*#__PURE__*/r$3.memo(Identicon$6);

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
function Identicon$5({
  className = '',
  size,
  style
}) {
  return /*#__PURE__*/jsx("svg", {
    className: className,
    height: size,
    style: style,
    viewBox: "0 0 64 64",
    width: size
  });
}
const Empty = /*#__PURE__*/r$3.memo(Identicon$5);

var main$1 = {exports: {}};

(function (module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(commonjsGlobal, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	const pnglib = __webpack_require__(1);
	const hsl2rgb = __webpack_require__(2);

	// The random number is a js implementation of the Xorshift PRNG
	const randseed = new Array(4); // Xorshift: [x, y, z, w] 32 bit values

	function seedrand(seed) {
	  for (let i = 0; i < randseed.length; i++) {
	    randseed[i] = 0;
	  }
	  for (let i = 0; i < seed.length; i++) {
	    randseed[i % 4] = (randseed[i % 4] << 5) - randseed[i % 4] + seed.charCodeAt(i);
	  }
	}

	function rand() {
	  // based on Java's String.hashCode(), expanded to 4 32bit values
	  const t = randseed[0] ^ (randseed[0] << 11);

	  randseed[0] = randseed[1];
	  randseed[1] = randseed[2];
	  randseed[2] = randseed[3];
	  randseed[3] = randseed[3] ^ (randseed[3] >> 19) ^ t ^ (t >> 8);

	  return (randseed[3] >>> 0) / (1 << 31 >>> 0);
	}

	function createColor() {
	  //saturation is the whole color spectrum
	  const h = Math.floor(rand() * 360);
	  //saturation goes from 40 to 100, it avoids greyish colors
	  const s = rand() * 60 + 40;
	  //lightness can be anything from 0 to 100, but probabilities are a bell curve around 50%
	  const l = (rand() + rand() + rand() + rand()) * 25 ;

	  return [h / 360, s / 100, l / 100];
	}

	function createImageData(size) {
	  const width = size; // Only support square icons for now
	  const height = size;

	  const dataWidth = Math.ceil(width / 2);
	  const mirrorWidth = width - dataWidth;

	  const data = [];
	  for (let y = 0; y < height; y++) {
	    let row = [];
	    for (let x = 0; x < dataWidth; x++) {
	      // this makes foreground and background color to have a 43% (1/2.3) probability
	      // spot color has 13% chance
	      row[x] = Math.floor(rand() * 2.3);
	    }
	    const r = row.slice(0, mirrorWidth).reverse();
	    row = row.concat(r);

	    for (let i = 0; i < row.length; i++) {
	      data.push(row[i]);
	    }
	  }

	  return data;
	}

	// Modifies the passed PNG to fill in a specified rectangle
	function fillRect(png, x, y, w, h, color) {
	  for(let i = 0; i < w; i++) {
	    for (let j = 0; j < h; j++) {
	      png.buffer[png.index(x + i, y + j)] = color;
	    }
	  }
	}

	function buildOpts(opts) {
	  if (!opts.seed) {
	    throw new Error('No seed provided');
	  }

	  seedrand(opts.seed);

	  return Object.assign({
	    size: 8,
	    scale: 16,
	    color: createColor(),
	    bgcolor: createColor(),
	    spotcolor: createColor(),
	  }, opts)
	}

	function makeBlockie(address) {
	  const opts = buildOpts({ seed: address.toLowerCase() });

	  const imageData = createImageData(opts.size);
	  const width = Math.sqrt(imageData.length);

	  const p = new pnglib(opts.size * opts.scale, opts.size * opts.scale, 3);
	  p.color(...hsl2rgb(...opts.bgcolor));
	  const color = p.color(...hsl2rgb(...opts.color));
	  const spotcolor = p.color(...hsl2rgb(...opts.spotcolor));

	  for (let i = 0; i < imageData.length; i++) {
	    const row = Math.floor(i / width);
	    const col = i % width;
	    // if data is 0, leave the background
	    if (imageData[i]) {
	      // if data is 2, choose spot color, if 1 choose foreground
	      const pngColor = imageData[i] == 1 ? color : spotcolor;
	      fillRect(p, col * opts.scale, row * opts.scale, opts.scale, opts.scale, pngColor);
	    }
	  }
	  return `data:image/png;base64,${p.getBase64()}`;
	}

	module.exports = makeBlockie;


/***/ },
/* 1 */
/***/ function(module, exports) {

	/**
	 * A handy class to calculate color values.
	 *
	 * @version 1.0
	 * @author Robert Eisele <robert@xarg.org>
	 * @copyright Copyright (c) 2010, Robert Eisele
	 * @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
	 * @license http://www.opensource.org/licenses/bsd-license.php BSD License
	 *
	 */

	// Modified by George Chan <gchan@21cn.com>

	// Further modified by Will O'B <@wbobeirne> to make it
	// UglifyJS and "use strict"; friendly

	module.exports = function(width,height,depth) {


	    // helper functions for that ctx
	    function write(buffer, offs) {
	        for (var i = 2; i < arguments.length; i++) {
	            for (var j = 0; j < arguments[i].length; j++) {
	                buffer[offs++] = arguments[i].charAt(j);
	            }
	        }
	    }

	    function byte2(w) {
	        return String.fromCharCode((w >> 8) & 255, w & 255);
	    }

	    function byte4(w) {
	        return String.fromCharCode((w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w & 255);
	    }

	    function byte2lsb(w) {
	        return String.fromCharCode(w & 255, (w >> 8) & 255);
	    }

	    this.width   = width;
	    this.height  = height;
	    this.depth   = depth;

	    // pixel data and row filter identifier size
	    this.pix_size = height * (width + 1);

	    // deflate header, pix_size, block headers, adler32 checksum
	    this.data_size = 2 + this.pix_size + 5 * Math.floor((0xfffe + this.pix_size) / 0xffff) + 4;

	    // offsets and sizes of Png chunks
	    this.ihdr_offs = 0; // IHDR offset and size
	    this.ihdr_size = 4 + 4 + 13 + 4;
	    this.plte_offs = this.ihdr_offs + this.ihdr_size; // PLTE offset and size
	    this.plte_size = 4 + 4 + 3 * depth + 4;
	    this.trns_offs = this.plte_offs + this.plte_size; // tRNS offset and size
	    this.trns_size = 4 + 4 + depth + 4;
	    this.idat_offs = this.trns_offs + this.trns_size; // IDAT offset and size
	    this.idat_size = 4 + 4 + this.data_size + 4;
	    this.iend_offs = this.idat_offs + this.idat_size; // IEND offset and size
	    this.iend_size = 4 + 4 + 4;
	    this.buffer_size  = this.iend_offs + this.iend_size; // total PNG size

	    this.buffer  = new Array();
	    this.palette = new Object();
	    this.pindex  = 0;

	    var _crc32 = new Array();

	    // initialize buffer with zero bytes
	    for (var i = 0; i < this.buffer_size; i++) {
	        this.buffer[i] = "\x00";
	    }

	    // initialize non-zero elements
	    write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), 'IHDR', byte4(width), byte4(height), "\x08\x03");
	    write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), 'PLTE');
	    write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), 'tRNS');
	    write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), 'IDAT');
	    write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), 'IEND');

	    // initialize deflate header
	    var header = ((8 + (7 << 4)) << 8) | (3 << 6);
	    header+= 31 - (header % 31);

	    write(this.buffer, this.idat_offs + 8, byte2(header));

	    // initialize deflate block headers
	    for (var i = 0; (i << 16) - 1 < this.pix_size; i++) {
	        var size, bits;
	        if (i + 0xffff < this.pix_size) {
	            size = 0xffff;
	            bits = "\x00";
	        } else {
	            size = this.pix_size - (i << 16) - i;
	            bits = "\x01";
	        }
	        write(this.buffer, this.idat_offs + 8 + 2 + (i << 16) + (i << 2), bits, byte2lsb(size), byte2lsb(~size));
	    }

	    /* Create crc32 lookup table */
	    for (var i = 0; i < 256; i++) {
	        var c = i;
	        for (var j = 0; j < 8; j++) {
	            if (c & 1) {
	                c = -306674912 ^ ((c >> 1) & 0x7fffffff);
	            } else {
	                c = (c >> 1) & 0x7fffffff;
	            }
	        }
	        _crc32[i] = c;
	    }

	    // compute the index into a png for a given pixel
	    this.index = function(x,y) {
	        var i = y * (this.width + 1) + x + 1;
	        var j = this.idat_offs + 8 + 2 + 5 * Math.floor((i / 0xffff) + 1) + i;
	        return j;
	    };

	    // convert a color and build up the palette
	    this.color = function(red, green, blue, alpha) {

	        alpha = alpha >= 0 ? alpha : 255;
	        var color = (((((alpha << 8) | red) << 8) | green) << 8) | blue;

	        if (typeof this.palette[color] == "undefined") {
	            if (this.pindex == this.depth) return "\x00";

	            var ndx = this.plte_offs + 8 + 3 * this.pindex;

	            this.buffer[ndx + 0] = String.fromCharCode(red);
	            this.buffer[ndx + 1] = String.fromCharCode(green);
	            this.buffer[ndx + 2] = String.fromCharCode(blue);
	            this.buffer[this.trns_offs+8+this.pindex] = String.fromCharCode(alpha);

	            this.palette[color] = String.fromCharCode(this.pindex++);
	        }
	        return this.palette[color];
	    };

	    // output a PNG string, Base64 encoded
	    this.getBase64 = function() {

	        var s = this.getDump();

	        var ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	        var c1, c2, c3, e1, e2, e3, e4;
	        var l = s.length;
	        var i = 0;
	        var r = "";

	        do {
	            c1 = s.charCodeAt(i);
	            e1 = c1 >> 2;
	            c2 = s.charCodeAt(i+1);
	            e2 = ((c1 & 3) << 4) | (c2 >> 4);
	            c3 = s.charCodeAt(i+2);
	            if (l < i+2) { e3 = 64; } else { e3 = ((c2 & 0xf) << 2) | (c3 >> 6); }
	            if (l < i+3) { e4 = 64; } else { e4 = c3 & 0x3f; }
	            r+= ch.charAt(e1) + ch.charAt(e2) + ch.charAt(e3) + ch.charAt(e4);
	        } while ((i+= 3) < l);
	        return r;
	    };

	    // output a PNG string
	    this.getDump = function() {
	        // compute adler32 of output pixels + row filter bytes
	        var BASE = 65521; /* largest prime smaller than 65536 */
	        var NMAX = 5552; /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
	        var s1 = 1;
	        var s2 = 0;
	        var n = NMAX;

	        for (var y = 0; y < this.height; y++) {
	            for (var x = -1; x < this.width; x++) {
	                s1+= this.buffer[this.index(x, y)].charCodeAt(0);
	                s2+= s1;
	                if ((n-= 1) == 0) {
	                    s1%= BASE;
	                    s2%= BASE;
	                    n = NMAX;
	                }
	            }
	        }
	        s1%= BASE;
	        s2%= BASE;
	        write(this.buffer, this.idat_offs + this.idat_size - 8, byte4((s2 << 16) | s1));

	        // compute crc32 of the PNG chunks
	        function crc32(png, offs, size) {
	            var crc = -1;
	            for (var i = 4; i < size-4; i += 1) {
	                crc = _crc32[(crc ^ png[offs+i].charCodeAt(0)) & 0xff] ^ ((crc >> 8) & 0x00ffffff);
	            }
	            write(png, offs+size-4, byte4(crc ^ -1));
	        }

	        crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
	        crc32(this.buffer, this.plte_offs, this.plte_size);
	        crc32(this.buffer, this.trns_offs, this.trns_size);
	        crc32(this.buffer, this.idat_offs, this.idat_size);
	        crc32(this.buffer, this.iend_offs, this.iend_size);

	        // convert PNG to string
	        return "\x89PNG\r\n\x1a\n" + this.buffer.join('');
	    };
	};


/***/ },
/* 2 */
/***/ function(module, exports) {

	// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
	/**
	 * Converts an HSL color value to RGB. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes h, s, and l are contained in the set [0, 1] and
	 * returns r, g, and b in the set [0, 255].
	 *
	 * @param   {number}  h       The hue
	 * @param   {number}  s       The saturation
	 * @param   {number}  l       The lightness
	 * @return  {Array}           The RGB representation
	 */

	 function hue2rgb(p, q, t) {
	   if(t < 0) t += 1;
	   if(t > 1) t -= 1;
	   if(t < 1/6) return p + (q - p) * 6 * t;
	   if(t < 1/2) return q;
	   if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	   return p;
	 }

	function hsl2rgb(h, s, l){
	  let r, g, b;

	  if (s == 0) {
	    r = g = b = l; // achromatic
	  } else {
	    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	    const p = 2 * l - q;
	    r = hue2rgb(p, q, h + 1/3);
	    g = hue2rgb(p, q, h);
	    b = hue2rgb(p, q, h - 1/3);
	  }

	  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), 255];
	}

	module.exports = hsl2rgb;


/***/ }
/******/ ])
});
}(main$1));

var makeBlockie = main$1.exports;

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser$5 = true;
var env$5 = {};
var argv = [];
var version$7 = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop$4() {}

var on = noop$4;
var addListener = noop$4;
var once = noop$4;
var off = noop$4;
var removeListener = noop$4;
var removeAllListeners = noop$4;
var emit = noop$4;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser$5,
  env: env$5,
  argv: argv,
  version: version$7,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var reactIs$4 = {exports: {}};

var reactIs_production_min$3 = {};

/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$3=Symbol.for("react.element"),c$3=Symbol.for("react.portal"),d$3=Symbol.for("react.fragment"),e$3=Symbol.for("react.strict_mode"),f$3=Symbol.for("react.profiler"),g$3=Symbol.for("react.provider"),h$3=Symbol.for("react.context"),k$3=Symbol.for("react.server_context"),l$3=Symbol.for("react.forward_ref"),m$3=Symbol.for("react.suspense"),n$3=Symbol.for("react.suspense_list"),p$3=Symbol.for("react.memo"),q$2=Symbol.for("react.lazy"),t$3=Symbol.for("react.offscreen"),u$2;u$2=Symbol.for("react.module.reference");
function v$4(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b$3:switch(a=a.type,a){case d$3:case f$3:case e$3:case m$3:case n$3:return a;default:switch(a=a&&a.$$typeof,a){case k$3:case h$3:case l$3:case q$2:case p$3:case g$3:return a;default:return r}}case c$3:return r}}}var ContextConsumer$1 = reactIs_production_min$3.ContextConsumer=h$3;var ContextProvider$1 = reactIs_production_min$3.ContextProvider=g$3;var Element$1 = reactIs_production_min$3.Element=b$3;var ForwardRef$1 = reactIs_production_min$3.ForwardRef=l$3;var Fragment$2 = reactIs_production_min$3.Fragment=d$3;var Lazy$1 = reactIs_production_min$3.Lazy=q$2;var Memo$1 = reactIs_production_min$3.Memo=p$3;var Portal$1 = reactIs_production_min$3.Portal=c$3;var Profiler$1 = reactIs_production_min$3.Profiler=f$3;var StrictMode$1 = reactIs_production_min$3.StrictMode=e$3;var Suspense$1 = reactIs_production_min$3.Suspense=m$3;
var SuspenseList = reactIs_production_min$3.SuspenseList=n$3;var isAsyncMode$1 = reactIs_production_min$3.isAsyncMode=function(){return !1};var isConcurrentMode$1 = reactIs_production_min$3.isConcurrentMode=function(){return !1};var isContextConsumer$1 = reactIs_production_min$3.isContextConsumer=function(a){return v$4(a)===h$3};var isContextProvider$1 = reactIs_production_min$3.isContextProvider=function(a){return v$4(a)===g$3};var isElement$1 = reactIs_production_min$3.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b$3};var isForwardRef$1 = reactIs_production_min$3.isForwardRef=function(a){return v$4(a)===l$3};var isFragment$1 = reactIs_production_min$3.isFragment=function(a){return v$4(a)===d$3};var isLazy$1 = reactIs_production_min$3.isLazy=function(a){return v$4(a)===q$2};var isMemo$1 = reactIs_production_min$3.isMemo=function(a){return v$4(a)===p$3};
var isPortal$1 = reactIs_production_min$3.isPortal=function(a){return v$4(a)===c$3};var isProfiler$1 = reactIs_production_min$3.isProfiler=function(a){return v$4(a)===f$3};var isStrictMode$1 = reactIs_production_min$3.isStrictMode=function(a){return v$4(a)===e$3};var isSuspense$1 = reactIs_production_min$3.isSuspense=function(a){return v$4(a)===m$3};var isSuspenseList = reactIs_production_min$3.isSuspenseList=function(a){return v$4(a)===n$3};
var isValidElementType$1 = reactIs_production_min$3.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d$3||a===f$3||a===e$3||a===m$3||a===n$3||a===t$3||"object"===typeof a&&null!==a&&(a.$$typeof===q$2||a.$$typeof===p$3||a.$$typeof===g$3||a.$$typeof===h$3||a.$$typeof===l$3||a.$$typeof===u$2||void 0!==a.getModuleId)?!0:!1};var typeOf$1 = reactIs_production_min$3.typeOf=v$4;

var reactIs_production_min$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), reactIs_production_min$3, {
    'default': reactIs_production_min$3,
    ContextConsumer: ContextConsumer$1,
    ContextProvider: ContextProvider$1,
    Element: Element$1,
    ForwardRef: ForwardRef$1,
    Fragment: Fragment$2,
    Lazy: Lazy$1,
    Memo: Memo$1,
    Portal: Portal$1,
    Profiler: Profiler$1,
    StrictMode: StrictMode$1,
    Suspense: Suspense$1,
    SuspenseList: SuspenseList,
    isAsyncMode: isAsyncMode$1,
    isConcurrentMode: isConcurrentMode$1,
    isContextConsumer: isContextConsumer$1,
    isContextProvider: isContextProvider$1,
    isElement: isElement$1,
    isForwardRef: isForwardRef$1,
    isFragment: isFragment$1,
    isLazy: isLazy$1,
    isMemo: isMemo$1,
    isPortal: isPortal$1,
    isProfiler: isProfiler$1,
    isStrictMode: isStrictMode$1,
    isSuspense: isSuspense$1,
    isSuspenseList: isSuspenseList,
    isValidElementType: isValidElementType$1,
    typeOf: typeOf$1
}));

var require$$0$U = /*@__PURE__*/getAugmentedNamespace(reactIs_production_min$2);

var reactIs_development$3 = {};

var typeOf_1$1;
var isValidElementType_1$1;
var isSuspenseList_1;
var isSuspense_1$1;
var isStrictMode_1$1;
var isProfiler_1$1;
var isPortal_1$1;
var isMemo_1$1;
var isLazy_1$1;
var isFragment_1$1;
var isForwardRef_1$1;
var isElement_1$1;
var isContextProvider_1$1;
var isContextConsumer_1$1;
var isConcurrentMode_1$1;
var isAsyncMode_1$1;
var SuspenseList_1;
var Suspense_1$1;
var StrictMode_1$1;
var Profiler_1$1;
var Portal_1$1;
var Memo_1$1;
var Lazy_1$1;
var Fragment_1$1;
var ForwardRef_1$1;
var Element_1$1;
var ContextProvider_1$1;
var ContextConsumer_1$1;

if (browser$1$1.env.NODE_ENV !== "production") {
  (function() {

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_SERVER_CONTEXT_TYPE:
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false;
var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isConcurrentMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}
function isSuspenseList(object) {
  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
}

ContextConsumer_1$1 = reactIs_development$3.ContextConsumer = ContextConsumer;
ContextProvider_1$1 = reactIs_development$3.ContextProvider = ContextProvider;
Element_1$1 = reactIs_development$3.Element = Element;
ForwardRef_1$1 = reactIs_development$3.ForwardRef = ForwardRef;
Fragment_1$1 = reactIs_development$3.Fragment = Fragment;
Lazy_1$1 = reactIs_development$3.Lazy = Lazy;
Memo_1$1 = reactIs_development$3.Memo = Memo;
Portal_1$1 = reactIs_development$3.Portal = Portal;
Profiler_1$1 = reactIs_development$3.Profiler = Profiler;
StrictMode_1$1 = reactIs_development$3.StrictMode = StrictMode;
Suspense_1$1 = reactIs_development$3.Suspense = Suspense;
SuspenseList_1 = reactIs_development$3.SuspenseList = SuspenseList;
isAsyncMode_1$1 = reactIs_development$3.isAsyncMode = isAsyncMode;
isConcurrentMode_1$1 = reactIs_development$3.isConcurrentMode = isConcurrentMode;
isContextConsumer_1$1 = reactIs_development$3.isContextConsumer = isContextConsumer;
isContextProvider_1$1 = reactIs_development$3.isContextProvider = isContextProvider;
isElement_1$1 = reactIs_development$3.isElement = isElement;
isForwardRef_1$1 = reactIs_development$3.isForwardRef = isForwardRef;
isFragment_1$1 = reactIs_development$3.isFragment = isFragment;
isLazy_1$1 = reactIs_development$3.isLazy = isLazy;
isMemo_1$1 = reactIs_development$3.isMemo = isMemo;
isPortal_1$1 = reactIs_development$3.isPortal = isPortal;
isProfiler_1$1 = reactIs_development$3.isProfiler = isProfiler;
isStrictMode_1$1 = reactIs_development$3.isStrictMode = isStrictMode;
isSuspense_1$1 = reactIs_development$3.isSuspense = isSuspense;
isSuspenseList_1 = reactIs_development$3.isSuspenseList = isSuspenseList;
isValidElementType_1$1 = reactIs_development$3.isValidElementType = isValidElementType;
typeOf_1$1 = reactIs_development$3.typeOf = typeOf;
  })();
}

var reactIs_development$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), reactIs_development$3, {
    'default': reactIs_development$3,
    get ContextConsumer () { return ContextConsumer_1$1; },
    get ContextProvider () { return ContextProvider_1$1; },
    get Element () { return Element_1$1; },
    get ForwardRef () { return ForwardRef_1$1; },
    get Fragment () { return Fragment_1$1; },
    get Lazy () { return Lazy_1$1; },
    get Memo () { return Memo_1$1; },
    get Portal () { return Portal_1$1; },
    get Profiler () { return Profiler_1$1; },
    get StrictMode () { return StrictMode_1$1; },
    get Suspense () { return Suspense_1$1; },
    get SuspenseList () { return SuspenseList_1; },
    get isAsyncMode () { return isAsyncMode_1$1; },
    get isConcurrentMode () { return isConcurrentMode_1$1; },
    get isContextConsumer () { return isContextConsumer_1$1; },
    get isContextProvider () { return isContextProvider_1$1; },
    get isElement () { return isElement_1$1; },
    get isForwardRef () { return isForwardRef_1$1; },
    get isFragment () { return isFragment_1$1; },
    get isLazy () { return isLazy_1$1; },
    get isMemo () { return isMemo_1$1; },
    get isPortal () { return isPortal_1$1; },
    get isProfiler () { return isProfiler_1$1; },
    get isStrictMode () { return isStrictMode_1$1; },
    get isSuspense () { return isSuspense_1$1; },
    get isSuspenseList () { return isSuspenseList_1; },
    get isValidElementType () { return isValidElementType_1$1; },
    get typeOf () { return typeOf_1$1; }
}));

var require$$1$15 = /*@__PURE__*/getAugmentedNamespace(reactIs_development$2);

if (browser$1$1.env.NODE_ENV === 'production') {
  reactIs$4.exports = require$$0$U;
} else {
  reactIs$4.exports = require$$1$15;
}

function stylis_min (W) {
  function M(d, c, e, h, a) {
    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
      g = e.charCodeAt(l);
      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

      if (0 === b + n + v + m) {
        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
          switch (g) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;

            default:
              f += e.charAt(l);
          }

          g = 59;
        }

        switch (g) {
          case 123:
            f = f.trim();
            q = f.charCodeAt(0);
            k = 1;

            for (t = ++l; l < B;) {
              switch (g = e.charCodeAt(l)) {
                case 123:
                  k++;
                  break;

                case 125:
                  k--;
                  break;

                case 47:
                  switch (g = e.charCodeAt(l + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u = l + 1; u < J; ++u) {
                          switch (e.charCodeAt(u)) {
                            case 47:
                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                l = u + 1;
                                break a;
                              }

                              break;

                            case 10:
                              if (47 === g) {
                                l = u + 1;
                                break a;
                              }

                          }
                        }

                        l = u;
                      }

                  }

                  break;

                case 91:
                  g++;

                case 40:
                  g++;

                case 34:
                case 39:
                  for (; l++ < J && e.charCodeAt(l) !== g;) {
                  }

              }

              if (0 === k) break;
              l++;
            }

            k = e.substring(t, l);
            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

            switch (q) {
              case 64:
                0 < r && (f = f.replace(N, ''));
                g = f.charCodeAt(1);

                switch (g) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r = c;
                    break;

                  default:
                    r = O;
                }

                k = M(c, r, k, g, a + 1);
                t = k.length;
                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                if (0 < t) switch (g) {
                  case 115:
                    f = f.replace(da, ea);

                  case 100:
                  case 109:
                  case 45:
                    k = f + '{' + k + '}';
                    break;

                  case 107:
                    f = f.replace(fa, '$1 $2');
                    k = f + '{' + k + '}';
                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                    break;

                  default:
                    k = f + k, 112 === h && (k = (p += k, ''));
                } else k = '';
                break;

              default:
                k = M(c, X(c, f, I), k, h, a + 1);
            }

            F += k;
            k = I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
            break;

          case 125:
          case 59:
            f = (0 < r ? f.replace(N, '') : f).trim();
            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
              case 0:
                break;

              case 64:
                if (105 === g || 99 === g) {
                  G += f + e.charAt(l);
                  break;
                }

              default:
                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
            }
            I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
        }
      }

      switch (g) {
        case 13:
        case 10:
          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
          z = 1;
          D++;
          break;

        case 59:
        case 125:
          if (0 === b + n + v + m) {
            z++;
            break;
          }

        default:
          z++;
          y = e.charAt(l);

          switch (g) {
            case 9:
            case 32:
              if (0 === n + m + b) switch (x) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y = '';
                  break;

                default:
                  32 !== g && (y = ' ');
              }
              break;

            case 0:
              y = '\\0';
              break;

            case 12:
              y = '\\f';
              break;

            case 11:
              y = '\\v';
              break;

            case 38:
              0 === n + b + m && (r = I = 1, y = '\f' + y);
              break;

            case 108:
              if (0 === n + b + m + E && 0 < u) switch (l - u) {
                case 2:
                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                case 8:
                  111 === K && (E = K);
              }
              break;

            case 58:
              0 === n + b + m && (u = l);
              break;

            case 44:
              0 === b + v + n + m && (r = 1, y += '\r');
              break;

            case 34:
            case 39:
              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
              break;

            case 91:
              0 === n + b + v && m++;
              break;

            case 93:
              0 === n + b + v && m--;
              break;

            case 41:
              0 === n + b + m && v--;
              break;

            case 40:
              if (0 === n + b + m) {
                if (0 === q) switch (2 * x + 3 * K) {
                  case 533:
                    break;

                  default:
                    q = 1;
                }
                v++;
              }

              break;

            case 64:
              0 === b + v + n + m + u + k && (k = 1);
              break;

            case 42:
            case 47:
              if (!(0 < n + m + v)) switch (b) {
                case 0:
                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                    case 235:
                      b = 47;
                      break;

                    case 220:
                      t = l, b = 42;
                  }

                  break;

                case 42:
                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
              }
          }

          0 === b && (f += y);
      }

      K = x;
      x = g;
      l++;
    }

    t = p.length;

    if (0 < t) {
      r = c;
      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
      p = r.join(',') + '{' + p + '}';

      if (0 !== w * E) {
        2 !== w || L(p, 2) || (E = 0);

        switch (E) {
          case 111:
            p = p.replace(ha, ':-moz-$1') + p;
            break;

          case 112:
            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
        }

        E = 0;
      }
    }

    return G + p + F;
  }

  function X(d, c, e) {
    var h = c.trim().split(ia);
    c = h;
    var a = h.length,
        m = d.length;

    switch (m) {
      case 0:
      case 1:
        var b = 0;

        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
          c[b] = Z(d, c[b], e).trim();
        }

        break;

      default:
        var v = b = 0;

        for (c = []; b < a; ++b) {
          for (var n = 0; n < m; ++n) {
            c[v++] = Z(d[n] + ' ', h[b], e).trim();
          }
        }

    }

    return c;
  }

  function Z(d, c, e) {
    var h = c.charCodeAt(0);
    33 > h && (h = (c = c.trim()).charCodeAt(0));

    switch (h) {
      case 38:
        return c.replace(F, '$1' + d.trim());

      case 58:
        return d.trim() + c.replace(F, '$1' + d.trim());

      default:
        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
    }

    return d + c;
  }

  function P(d, c, e, h) {
    var a = d + ';',
        m = 2 * c + 3 * e + 4 * h;

    if (944 === m) {
      d = a.indexOf(':', 9) + 1;
      var b = a.substring(d, a.length - 1).trim();
      b = a.substring(0, d).trim() + b + ';';
      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
    }

    if (0 === w || 2 === w && !L(a, 1)) return a;

    switch (m) {
      case 1015:
        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

      case 951:
        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

      case 963:
        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

      case 1009:
        if (100 !== a.charCodeAt(4)) break;

      case 969:
      case 942:
        return '-webkit-' + a + a;

      case 978:
        return '-webkit-' + a + '-moz-' + a + a;

      case 1019:
      case 983:
        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

      case 883:
        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
        break;

      case 932:
        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
          case 103:
            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

          case 115:
            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

          case 98:
            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
        }
        return '-webkit-' + a + '-ms-' + a + a;

      case 964:
        return '-webkit-' + a + '-ms-flex-' + a + a;

      case 1023:
        if (99 !== a.charCodeAt(8)) break;
        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

      case 1005:
        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

      case 1e3:
        b = a.substring(13).trim();
        c = b.indexOf('-') + 1;

        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
          case 226:
            b = a.replace(G, 'tb');
            break;

          case 232:
            b = a.replace(G, 'tb-rl');
            break;

          case 220:
            b = a.replace(G, 'lr');
            break;

          default:
            return a;
        }

        return '-webkit-' + a + '-ms-' + b + a;

      case 1017:
        if (-1 === a.indexOf('sticky', 9)) break;

      case 975:
        c = (a = d).length - 10;
        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b.charCodeAt(8)) break;

          case 115:
            a = a.replace(b, '-webkit-' + b) + ';' + a;
            break;

          case 207:
          case 102:
            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
        }

        return a + ';';

      case 938:
        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
          case 105:
            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

          case 115:
            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

          default:
            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
        }
        break;

      case 973:
      case 989:
        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

      case 931:
      case 953:
        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
        break;

      case 962:
        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
    }

    return a;
  }

  function L(d, c) {
    var e = d.indexOf(1 === c ? ':' : '{'),
        h = d.substring(0, 3 !== c ? e : 10);
    e = d.substring(e + 1, d.length - 1);
    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
  }

  function ea(d, c) {
    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
  }

  function H(d, c, e, h, a, m, b, v, n, q) {
    for (var g = 0, x = c, w; g < A; ++g) {
      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;

        default:
          x = w;
      }
    }

    if (x !== c) return x;
  }

  function T(d) {
    switch (d) {
      case void 0:
      case null:
        A = S.length = 0;
        break;

      default:
        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
          T(d[c]);
        } else Y = !!d | 0;
    }

    return T;
  }

  function U(d) {
    d = d.prefix;
    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
    return U;
  }

  function B(d, c) {
    var e = d;
    33 > e.charCodeAt(0) && (e = e.trim());
    V = e;
    e = [V];

    if (0 < A) {
      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
      void 0 !== h && 'string' === typeof h && (c = h);
    }

    var a = M(O, e, c, 0, 0);
    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
    V = '';
    E = 0;
    z = D = 1;
    return a;
  }

  var ca = /^\0+/g,
      N = /[\0\r\f]/g,
      aa = /: */g,
      ka = /zoo|gra/,
      ma = /([,: ])(transform)/g,
      ia = /,\r+?/g,
      F = /([\t\r\n ])*\f?&/g,
      fa = /@(k\w+)\s*(\S*)\s*/,
      Q = /::(place)/g,
      ha = /:(read-only)/g,
      G = /[svh]\w+-[tblr]{2}/,
      da = /\(\s*(.*)\s*\)/g,
      oa = /([\s\S]*?);/g,
      ba = /-self|flex-/g,
      na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
      la = /stretch|:\s*\w+\-(?:conte|avail)/,
      ja = /([^-])(image-set\()/,
      z = 1,
      D = 1,
      E = 0,
      w = 1,
      O = [],
      S = [],
      A = 0,
      R = null,
      Y = 0,
      V = '';
  B.use = T;
  B.set = U;
  void 0 !== W && U(W);
  return B;
}

var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */memoize(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

var reactIs$3 = {exports: {}};

var reactIs_production_min$1 = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$2="function"===typeof Symbol&&Symbol.for,c$2=b$2?Symbol.for("react.element"):60103,d$2=b$2?Symbol.for("react.portal"):60106,e$2=b$2?Symbol.for("react.fragment"):60107,f$2=b$2?Symbol.for("react.strict_mode"):60108,g$2=b$2?Symbol.for("react.profiler"):60114,h$2=b$2?Symbol.for("react.provider"):60109,k$2=b$2?Symbol.for("react.context"):60110,l$2=b$2?Symbol.for("react.async_mode"):60111,m$2=b$2?Symbol.for("react.concurrent_mode"):60111,n$2=b$2?Symbol.for("react.forward_ref"):60112,p$2=b$2?Symbol.for("react.suspense"):60113,q$1=b$2?
Symbol.for("react.suspense_list"):60120,r$2=b$2?Symbol.for("react.memo"):60115,t$2=b$2?Symbol.for("react.lazy"):60116,v$3=b$2?Symbol.for("react.block"):60121,w$2=b$2?Symbol.for("react.fundamental"):60117,x$3=b$2?Symbol.for("react.responder"):60118,y$3=b$2?Symbol.for("react.scope"):60119;
function z$2(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c$2:switch(a=a.type,a){case l$2:case m$2:case e$2:case g$2:case f$2:case p$2:return a;default:switch(a=a&&a.$$typeof,a){case k$2:case n$2:case t$2:case r$2:case h$2:return a;default:return u}}case d$2:return u}}}function A$1(a){return z$2(a)===m$2}var AsyncMode = reactIs_production_min$1.AsyncMode=l$2;var ConcurrentMode = reactIs_production_min$1.ConcurrentMode=m$2;var ContextConsumer = reactIs_production_min$1.ContextConsumer=k$2;var ContextProvider = reactIs_production_min$1.ContextProvider=h$2;var Element = reactIs_production_min$1.Element=c$2;var ForwardRef = reactIs_production_min$1.ForwardRef=n$2;var Fragment$1 = reactIs_production_min$1.Fragment=e$2;var Lazy = reactIs_production_min$1.Lazy=t$2;var Memo = reactIs_production_min$1.Memo=r$2;var Portal = reactIs_production_min$1.Portal=d$2;
var Profiler = reactIs_production_min$1.Profiler=g$2;var StrictMode = reactIs_production_min$1.StrictMode=f$2;var Suspense = reactIs_production_min$1.Suspense=p$2;var isAsyncMode = reactIs_production_min$1.isAsyncMode=function(a){return A$1(a)||z$2(a)===l$2};var isConcurrentMode = reactIs_production_min$1.isConcurrentMode=A$1;var isContextConsumer = reactIs_production_min$1.isContextConsumer=function(a){return z$2(a)===k$2};var isContextProvider = reactIs_production_min$1.isContextProvider=function(a){return z$2(a)===h$2};var isElement = reactIs_production_min$1.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c$2};var isForwardRef = reactIs_production_min$1.isForwardRef=function(a){return z$2(a)===n$2};var isFragment = reactIs_production_min$1.isFragment=function(a){return z$2(a)===e$2};var isLazy = reactIs_production_min$1.isLazy=function(a){return z$2(a)===t$2};
var isMemo = reactIs_production_min$1.isMemo=function(a){return z$2(a)===r$2};var isPortal = reactIs_production_min$1.isPortal=function(a){return z$2(a)===d$2};var isProfiler = reactIs_production_min$1.isProfiler=function(a){return z$2(a)===g$2};var isStrictMode = reactIs_production_min$1.isStrictMode=function(a){return z$2(a)===f$2};var isSuspense = reactIs_production_min$1.isSuspense=function(a){return z$2(a)===p$2};
var isValidElementType = reactIs_production_min$1.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e$2||a===m$2||a===g$2||a===f$2||a===p$2||a===q$1||"object"===typeof a&&null!==a&&(a.$$typeof===t$2||a.$$typeof===r$2||a.$$typeof===h$2||a.$$typeof===k$2||a.$$typeof===n$2||a.$$typeof===w$2||a.$$typeof===x$3||a.$$typeof===y$3||a.$$typeof===v$3)};var typeOf = reactIs_production_min$1.typeOf=z$2;

var reactIs_production_min = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), reactIs_production_min$1, {
    'default': reactIs_production_min$1,
    AsyncMode: AsyncMode,
    ConcurrentMode: ConcurrentMode,
    ContextConsumer: ContextConsumer,
    ContextProvider: ContextProvider,
    Element: Element,
    ForwardRef: ForwardRef,
    Fragment: Fragment$1,
    Lazy: Lazy,
    Memo: Memo,
    Portal: Portal,
    Profiler: Profiler,
    StrictMode: StrictMode,
    Suspense: Suspense,
    isAsyncMode: isAsyncMode,
    isConcurrentMode: isConcurrentMode,
    isContextConsumer: isContextConsumer,
    isContextProvider: isContextProvider,
    isElement: isElement,
    isForwardRef: isForwardRef,
    isFragment: isFragment,
    isLazy: isLazy,
    isMemo: isMemo,
    isPortal: isPortal,
    isProfiler: isProfiler,
    isStrictMode: isStrictMode,
    isSuspense: isSuspense,
    isValidElementType: isValidElementType,
    typeOf: typeOf
}));

var require$$0$T = /*@__PURE__*/getAugmentedNamespace(reactIs_production_min);

var reactIs_development$1 = {};

var typeOf_1;
var isValidElementType_1;
var isSuspense_1;
var isStrictMode_1;
var isProfiler_1;
var isPortal_1;
var isMemo_1;
var isLazy_1;
var isFragment_1;
var isForwardRef_1;
var isElement_1;
var isContextProvider_1;
var isContextConsumer_1;
var isConcurrentMode_1;
var isAsyncMode_1;
var Suspense_1;
var StrictMode_1;
var Profiler_1;
var Portal_1;
var Memo_1;
var Lazy_1;
var Fragment_1;
var ForwardRef_1;
var Element_1;
var ContextProvider_1;
var ContextConsumer_1;
var ConcurrentMode_1;
var AsyncMode_1;



if (browser$1$1.env.NODE_ENV !== "production") {
  (function() {

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

AsyncMode_1 = reactIs_development$1.AsyncMode = AsyncMode;
ConcurrentMode_1 = reactIs_development$1.ConcurrentMode = ConcurrentMode;
ContextConsumer_1 = reactIs_development$1.ContextConsumer = ContextConsumer;
ContextProvider_1 = reactIs_development$1.ContextProvider = ContextProvider;
Element_1 = reactIs_development$1.Element = Element;
ForwardRef_1 = reactIs_development$1.ForwardRef = ForwardRef;
Fragment_1 = reactIs_development$1.Fragment = Fragment;
Lazy_1 = reactIs_development$1.Lazy = Lazy;
Memo_1 = reactIs_development$1.Memo = Memo;
Portal_1 = reactIs_development$1.Portal = Portal;
Profiler_1 = reactIs_development$1.Profiler = Profiler;
StrictMode_1 = reactIs_development$1.StrictMode = StrictMode;
Suspense_1 = reactIs_development$1.Suspense = Suspense;
isAsyncMode_1 = reactIs_development$1.isAsyncMode = isAsyncMode;
isConcurrentMode_1 = reactIs_development$1.isConcurrentMode = isConcurrentMode;
isContextConsumer_1 = reactIs_development$1.isContextConsumer = isContextConsumer;
isContextProvider_1 = reactIs_development$1.isContextProvider = isContextProvider;
isElement_1 = reactIs_development$1.isElement = isElement;
isForwardRef_1 = reactIs_development$1.isForwardRef = isForwardRef;
isFragment_1 = reactIs_development$1.isFragment = isFragment;
isLazy_1 = reactIs_development$1.isLazy = isLazy;
isMemo_1 = reactIs_development$1.isMemo = isMemo;
isPortal_1 = reactIs_development$1.isPortal = isPortal;
isProfiler_1 = reactIs_development$1.isProfiler = isProfiler;
isStrictMode_1 = reactIs_development$1.isStrictMode = isStrictMode;
isSuspense_1 = reactIs_development$1.isSuspense = isSuspense;
isValidElementType_1 = reactIs_development$1.isValidElementType = isValidElementType;
typeOf_1 = reactIs_development$1.typeOf = typeOf;
  })();
}

var reactIs_development = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), reactIs_development$1, {
    'default': reactIs_development$1,
    get AsyncMode () { return AsyncMode_1; },
    get ConcurrentMode () { return ConcurrentMode_1; },
    get ContextConsumer () { return ContextConsumer_1; },
    get ContextProvider () { return ContextProvider_1; },
    get Element () { return Element_1; },
    get ForwardRef () { return ForwardRef_1; },
    get Fragment () { return Fragment_1; },
    get Lazy () { return Lazy_1; },
    get Memo () { return Memo_1; },
    get Portal () { return Portal_1; },
    get Profiler () { return Profiler_1; },
    get StrictMode () { return StrictMode_1; },
    get Suspense () { return Suspense_1; },
    get isAsyncMode () { return isAsyncMode_1; },
    get isConcurrentMode () { return isConcurrentMode_1; },
    get isContextConsumer () { return isContextConsumer_1; },
    get isContextProvider () { return isContextProvider_1; },
    get isElement () { return isElement_1; },
    get isForwardRef () { return isForwardRef_1; },
    get isFragment () { return isFragment_1; },
    get isLazy () { return isLazy_1; },
    get isMemo () { return isMemo_1; },
    get isPortal () { return isPortal_1; },
    get isProfiler () { return isProfiler_1; },
    get isStrictMode () { return isStrictMode_1; },
    get isSuspense () { return isSuspense_1; },
    get isValidElementType () { return isValidElementType_1; },
    get typeOf () { return typeOf_1; }
}));

var require$$1$14 = /*@__PURE__*/getAugmentedNamespace(reactIs_development);

if (browser$1$1.env.NODE_ENV === 'production') {
  reactIs$3.exports = require$$0$T;
} else {
  reactIs$3.exports = require$$1$14;
}

var reactIs$1 = reactIs$3.exports;

var reactIs$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), reactIs$3.exports, {
    'default': reactIs$1
}));

var require$$0$S = /*@__PURE__*/getAugmentedNamespace(reactIs$2);

var reactIs = require$$0$S;

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

function y$2(){return (y$2=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r]);}return e}).apply(this,arguments)}var v$2=function(e,t){for(var n=[e[0]],r=0,o=t.length;r<o;r+=1)n.push(t[r],e[r+1]);return n},g$1=function(t){return null!==t&&"object"==typeof t&&"[object Object]"===(t.toString?t.toString():Object.prototype.toString.call(t))&&!reactIs$4.exports.typeOf(t)},S=Object.freeze([]),w$1=Object.freeze({});function E$1(e){return "function"==typeof e}function b$1(e){return "production"!==browser$1$1.env.NODE_ENV&&"string"==typeof e&&e||e.displayName||e.name||"Component"}function _$1(e){return e&&"string"==typeof e.styledComponentId}var N$1="undefined"!=typeof browser$1$1&&(browser$1$1.env.REACT_APP_SC_ATTR||browser$1$1.env.SC_ATTR)||"data-styled",C$1="undefined"!=typeof window&&"HTMLElement"in window,I=Boolean("boolean"==typeof SC_DISABLE_SPEEDY?SC_DISABLE_SPEEDY:"undefined"!=typeof browser$1$1&&void 0!==browser$1$1.env.REACT_APP_SC_DISABLE_SPEEDY&&""!==browser$1$1.env.REACT_APP_SC_DISABLE_SPEEDY?"false"!==browser$1$1.env.REACT_APP_SC_DISABLE_SPEEDY&&browser$1$1.env.REACT_APP_SC_DISABLE_SPEEDY:"undefined"!=typeof browser$1$1&&void 0!==browser$1$1.env.SC_DISABLE_SPEEDY&&""!==browser$1$1.env.SC_DISABLE_SPEEDY?"false"!==browser$1$1.env.SC_DISABLE_SPEEDY&&browser$1$1.env.SC_DISABLE_SPEEDY:"production"!==browser$1$1.env.NODE_ENV),O="production"!==browser$1$1.env.NODE_ENV?{1:"Cannot create styled-component for component: %s.\n\n",2:"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n",3:"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n",4:"The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n",5:"The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n",6:"Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n",7:'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n',8:'ThemeProvider: Please make your "theme" prop an object.\n\n',9:"Missing document `<head>`\n\n",10:"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n",11:"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n",12:"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n",13:"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n",14:'ThemeProvider: "theme" prop is required.\n\n',15:"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n",16:"Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n",17:"CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n"}:{};function R(){for(var e=arguments.length<=0?void 0:arguments[0],t=[],n=1,r=arguments.length;n<r;n+=1)t.push(n<0||arguments.length<=n?void 0:arguments[n]);return t.forEach((function(t){e=e.replace(/%[a-z]/,t);})),e}function D$1(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw "production"===browser$1$1.env.NODE_ENV?new Error("An error occurred. See https://git.io/JUIaE#"+e+" for more information."+(n.length>0?" Args: "+n.join(", "):"")):new Error(R.apply(void 0,[O[e]].concat(n)).trim())}var j$1=function(){function e(e){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=e;}var t=e.prototype;return t.indexOfGroup=function(e){for(var t=0,n=0;n<e;n++)t+=this.groupSizes[n];return t},t.insertRules=function(e,t){if(e>=this.groupSizes.length){for(var n=this.groupSizes,r=n.length,o=r;e>=o;)(o<<=1)<0&&D$1(16,""+e);this.groupSizes=new Uint32Array(o),this.groupSizes.set(n),this.length=o;for(var s=r;s<o;s++)this.groupSizes[s]=0;}for(var i=this.indexOfGroup(e+1),a=0,c=t.length;a<c;a++)this.tag.insertRule(i,t[a])&&(this.groupSizes[e]++,i++);},t.clearGroup=function(e){if(e<this.length){var t=this.groupSizes[e],n=this.indexOfGroup(e),r=n+t;this.groupSizes[e]=0;for(var o=n;o<r;o++)this.tag.deleteRule(n);}},t.getGroup=function(e){var t="";if(e>=this.length||0===this.groupSizes[e])return t;for(var n=this.groupSizes[e],r=this.indexOfGroup(e),o=r+n,s=r;s<o;s++)t+=this.tag.getRule(s)+"/*!sc*/\n";return t},e}(),T$2=new Map,x$2=new Map,k$1=1,V=function(e){if(T$2.has(e))return T$2.get(e);for(;x$2.has(k$1);)k$1++;var t=k$1++;return "production"!==browser$1$1.env.NODE_ENV&&((0|t)<0||t>1<<30)&&D$1(16,""+t),T$2.set(e,t),x$2.set(t,e),t},z$1=function(e){return x$2.get(e)},B=function(e,t){t>=k$1&&(k$1=t+1),T$2.set(e,t),x$2.set(t,e);},M="style["+N$1+'][data-styled-version="5.3.6"]',G=new RegExp("^"+N$1+'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),L=function(e,t,n){for(var r,o=n.split(","),s=0,i=o.length;s<i;s++)(r=o[s])&&e.registerName(t,r);},F=function(e,t){for(var n=(t.textContent||"").split("/*!sc*/\n"),r=[],o=0,s=n.length;o<s;o++){var i=n[o].trim();if(i){var a=i.match(G);if(a){var c=0|parseInt(a[1],10),u=a[2];0!==c&&(B(u,c),L(e,u,a[3]),e.getTag().insertRules(c,r)),r.length=0;}else r.push(i);}}},Y=function(){return "undefined"!=typeof __webpack_nonce__?__webpack_nonce__:null},q=function(e){var t=document.head,n=e||t,r=document.createElement("style"),o=function(e){for(var t=e.childNodes,n=t.length;n>=0;n--){var r=t[n];if(r&&1===r.nodeType&&r.hasAttribute(N$1))return r}}(n),s=void 0!==o?o.nextSibling:null;r.setAttribute(N$1,"active"),r.setAttribute("data-styled-version","5.3.6");var i=Y();return i&&r.setAttribute("nonce",i),n.insertBefore(r,s),r},H=function(){function e(e){var t=this.element=q(e);t.appendChild(document.createTextNode("")),this.sheet=function(e){if(e.sheet)return e.sheet;for(var t=document.styleSheets,n=0,r=t.length;n<r;n++){var o=t[n];if(o.ownerNode===e)return o}D$1(17);}(t),this.length=0;}var t=e.prototype;return t.insertRule=function(e,t){try{return this.sheet.insertRule(t,e),this.length++,!0}catch(e){return !1}},t.deleteRule=function(e){this.sheet.deleteRule(e),this.length--;},t.getRule=function(e){var t=this.sheet.cssRules[e];return void 0!==t&&"string"==typeof t.cssText?t.cssText:""},e}(),$$1=function(){function e(e){var t=this.element=q(e);this.nodes=t.childNodes,this.length=0;}var t=e.prototype;return t.insertRule=function(e,t){if(e<=this.length&&e>=0){var n=document.createTextNode(t),r=this.nodes[e];return this.element.insertBefore(n,r||null),this.length++,!0}return !1},t.deleteRule=function(e){this.element.removeChild(this.nodes[e]),this.length--;},t.getRule=function(e){return e<this.length?this.nodes[e].textContent:""},e}(),W=function(){function e(e){this.rules=[],this.length=0;}var t=e.prototype;return t.insertRule=function(e,t){return e<=this.length&&(this.rules.splice(e,0,t),this.length++,!0)},t.deleteRule=function(e){this.rules.splice(e,1),this.length--;},t.getRule=function(e){return e<this.length?this.rules[e]:""},e}(),U=C$1,J={isServer:!C$1,useCSSOMInjection:!I},X=function(){function e(e,t,n){void 0===e&&(e=w$1),void 0===t&&(t={}),this.options=y$2({},J,{},e),this.gs=t,this.names=new Map(n),this.server=!!e.isServer,!this.server&&C$1&&U&&(U=!1,function(e){for(var t=document.querySelectorAll(M),n=0,r=t.length;n<r;n++){var o=t[n];o&&"active"!==o.getAttribute(N$1)&&(F(e,o),o.parentNode&&o.parentNode.removeChild(o));}}(this));}e.registerId=function(e){return V(e)};var t=e.prototype;return t.reconstructWithOptions=function(t,n){return void 0===n&&(n=!0),new e(y$2({},this.options,{},t),this.gs,n&&this.names||void 0)},t.allocateGSInstance=function(e){return this.gs[e]=(this.gs[e]||0)+1},t.getTag=function(){return this.tag||(this.tag=(n=(t=this.options).isServer,r=t.useCSSOMInjection,o=t.target,e=n?new W(o):r?new H(o):new $$1(o),new j$1(e)));var e,t,n,r,o;},t.hasNameForId=function(e,t){return this.names.has(e)&&this.names.get(e).has(t)},t.registerName=function(e,t){if(V(e),this.names.has(e))this.names.get(e).add(t);else {var n=new Set;n.add(t),this.names.set(e,n);}},t.insertRules=function(e,t,n){this.registerName(e,t),this.getTag().insertRules(V(e),n);},t.clearNames=function(e){this.names.has(e)&&this.names.get(e).clear();},t.clearRules=function(e){this.getTag().clearGroup(V(e)),this.clearNames(e);},t.clearTag=function(){this.tag=void 0;},t.toString=function(){return function(e){for(var t=e.getTag(),n=t.length,r="",o=0;o<n;o++){var s=z$1(o);if(void 0!==s){var i=e.names.get(s),a=t.getGroup(o);if(i&&a&&i.size){var c=N$1+".g"+o+'[id="'+s+'"]',u="";void 0!==i&&i.forEach((function(e){e.length>0&&(u+=e+",");})),r+=""+a+c+'{content:"'+u+'"}/*!sc*/\n';}}}return r}(this)},e}(),Z=/(a)(d)/gi,K=function(e){return String.fromCharCode(e+(e>25?39:97))};function Q(e){var t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=K(t%52)+n;return (K(t%52)+n).replace(Z,"$1-$2")}var ee=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},te=function(e){return ee(5381,e)};function ne(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(E$1(n)&&!_$1(n))return !1}return !0}var re=te("5.3.6"),oe=function(){function e(e,t,n){this.rules=e,this.staticRulesId="",this.isStatic="production"===browser$1$1.env.NODE_ENV&&(void 0===n||n.isStatic)&&ne(e),this.componentId=t,this.baseHash=ee(re,t),this.baseStyle=n,X.registerId(t);}return e.prototype.generateAndInjectStyles=function(e,t,n){var r=this.componentId,o=[];if(this.baseStyle&&o.push(this.baseStyle.generateAndInjectStyles(e,t,n)),this.isStatic&&!n.hash)if(this.staticRulesId&&t.hasNameForId(r,this.staticRulesId))o.push(this.staticRulesId);else {var s=_e$1(this.rules,e,t,n).join(""),i=Q(ee(this.baseHash,s)>>>0);if(!t.hasNameForId(r,i)){var a=n(s,"."+i,void 0,r);t.insertRules(r,i,a);}o.push(i),this.staticRulesId=i;}else {for(var c=this.rules.length,u=ee(this.baseHash,n.hash),l="",d=0;d<c;d++){var h=this.rules[d];if("string"==typeof h)l+=h,"production"!==browser$1$1.env.NODE_ENV&&(u=ee(u,h+d));else if(h){var p=_e$1(h,e,t,n),f=Array.isArray(p)?p.join(""):p;u=ee(u,f+d),l+=f;}}if(l){var m=Q(u>>>0);if(!t.hasNameForId(r,m)){var y=n(l,"."+m,void 0,r);t.insertRules(r,m,y);}o.push(m);}}return o.join(" ")},e}(),se=/^\s*\/\/.*$/gm,ie=[":","[",".","#"];function ae(e){var t,n,r,o,s=void 0===e?w$1:e,i=s.options,a=void 0===i?w$1:i,c=s.plugins,u=void 0===c?S:c,l=new stylis_min(a),d=[],p=function(e){function t(t){if(t)try{e(t+"}");}catch(e){}}return function(n,r,o,s,i,a,c,u,l,d){switch(n){case 1:if(0===l&&64===r.charCodeAt(0))return e(r+";"),"";break;case 2:if(0===u)return r+"/*|*/";break;case 3:switch(u){case 102:case 112:return e(o[0]+r),"";default:return r+(0===d?"/*|*/":"")}case-2:r.split("/*|*/}").forEach(t);}}}((function(e){d.push(e);})),f=function(e,r,s){return 0===r&&-1!==ie.indexOf(s[n.length])||s.match(o)?e:"."+t};function m(e,s,i,a){void 0===a&&(a="&");var c=e.replace(se,""),u=s&&i?i+" "+s+" { "+c+" }":c;return t=a,n=s,r=new RegExp("\\"+n+"\\b","g"),o=new RegExp("(\\"+n+"\\b){2,}"),l(i||!s?"":s,u)}return l.use([].concat(u,[function(e,t,o){2===e&&o.length&&o[0].lastIndexOf(n)>0&&(o[0]=o[0].replace(r,f));},p,function(e){if(-2===e){var t=d;return d=[],t}}])),m.hash=u.length?u.reduce((function(e,t){return t.name||D$1(15),ee(e,t.name)}),5381).toString():"",m}var ce=r$3.createContext();ce.Consumer;var le=r$3.createContext(),de$1=(le.Consumer,new X),he=ae();function pe(){return useContext$1(ce)||de$1}function fe(){return useContext$1(le)||he}var ye=function(){function e(e,t){var n=this;this.inject=function(e,t){void 0===t&&(t=he);var r=n.name+t.hash;e.hasNameForId(n.id,r)||e.insertRules(n.id,r,t(n.rules,r,"@keyframes"));},this.toString=function(){return D$1(12,String(n.name))},this.name=e,this.id="sc-keyframes-"+e,this.rules=t;}return e.prototype.getName=function(e){return void 0===e&&(e=he),this.name+e.hash},e}(),ve=/([A-Z])/,ge=/([A-Z])/g,Se=/^ms-/,we=function(e){return "-"+e.toLowerCase()};function Ee(e){return ve.test(e)?e.replace(ge,we).replace(Se,"-ms-"):e}var be=function(e){return null==e||!1===e||""===e};function _e$1(e,n,r,o){if(Array.isArray(e)){for(var s,i=[],a=0,c=e.length;a<c;a+=1)""!==(s=_e$1(e[a],n,r,o))&&(Array.isArray(s)?i.push.apply(i,s):i.push(s));return i}if(be(e))return "";if(_$1(e))return "."+e.styledComponentId;if(E$1(e)){if("function"!=typeof(l=e)||l.prototype&&l.prototype.isReactComponent||!n)return e;var u=e(n);return "production"!==browser$1$1.env.NODE_ENV&&reactIs$4.exports.isElement(u)&&console.warn(b$1(e)+" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."),_e$1(u,n,r,o)}var l;return e instanceof ye?r?(e.inject(r,o),e.getName(o)):e:g$1(e)?function e(t,n){var r,o,s=[];for(var i in t)t.hasOwnProperty(i)&&!be(t[i])&&(Array.isArray(t[i])&&t[i].isCss||E$1(t[i])?s.push(Ee(i)+":",t[i],";"):g$1(t[i])?s.push.apply(s,e(t[i],i)):s.push(Ee(i)+": "+(r=i,null==(o=t[i])||"boolean"==typeof o||""===o?"":"number"!=typeof o||0===o||r in unitlessKeys?String(o).trim():o+"px")+";"));return n?[n+" {"].concat(s,["}"]):s}(e):e.toString()}var Ne=function(e){return Array.isArray(e)&&(e.isCss=!0),e};function Ae(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return E$1(e)||g$1(e)?Ne(_e$1(v$2(S,[e].concat(n)))):0===n.length&&1===e.length&&"string"==typeof e[0]?e:Ne(_e$1(v$2(e,n)))}var Ce=/invalid hook call/i,Ie=new Set,Pe=function(e,t){if("production"!==browser$1$1.env.NODE_ENV){var n="The component "+e+(t?' with the id of "'+t+'"':"")+" has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.",r=console.error;try{var o=!0;console.error=function(e){if(Ce.test(e))o=!1,Ie.delete(n);else {for(var t=arguments.length,s=new Array(t>1?t-1:0),i=1;i<t;i++)s[i-1]=arguments[i];r.apply(void 0,[e].concat(s));}},useRef$1(),o&&!Ie.has(n)&&(console.warn(n),Ie.add(n));}catch(e){Ce.test(e.message)&&Ie.delete(n);}finally{console.error=r;}}},Oe=function(e,t,n){return void 0===n&&(n=w$1),e.theme!==n.theme&&e.theme||t||n.theme},Re=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,De=/(^-|-$)/g;function je(e){return e.replace(Re,"-").replace(De,"")}var Te=function(e){return Q(te(e)>>>0)};function xe(e){return "string"==typeof e&&("production"===browser$1$1.env.NODE_ENV||e.charAt(0)===e.charAt(0).toLowerCase())}var ke=function(e){return "function"==typeof e||"object"==typeof e&&null!==e&&!Array.isArray(e)},Ve=function(e){return "__proto__"!==e&&"constructor"!==e&&"prototype"!==e};function ze(e,t,n){var r=e[n];ke(t)&&ke(r)?Be(r,t):e[n]=t;}function Be(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(var o=0,s=n;o<s.length;o++){var i=s[o];if(ke(i))for(var a in i)Ve(a)&&ze(e,i[a],a);}return e}var Me=r$3.createContext();Me.Consumer;var Fe={};function Ye(e,t,n){var o=_$1(e),i=!xe(e),a=t.attrs,c=void 0===a?S:a,d=t.componentId,h=void 0===d?function(e,t){var n="string"!=typeof e?"sc":je(e);Fe[n]=(Fe[n]||0)+1;var r=n+"-"+Te("5.3.6"+n+Fe[n]);return t?t+"-"+r:r}(t.displayName,t.parentComponentId):d,p=t.displayName,v=void 0===p?function(e){return xe(e)?"styled."+e:"Styled("+b$1(e)+")"}(e):p,g=t.displayName&&t.componentId?je(t.displayName)+"-"+t.componentId:t.componentId||h,N=o&&e.attrs?Array.prototype.concat(e.attrs,c).filter(Boolean):c,A=t.shouldForwardProp;o&&e.shouldForwardProp&&(A=t.shouldForwardProp?function(n,r,o){return e.shouldForwardProp(n,r,o)&&t.shouldForwardProp(n,r,o)}:e.shouldForwardProp);var C,I=new oe(n,g,o?e.componentStyle:void 0),P=I.isStatic&&0===c.length,O=function(e,t){return function(e,t,n,r){var o=e.attrs,i=e.componentStyle,a=e.defaultProps,c=e.foldedComponentIds,d=e.shouldForwardProp,h=e.styledComponentId,p=e.target;"production"!==browser$1$1.env.NODE_ENV&&useDebugValue$1(h);var m=function(e,t,n){void 0===e&&(e=w$1);var r=y$2({},t,{theme:e}),o={};return n.forEach((function(e){var t,n,s,i=e;for(t in E$1(i)&&(i=i(r)),i)r[t]=o[t]="className"===t?(n=o[t],s=i[t],n&&s?n+" "+s:n||s):i[t];})),[r,o]}(Oe(t,useContext$1(Me),a)||w$1,t,o),v=m[0],g=m[1],S=function(e,t,n,r){var o=pe(),s=fe(),i=t?e.generateAndInjectStyles(w$1,o,s):e.generateAndInjectStyles(n,o,s);return "production"!==browser$1$1.env.NODE_ENV&&useDebugValue$1(i),"production"!==browser$1$1.env.NODE_ENV&&!t&&r&&r(i),i}(i,r,v,"production"!==browser$1$1.env.NODE_ENV?e.warnTooManyClasses:void 0),b=n,_=g.$as||t.$as||g.as||t.as||p,N=xe(_),A=g!==t?y$2({},t,{},g):t,C={};for(var I in A)"$"!==I[0]&&"as"!==I&&("forwardedAs"===I?C.as=A[I]:(d?d(I,isPropValid,_):!N||isPropValid(I))&&(C[I]=A[I]));return t.style&&g.style!==t.style&&(C.style=y$2({},t.style,{},g.style)),C.className=Array.prototype.concat(c,h,S!==h?S:null,t.className,g.className).filter(Boolean).join(" "),C.ref=b,createElement$1(_,C)}(C,e,t,P)};return O.displayName=v,(C=r$3.forwardRef(O)).attrs=N,C.componentStyle=I,C.displayName=v,C.shouldForwardProp=A,C.foldedComponentIds=o?Array.prototype.concat(e.foldedComponentIds,e.styledComponentId):S,C.styledComponentId=g,C.target=o?e.target:e,C.withComponent=function(e){var r=t.componentId,o=function(e,t){if(null==e)return {};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(t,["componentId"]),s=r&&r+"-"+(xe(e)?e:je(b$1(e)));return Ye(e,y$2({},o,{attrs:N,componentId:s}),n)},Object.defineProperty(C,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(t){this._foldedDefaultProps=o?Be({},e.defaultProps,t):t;}}),"production"!==browser$1$1.env.NODE_ENV&&(Pe(v,g),C.warnTooManyClasses=function(e,t){var n={},r=!1;return function(o){if(!r&&(n[o]=!0,Object.keys(n).length>=200)){var s=t?' with the id of "'+t+'"':"";console.warn("Over 200 classes were generated for component "+e+s+".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"),r=!0,n={};}}}(v,g)),C.toString=function(){return "."+C.styledComponentId},i&&hoistNonReactStatics_cjs(C,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0,withComponent:!0}),C}var qe=function(e){return function e(t,r,o){if(void 0===o&&(o=w$1),!reactIs$4.exports.isValidElementType(r))return D$1(1,String(r));var s=function(){return t(r,o,Ae.apply(void 0,arguments))};return s.withConfig=function(n){return e(t,r,y$2({},o,{},n))},s.attrs=function(n){return e(t,r,y$2({},o,{attrs:Array.prototype.concat(o.attrs,n).filter(Boolean)}))},s}(Ye,e)};["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","textPath","tspan"].forEach((function(e){qe[e]=qe(e);}));"production"!==browser$1$1.env.NODE_ENV&&"undefined"!=typeof navigator&&"ReactNative"===navigator.product&&console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"),"production"!==browser$1$1.env.NODE_ENV&&"test"!==browser$1$1.env.NODE_ENV&&"undefined"!=typeof window&&(window["__styled-components-init__"]=window["__styled-components-init__"]||0,1===window["__styled-components-init__"]&&console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."),window["__styled-components-init__"]+=1);var styled = qe;

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
function Identicon$4({
  address,
  className = '',
  style
}) {
  const imgSrc = useMemo$1(() => makeBlockie(address), [address]);
  return /*#__PURE__*/jsx("img", {
    className: className,
    src: imgSrc,
    style: style
  });
}
const Ethereum = /*#__PURE__*/r$3.memo(styled(Identicon$4).withConfig({
  displayName: "Ethereum",
  componentId: "sc-osop9v-0"
})(({
  size
}) => `
  display: block;
  height: ${size}px;
  width: ${size}px;
`));

/**
 * Keeps a list of edges per scanline.
 * @param {number} width  Clipping width.
 * @param {number} height  Clipping height.
 */
function EdgeTable$1(width, height) {
    this.width = width;
    this.height = height;
    this.clear();
}

/**
 * Sorts the edges of each scanline in ascending x coordinates.
 */
EdgeTable$1.prototype.clear = function EdgeTable_clear() {
    this.scanlines = [];
    this.scanlines.length = this.height;
    this.nextId = 1;
};

/**
 * Adds an edge to the table.
 * @param {Edge} edge
 */
EdgeTable$1.prototype.add = function EdgeTable_add(edge) {
    var minY, maxY;

    if (edge.y0 == edge.y1) {
        // Skip horizontal lines
        return;
    }
    else if (edge.y0 < edge.y1) {
        minY = Math.floor(edge.y0);
        maxY = Math.floor(edge.y1 + 0.996 /* 1/255 */);
    }
    else {
        minY = Math.floor(edge.y1);
        maxY = Math.floor(edge.y0 + 0.996 /* 1/255 */);
    }

    if (maxY < 0 || minY >= this.scanlines.length) {
        return;
    }

    if (minY < 0) {
        minY = 0;
    }
    if (maxY > this.scanlines.length) {
        maxY = this.scanlines.length;
    }

    if (minY < maxY) {
        var y = minY;
        var x1 = edge.intersection(y);

        while (y < maxY) {
            var x2 = edge.intersection(y + 1);

            var fromX, width;
            if (x1 < x2) {
                fromX = Math.floor(x1);
                width = Math.floor(x2 + 0.9999) - fromX;
            }
            else {
                fromX = Math.floor(x2);
                width = Math.floor(x1 + 0.9999) - fromX;
            }

            if (fromX < 0) {
                width += fromX;
                fromX = 0;

                if (width < 0) {
                    width = 0;
                }
            }

            if (fromX < this.width) {
                var scanline = this.scanlines[y];
                if (scanline == null) {
                    this.scanlines[y] = scanline = [];
                }
                scanline.push({
                    fromX: fromX,
                    width: width,
                    edge: edge
                });
            }

            x1 = x2;
            y++;
        }
    }
};

/**
 * Sorts the edges of each scanline in ascending x coordinates.
 */
EdgeTable$1.prototype.sort = function EdgeTable_sort() {
    for (var i = 0; i < this.scanlines.length; i++) {
        var arr = this.scanlines[i];
        if (arr) {
            arr.sort(function (x, y) {
                if (x.fromX < y.fromX) {
                    return -1;
                }
                if (x.fromX > y.fromX) {
                    return 1;
                }
                return 0;
            });
        }
    }
};

var edgeTable = EdgeTable$1;

var edgeTable$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), edgeTable, {
    'default': edgeTable
}));

var require$$0$R = /*@__PURE__*/getAugmentedNamespace(edgeTable$1);

var colorUtils$8 = {
    /**
     * Transparent color.
     * @type {number}
     * @constant
     */
    TRANSPARENT: 0,

    /**
     * Specifies a transparent color that will not blend with layers below the current layer.
     * @type {number}
     * @constant
     */
    FORCE_TRANSPARENT: Infinity,

    /**
     * Creates a signed 32-bit RGBA color value from the specified color components.
     * @returns {number}
     */
    from: colorUtils_from,

    /**
     * Gets the alpha component of a color.
     * @param {number} color  32-bit color value on the format 0xRRGGBBAA.
     * @returns {number}
     */
    alpha: colorUtils_alpha,

    /**
     * Gets the red component of a color.
     * @param {number} color  32-bit color value on the format 0xRRGGBBAA.
     * @returns {number}
     */
    red: colorUtils_red,

    /**
     * Gets the green component of a color.
     * @param {number} color  32-bit color value on the format 0xRRGGBBAA.
     * @returns {number}
     */
    green: colorUtils_green,

    /**
     * Gets the blue component of a color.
     * @param {number} color  32-bit color value on the format 0xRRGGBBAA.
     * @returns {number}
     */
    blue: colorUtils_blue,

    /**
     * Parses a value to a 32-bit color on the format 0xRRGGBBAA. The following formats are supported:
     * - 32 bit integers on the format `0xRRGGBBAA`
     * - strings on the format `"#RGB"`
     * - strings on the format `"#RGBA"`
     * - strings on the format `"#RRGGBB"`
     * - strings on the format `"#RRGGBBAA"`
     * - strings on the format `"rgb(255, 255, 255)"`
     * - strings on the format `"rgb(255, 255, 255, 0.5)"`
     * - strings on the format `"rgb(255, 255, 255, 50%)"`
     * - strings on the format `"rgba(255, 255, 255, 0.5)"`
     * - strings on the format `"rgba(255, 255, 255, 50%)"`
     * - strings on the format `"hsl(134, 50%, 50%)"`
     * - strings on the format `"hsl(134, 50%, 50%, 0.5)"`
     * - strings on the format `"hsl(134, 50%, 50%, 50%)"`
     * - strings on the format `"hsla(134, 50%, 50%, 0.5)"`
     * - strings on the format `"hsla(134, 50%, 50%, 50%)"`
     * - strings on the format `"hwb(134, 50%, 50%)"`
     * - strings on the format `"hwb(134, 50%, 50%, 0.5)"`
     * - strings on the format `"hwb(134, 50%, 50%, 50%)"`
     *
     * @param {number|string} color  The value to parse.
     * @returns {number}
     */
    parse: colorUtils_parse,
    
    /**
     * Computes a mix of the two specified colors, with the proportion given by the specified weight.
     * @param {number} color1  First color to mix.
     * @param {number} color2  Second color to mix.
     * @param {number} weight  Weight in the range [0,1]. 0 gives color1, 1 gives color2.
     * @returns {number} Mixed color.
     */
    mix: colorUtils_mix,
    
    /**
     * Formats the specified color as a hex string #RRGGBBAA.
     * @param {number|string} color  The color to format. Can be a numeric color on the format 0xRRGGBBAA or a string parsable by colorUtils.parse.
     * @returns {string}
     */
    format: function colorUtils_format(color) {
        color = colorUtils_parse(color);
        if (isFinite(color)) {
            return "#" + 
                ("000000" + (color >>> 8).toString(16)).slice(-6) + 
                ("00" + (color & 0xff).toString(16)).slice(-2);
        }
    },

    /**
     * Blends this color with another color using the over blending operation.
     * @param {number} fore  The foreground color.
     * @param {number} back  The background color.
     */
    over: function colorUtils_over(fore, back) {
        var foreA = colorUtils_alpha(fore);

        if (foreA < 1) {
            return back;
        }
        else if (foreA > 254 || colorUtils_alpha(back) < 1) {
            return fore;
        }

        // Source: https://en.wikipedia.org/wiki/Alpha_compositing#Description
        var forePA = foreA * 255;
        var backPA = colorUtils_alpha(back) * (255 - foreA);
        var pa = (forePA + backPA);

        var b = Math.floor(
            (forePA * colorUtils_blue(fore) + backPA * colorUtils_blue(back)) /
            pa);

        var g = Math.floor(
            (forePA * colorUtils_green(fore) + backPA * colorUtils_green(back)) /
            pa);

        var r = Math.floor(
            (forePA * colorUtils_red(fore) + backPA * colorUtils_red(back)) /
            pa);

        var a = Math.floor(pa / 255);

        return (r << 24) | (g << 16) | (b << 8) | a;
    }
};

function colorUtils_mix(color1, color2, weight) {
    if (weight < 0) {
        weight = 0;
    }
    else if (weight > 1) {
        weight = 1;
    }
    
    var a = (color1 & 0xff) * (1 - weight) + (color2 & 0xff) * weight;
    if (a <= 0.1) {
        return 0;
    }
    
    var r = (
        (color1 >>> 24) * (color1 & 0xff) * (1 - weight) +
        (color2 >>> 24) * (color2 & 0xff) * weight
        ) / a;
        
    var g = (
        ((color1 >>> 16) & 0xff) * (color1 & 0xff) * (1 - weight) +
        ((color2 >>> 16) & 0xff) * (color2 & 0xff) * weight
        ) / a;
        
    var b = (
        ((color1 >>> 8) & 0xff) * (color1 & 0xff) * (1 - weight) +
        ((color2 >>> 8) & 0xff) * (color2 & 0xff) * weight
        ) / a;
    
    if (a > 255) a = 255;    
    if (r > 255) r = 255;
    if (g > 255) g = 255;
    if (b > 255) b = 255;
    
    return (r << 24) | (g << 16) | (b << 8) | a;
}

function colorUtils_from(a, r, g, b) {
    return (r << 24) | (g << 16) | (b << 8) | a;
}

function colorUtils_alpha(color) {
    return color & 0xff;
}

function colorUtils_red(color) {
    return (color >>> 24);
}

function colorUtils_green(color) {
    return (color >>> 16) & 0xff;
}

function colorUtils_blue(color) {
    return (color >>> 8) & 0xff;
}

// Named colors as defined in CSS Color Module Level 4.
// https://www.w3.org/TR/css-color-4/#named-colors
var NAMED_COLORS = {
    "transparent": 0,
    "antiquewhite": 0xFAEBD7FF,
    "aqua": 0x00FFFFFF,
    "aquamarine": 0x7FFFD4FF,
    "azure": 0xF0FFFFFF,
    "beige": 0xF5F5DCFF,
    "bisque": 0xFFE4C4FF,
    "black": 0x000000FF,
    "blanchedalmond": 0xFFEBCDFF,
    "blue": 0x0000FFFF,
    "blueviolet": 0x8A2BE2FF,
    "brown": 0xA52A2AFF,
    "burlywood": 0xDEB887FF,
    "cadetblue": 0x5F9EA0FF,
    "chartreuse": 0x7FFF00FF,
    "chocolate": 0xD2691EFF,
    "coral": 0xFF7F50FF,
    "cornflowerblue": 0x6495EDFF,
    "cornsilk": 0xFFF8DCFF,
    "crimson": 0xDC143CFF,
    "cyan": 0x00FFFFFF,
    "darkblue": 0x00008BFF,
    "darkcyan": 0x008B8BFF,
    "darkgoldenrod": 0xB8860BFF,
    "darkgray": 0xA9A9A9FF,
    "darkgreen": 0x006400FF,
    "darkgrey": 0xA9A9A9FF,
    "darkkhaki": 0xBDB76BFF,
    "darkmagenta": 0x8B008BFF,
    "darkolivegreen": 0x556B2FFF,
    "darkorange": 0xFF8C00FF,
    "darkorchid": 0x9932CCFF,
    "darkred": 0x8B0000FF,
    "darksalmon": 0xE9967AFF,
    "darkseagreen": 0x8FBC8FFF,
    "darkslateblue": 0x483D8BFF,
    "darkslategray": 0x2F4F4FFF,
    "darkslategrey": 0x2F4F4FFF,
    "darkturquoise": 0x00CED1FF,
    "darkviolet": 0x9400D3FF,
    "deeppink": 0xFF1493FF,
    "deepskyblue": 0x00BFFFFF,
    "dimgray": 0x696969FF,
    "dimgrey": 0x696969FF,
    "dodgerblue": 0x1E90FFFF,
    "firebrick": 0xB22222FF,
    "floralwhite": 0xFFFAF0FF,
    "forestgreen": 0x228B22FF,
    "fuchsia": 0xFF00FFFF,
    "gainsboro": 0xDCDCDCFF,
    "ghostwhite": 0xF8F8FFFF,
    "gold": 0xFFD700FF,
    "goldenrod": 0xDAA520FF,
    "gray": 0x808080FF,
    "green": 0x008000FF,
    "greenyellow": 0xADFF2FFF,
    "grey": 0x808080FF,
    "honeydew": 0xF0FFF0FF,
    "hotpink": 0xFF69B4FF,
    "indianred": 0xCD5C5CFF,
    "indigo": 0x4B0082FF,
    "ivory": 0xFFFFF0FF,
    "khaki": 0xF0E68CFF,
    "lavender": 0xE6E6FAFF,
    "lavenderblush": 0xFFF0F5FF,
    "lawngreen": 0x7CFC00FF,
    "lemonchiffon": 0xFFFACDFF,
    "lightblue": 0xADD8E6FF,
    "lightcoral": 0xF08080FF,
    "lightcyan": 0xE0FFFFFF,
    "lightgoldenrodyellow": 0xFAFAD2FF,
    "lightgray": 0xD3D3D3FF,
    "lightgreen": 0x90EE90FF,
    "lightgrey": 0xD3D3D3FF,
    "lightpink": 0xFFB6C1FF,
    "lightsalmon": 0xFFA07AFF,
    "lightseagreen": 0x20B2AAFF,
    "lightskyblue": 0x87CEFAFF,
    "lightslategray": 0x778899FF,
    "lightslategrey": 0x778899FF,
    "lightsteelblue": 0xB0C4DEFF,
    "lightyellow": 0xFFFFE0FF,
    "lime": 0x00FF00FF,
    "limegreen": 0x32CD32FF,
    "linen": 0xFAF0E6FF,
    "magenta": 0xFF00FFFF,
    "maroon": 0x800000FF,
    "mediumaquamarine": 0x66CDAAFF,
    "mediumblue": 0x0000CDFF,
    "mediumorchid": 0xBA55D3FF,
    "mediumpurple": 0x9370DBFF,
    "mediumseagreen": 0x3CB371FF,
    "mediumslateblue": 0x7B68EEFF,
    "mediumspringgreen": 0x00FA9AFF,
    "mediumturquoise": 0x48D1CCFF,
    "mediumvioletred": 0xC71585FF,
    "midnightblue": 0x191970FF,
    "mintcream": 0xF5FFFAFF,
    "mistyrose": 0xFFE4E1FF,
    "moccasin": 0xFFE4B5FF,
    "navajowhite": 0xFFDEADFF,
    "navy": 0x000080FF,
    "oldlace": 0xFDF5E6FF,
    "olive": 0x808000FF,
    "olivedrab": 0x6B8E23FF,
    "orange": 0xFFA500FF,
    "orangered": 0xFF4500FF,
    "orchid": 0xDA70D6FF,
    "palegoldenrod": 0xEEE8AAFF,
    "palegreen": 0x98FB98FF,
    "paleturquoise": 0xAFEEEEFF,
    "palevioletred": 0xDB7093FF,
    "papayawhip": 0xFFEFD5FF,
    "peachpuff": 0xFFDAB9FF,
    "peru": 0xCD853FFF,
    "pink": 0xFFC0CBFF,
    "plum": 0xDDA0DDFF,
    "powderblue": 0xB0E0E6FF,
    "purple": 0x800080FF,
    "rebeccapurple": 0x663399FF,
    "red": 0xFF0000FF,
    "rosybrown": 0xBC8F8FFF,
    "royalblue": 0x4169E1FF,
    "saddlebrown": 0x8B4513FF,
    "salmon": 0xFA8072FF,
    "sandybrown": 0xF4A460FF,
    "seagreen": 0x2E8B57FF,
    "seashell": 0xFFF5EEFF,
    "sienna": 0xA0522DFF,
    "silver": 0xC0C0C0FF,
    "skyblue": 0x87CEEBFF,
    "slateblue": 0x6A5ACDFF,
    "slategray": 0x708090FF,
    "slategrey": 0x708090FF,
    "snow": 0xFFFAFAFF,
    "springgreen": 0x00FF7FFF,
    "steelblue": 0x4682B4FF,
    "tan": 0xD2B48CFF,
    "teal": 0x008080FF,
    "thistle": 0xD8BFD8FF,
    "tomato": 0xFF6347FF,
    "turquoise": 0x40E0D0FF,
    "violet": 0xEE82EEFF,
    "wheat": 0xF5DEB3FF,
    "white": 0xFFFFFFFF,
    "whitesmoke": 0xF5F5F5FF,
    "yellow": 0xFFFF00FF,
    "yellowgreen": 0x9ACD32FF
};

function parseRgbComponent(value) {
    var match = value.match(/^\s*(\d*(?:\.\d*)?)(%?)\s*$/);
    if (match) {
        var result = parseFloat(match[1]);
        if (isNaN(result)) {
            return NaN;
        }
        
        result = match[2] ?
        
            // Percentage
            255 * result / 100 :
            
            // Absolute number
            result;
        
        result = 0 | result;
        
        if (result < 0) {
            result = 0;
        }
        if (result > 255) {
            result = 255;
        }
        
        return result;
    }
    return NaN;
}

function parsePercent(value) {
    var match = value.match(/^\s*(\d*(?:\.\d*)?)%\s*$/);
    if (match) {
        var result = parseFloat(match[1]);
        if (isNaN(result)) {
            return NaN;
        }
        
        // Percentage
        result = result / 100;
        
        return (
            result < 0 ? 0 : 
            result > 1 ? 1 : 
            result
            );
    }
    return NaN;
}

function parseAlpha(value) {
    if (!value) {
        return 255;
    }
    
    var match = value.match(/^\s*(\d*(?:\.\d*)?)(%?)\s*$/);
    if (match) {
        var result = parseFloat(match[1]);
        if (isNaN(result)) {
            return NaN;
        }
        
        // Percentage
        if (match[2]) {
            result = result / 100;
        }
        
        result = 0 | (255 * result);
        
        return (
            result < 0 ? 0 : 
            result > 255 ? 255 : 
            result
            );
    }
    return NaN;
}

// HSL conversion from CSS Color Module Level 4
// Source: https://www.w3.org/TR/css-color-4/#hsl-to-rgb
function hslToRgb(hue, sat, light) {
    if (light <= .5) {
        var t2 = light * (sat + 1);
    } else {
        var t2 = light + sat - (light * sat);
    }
    var t1 = light * 2 - t2;
    var r = hueToRgb$1(t1, t2, hue + 2);
    var g = hueToRgb$1(t1, t2, hue);
    var b = hueToRgb$1(t1, t2, hue - 2);
    return [r, g, b];
}
function hueToRgb$1(t1, t2, hue) {
    if (hue < 0) hue += 6;
    if (hue >= 6) hue -= 6;

    if (hue < 1) return (t2 - t1) * hue + t1;
    else if (hue < 3) return t2;
    else if (hue < 4) return (t2 - t1) * (4 - hue) + t1;
    else return t1;
}

// https://www.w3.org/TR/css-color-4/#hwb-to-rgb
function hwbToRgb(hue, white, black) {
    var rgb = hslToRgb(hue, 1, .5);
    for (var i = 0; i < 3; i++) {
        rgb[i] *= (1 - white - black);
        rgb[i] += white;
    }
    return rgb;
}

function parseHsla(h, s, l, a) {
    if (isFinite(h = parseHue(h)) && 
        isFinite(s = parsePercent(s)) && 
        isFinite(l = parsePercent(l)) && 
        isFinite(a = parseAlpha(a))) {
        var rgb = hslToRgb(h, s, l);
        return colorUtils_from(a, 
            (rgb[0] * 255) & 0xff, 
            (rgb[1] * 255) & 0xff, 
            (rgb[2] * 255) & 0xff);
    }
}


function parseRgba(r, g, b, a) {
    if (isFinite(r = parseRgbComponent(r)) && 
        isFinite(g = parseRgbComponent(g)) && 
        isFinite(b = parseRgbComponent(b)) && 
        isFinite(a = parseAlpha(a))) {
        return colorUtils_from(a, r, g, b);
    }
}

// Outputs a value [0, 6)
function parseHue(value) {
    var match = value.match(/^\s*(\d*(?:\.\d*)?)(deg|grad|rad|turn|)\s*$/);
    if (match) {
        var result = parseFloat(match[1]);
        if (isNaN(result)) {
            return NaN;
        }
        
        // Percentage
        switch (match[2]) {
            case "grad":
                // Gradians: range 0 - 400
                result = 6 * result / 400;
                break;
            case "rad":
                // Radians: range 0 - 2π
                result = 3 * result / Math.PI;
                break;
            case "turn":
                // Turns: range 0 - 1
                result = result * 6;
                break;
            default:
                // Degree: range 0 - 360
                result = result / 60;
                break;
        }
        
        result = (result % 6);
        
        if (result < 0) {
            result += 6;
        }
        
        return result;
    }
    return NaN;
}

function parseHexColor(color) {
    var hexColor = color; 
    if (hexColor.charAt(0) == "#") {
        hexColor = hexColor.substr(1);
    }

    var numeric = parseInt(hexColor, 16);
    
    // numeric is now parsed as a 32-bit unsigned integer.
    // All return paths below must perform a bitwise operator
    // on numeric before returning it to ensure it is converted to a 
    // 32-bit signed integer.

    switch (hexColor.length) {
        case 3:
            return (
                ((numeric & 0xf00) << 20) |
                ((numeric & 0xf00) << 16) |
                ((numeric & 0x0f0) << 16) |
                ((numeric & 0x0f0) << 12) |
                ((numeric & 0x00f) << 12) |
                ((numeric & 0x00f) << 8) | 
                0xff);
        case 4:
            return (
                ((numeric & 0xf000) << 16) |
                ((numeric & 0xf000) << 12) |
                ((numeric & 0x0f00) << 12) |
                ((numeric & 0x0f00) << 8) |
                ((numeric & 0x00f0) << 8) |
                ((numeric & 0x00f0) << 4) | 
                ((numeric & 0x000f) << 4) |
                ((numeric & 0x000f))
                );
        case 6:
            return numeric << 8 | 0xff;
        case 8:
            // The bitwise operation enforces the value to a 32-bit signed integer
            return numeric & 0xffffffff;
    }
}

function parseHwb(h, w, b, a) {
    if (isFinite(h = parseHue(h)) && 
        isFinite(w = parsePercent(w)) && 
        isFinite(b = parsePercent(b)) && 
        isFinite(a = parseAlpha(a))) {
        if (w + b > 1) {
            w = w / (w + b);
            b = 1 - w;
        }
        var rgb = hwbToRgb(h, w, b);
        return colorUtils_from(a, 
            (rgb[0] * 255) & 0xff, 
            (rgb[1] * 255) & 0xff, 
            (rgb[2] * 255) & 0xff);
    }
}

function colorUtils_parse(color) {
    if (typeof color == "number") {
        return color & 0xffffffff;
    }

    color = "" + color;
    
    // Hex colors
    if (/^#?[0-9a-f]{3,8}$/i.test(color)) {
        return parseHexColor(color);
    }
    
    color = color.toLowerCase();
    
    // Named colors
    if (color in NAMED_COLORS) {
        // bitwise operator is used to enforce a signed integer
        return NAMED_COLORS[color] & 0xffffffff;
    }
    
    // rgb[a](red, green, blue[, alpha])
    var rgba = color.match(/^rgba?\(([^,]+),([^,]+),([^,]+)(?:,([^,]+))?\)$/);
    if (rgba) {
        return parseRgba(rgba[1], rgba[2], rgba[3], rgba[4]);
    }
    
    // hsl[a](hue, saturation, lightness[, alpha])
    var hsla = color.match(/^hsla?\(([^,]+),([^,]+),([^,]+)(?:,([^,]+))?\)$/);
    if (hsla) {
        return parseHsla(hsla[1], hsla[2], hsla[3], hsla[4]);
    }
    
    // hwb(hue, whiteness, blackness[, alpha]?)
    var hwb = color.match(/^hwb\(([^,]+),([^,]+),([^,]+)(?:,([^,]+))?\)$/);
    if (hwb) {
        return parseHwb(hwb[1], hwb[2], hwb[3], hwb[4]);
    }

    throw new Error("Invalid color " + color);
}

var colorUtils$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), colorUtils$8, {
    'default': colorUtils$8
}));

var require$$5$m = /*@__PURE__*/getAugmentedNamespace(colorUtils$9);

const colorUtils$7 = require$$5$m;

function BitmapWriter$1(backColor, width, height) {
    this.backColor = backColor;
    this.canvas = [];
}

BitmapWriter$1.prototype.write = function write(color, count) {
    if (count > 0) {
        this.canvas.push(count);
        this.canvas.push(colorUtils$7.over(color, this.backColor));
    }
};

BitmapWriter$1.prototype.skip = function skip(count) {
    if (count > 0) {
        this.canvas.push(count);
        this.canvas.push(this.backColor);
    }
};

var bitmapWriter = BitmapWriter$1;

var bitmapWriter$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bitmapWriter, {
    'default': bitmapWriter
}));

var require$$0$Q = /*@__PURE__*/getAugmentedNamespace(bitmapWriter$1);

const colorUtils$6 = require$$5$m;

/**
 * Keeps track of the z-order of the currently rendered polygons,
 * and computes the final color from the stack of layers.
 */
function LayerManager$1() {
    this._layers = [];
}

/**
 * The current visible color.
 */
LayerManager$1.prototype.color = colorUtils$6.TRANSPARENT;

/**
 * Clears the stack of layers.
 */
LayerManager$1.prototype.clear = function LayerManager_clear() {
    this._layers = [];
    this.color = colorUtils$6.TRANSPARENT;
};

/**
 * Copies all layers in this LayerManager to another LayerManager.
 * @param {LayerManager} other
 */
LayerManager$1.prototype.copyTo = function LayerManager_copyTo(other) {
    other.color = this.color;
    other._layers = [];
    
    for (var i = 0; i < this._layers.length; i++) {
        var layer = this._layers[i];
        other._layers[i] = {
            color: layer.color,
            inPath: layer.inPath,
            polygonId: layer.polygonId,
            winding: layer.winding
        };
    }
};

/**
 * Adds a layer for the specified edge. The z-order is defined by its id.
 * @param {Edge} edge
 */
LayerManager$1.prototype.add = function LayerManager_add(edge) {
    var dwinding = edge.y0 < edge.y1 ? 1 : -1;

    var inserted = false;
    for (var i = this._layers.length - 1; i >= 0; i--) {
        if (this._layers[i].polygonId == edge.polygonId) {
            this._layers[i].winding += dwinding;

            if (!this._layers[i].inPath()) {
                this._layers.splice(i, 1);
            }

            inserted = true;
            break;
        }
        else if (this._layers[i].polygonId < edge.polygonId) {
            // Insert here
            this._layers.splice(i + 1, 0, {
                polygonId: edge.polygonId,
                color: edge.color,
                winding: dwinding,
                inPath: edge.windingRule == "evenodd" ? inPath_evenOdd : inPath_nonZero
            });

            inserted = true;
            break;
        }
    }

    if (!inserted) {
        this._layers.splice(0, 0, {
            polygonId: edge.polygonId,
            color: edge.color,
            winding: dwinding,
            inPath: edge.windingRule == "evenodd" ? inPath_evenOdd : inPath_nonZero
        });
    }

    // Update current color
    var color = colorUtils$6.TRANSPARENT;
    for (var i = this._layers.length - 1; i >= 0 && colorUtils$6.alpha(color) < 255; i--) {
        var layerColor = this._layers[i].color;
        if (layerColor === colorUtils$6.FORCE_TRANSPARENT) {
            break;
        }

        color = colorUtils$6.over(color, layerColor);
    }
    this.color = color;
};

var layerManager = LayerManager$1;


// Defines the winding rules

function inPath_evenOdd() {
    return this.winding % 2 == 1;
}
function inPath_nonZero() {
    return this.winding != 0;
}

var layerManager$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), layerManager, {
    'default': layerManager
}));

var require$$1$13 = /*@__PURE__*/getAugmentedNamespace(layerManager$1);

const colorUtils$5 = require$$5$m;

const IDX_COUNT = 0;
const IDX_A = 1;
const IDX_R = 2;
const IDX_G = 3;
const IDX_B = 4;

/**
 * Creates a color buffer keeping an average color out of several
 * color samples per pixel.
 * @param {number} width  Width of the buffer in pixels.
 * @param {number} samplesPerPixel  Number of samples to keep per pixel.
 */
function SuperSampleBuffer$1(width, samplesPerPixel) {
    this._samples = new Uint16Array(width * 5); 
    this._samplesPerPixel = samplesPerPixel;

    this._pixelOffset = 0;
    this._subPixelOffset = 0;
}

/**
 * Adds a color to the current pixel in the buffer.
 * @param {number} count  Number of samples of the color to be added to the buffer.
 * @private
 */
SuperSampleBuffer$1.prototype._add = function SuperSampleBuffer_add(count, a, r, g, b) {
    this._samples[this._pixelOffset * 5 + IDX_COUNT] += count;

    if (a > 0) {
        this._samples[this._pixelOffset * 5 + IDX_A] += 0 | (a * count);
        this._samples[this._pixelOffset * 5 + IDX_R] += 0 | (r * count * a / 255);
        this._samples[this._pixelOffset * 5 + IDX_G] += 0 | (g * count * a / 255);
        this._samples[this._pixelOffset * 5 + IDX_B] += 0 | (b * count * a / 255);
    }
};

/**
 * Rewinds the cursor to the beginning of the buffer.
 */
SuperSampleBuffer$1.prototype.rewind = function SuperSampleBuffer_rewind() {
    this._pixelOffset = 0;
    this._subPixelOffset = 0;
};

/**
 * Clears the samples in this buffer.
 */
SuperSampleBuffer$1.prototype.clear = function SuperSampleBuffer_clear() {
    this._pixelOffset = 0;
    this._subPixelOffset = 0;

    this._samples.fill(0);
};

/**
 * Writes the average color of each pixel to a specified BitmapWriter.
 * @param {BitmapWriter} bitmapWriter  The average colors will be written to this BitmapWriter.
 * @param {number} count  Number of pixels to write.
 */
SuperSampleBuffer$1.prototype.writeTo = function SuperSampleBuffer_writeTo(bitmapWriter, count) {
    for (var i = 0; i < count; i++) {
        var sampleCount = this._samples[i * 5 + IDX_COUNT],
            alphaSum = this._samples[i * 5 + IDX_A],
            color = sampleCount && alphaSum ? 
                colorUtils$5.from(
                    Math.floor(alphaSum / sampleCount),
                    Math.floor(this._samples[i * 5 + IDX_R] * 255 / alphaSum),
                    Math.floor(this._samples[i * 5 + IDX_G] * 255 / alphaSum),
                    Math.floor(this._samples[i * 5 + IDX_B] * 255 / alphaSum)
                ) : 0;
        bitmapWriter.write(color, 1);
    }
};

/**
 * Gets the average color for the pixel at a specified index in the buffer.
 * @param {number} index  The index of the pixel whose average color will be calculated.
 * @returns {number} Average color.
 */
SuperSampleBuffer$1.prototype.getColorAt = function SuperSampleBuffer_getColorAt(index) {
    var sampleCount = this._samples[index * 5 + IDX_COUNT],
        alphaSum = this._samples[index * 5 + IDX_A];
    return sampleCount && alphaSum ? 
            colorUtils$5.from(
                Math.floor(alphaSum / sampleCount),
                Math.floor(this._samples[index * 5 + IDX_R] * 255 / alphaSum),
                Math.floor(this._samples[index * 5 + IDX_G] * 255 / alphaSum),
                Math.floor(this._samples[index * 5 + IDX_B] * 255 / alphaSum)
            ) : 0;
};

/**
 * Adds a color to the buffer up until the specified x index.
 * @param {number} color  Color to write.
 * @param {number} untilX  Samples of the color will be added the buffer until
 * the cursor reaches this coordinate.
 */
SuperSampleBuffer$1.prototype.add = function SuperSampleBuffer_add(color, untilX) {
    var samplesLeft = Math.floor(untilX * this._samplesPerPixel) - this._subPixelOffset - this._pixelOffset * this._samplesPerPixel;

    var a = colorUtils$5.alpha(color);
    var r = colorUtils$5.red(color);
    var g = colorUtils$5.green(color);
    var b = colorUtils$5.blue(color);
    
    // First partial pixel
    if (this._subPixelOffset > 0) {
        var samples = this._samplesPerPixel - this._subPixelOffset;
        if (samples > samplesLeft) {
            samples = samplesLeft;
        }
        samplesLeft -= samples;

        this._add(samples, a, r, g, b);

        this._subPixelOffset += samples;
        if (this._subPixelOffset == this._samplesPerPixel) {
            this._subPixelOffset = 0;
            this._pixelOffset++;
        }
    }

    // Full pixels
    var fullPixels = Math.floor(samplesLeft / this._samplesPerPixel);
    if (fullPixels > 0) {
        for (var i = 0; i < fullPixels; i++) {
            this._add(this._samplesPerPixel, a, r, g, b);
            this._pixelOffset++;
        }

        samplesLeft -= fullPixels * this._samplesPerPixel;
    }

    // Last partial pixel
    if (samplesLeft > 0) {
        this._add(samplesLeft, a, r, g, b);

        this._subPixelOffset += samplesLeft;

        if (this._subPixelOffset == this._samplesPerPixel) {
            this._subPixelOffset = 0;
            this._pixelOffset++;
        }
    }
};

var superSampleBuffer = SuperSampleBuffer$1;

var superSampleBuffer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), superSampleBuffer, {
    'default': superSampleBuffer
}));

var require$$2$N = /*@__PURE__*/getAugmentedNamespace(superSampleBuffer$1);

const BitmapWriter = require$$0$Q;
const LayerManager = require$$1$13;
const SuperSampleBuffer = require$$2$N;
const colorUtils$4 = require$$5$m;

/**
 * A higher number of samples per pixel horizontally does not affect the
 * performance in the same way as SAMPLES_PER_PIXEL_Y, since the rasterizer
 * does not scan every subpixel horizontally.
 */
const SAMPLES_PER_PIXEL_X = 10;

/**
 * A higher number of samples vertically means lower performance, since
 * the rasterizer does a scan for every subpixel vertically.
 */
const SAMPLES_PER_PIXEL_Y = 4;

const SAMPLE_HEIGHT = 1 / SAMPLES_PER_PIXEL_Y;


var rasterizer$1 = rasterize;


/**
 * Rasterizes the edges in the edge table to a list of color ranges. No range will span
 * multiple scanlines.
 * @param {EdgeTable} edgeTable 
 * @param {number} backColor
 */
function rasterize(edgeTable, backColor) {
    edgeTable.sort();

    var writer = new BitmapWriter(backColor, edgeTable.width, edgeTable.height);
    
    // Allocate an extra slot in the super sample buffer to calculate the 
    // color that will be forwarded until the next supersample range.
    var superSampleBuffer = new SuperSampleBuffer(edgeTable.width + 1, SAMPLES_PER_PIXEL_X);

    var layers = [];
    var color = 0;
    
    // Keeps track of how many of the subpixellayers that are used for 
    // the currently rendered scanline. Until a range requiring supersampling
    // is encountered only a single layer is needed.
    var usedLayers = 0;

    // Create a layer manager for every subpixel scanline
    for (var i = 0; i < SAMPLES_PER_PIXEL_Y; i++) {
        layers[i] = new LayerManager();
    }

    for (var ey = 0; ey < edgeTable.height; ey++) {
        var scanline = edgeTable.scanlines[ey];
        if (!scanline || !scanline.length) {
            writer.skip(edgeTable.width);
            continue;
        }
        
        for (var i = 0; i < usedLayers; i++) {
            layers[i].clear();
        }
        usedLayers = 1;

        var superSampleRanges = getSuperSampleRanges(scanline, edgeTable.width);

        writer.skip(superSampleRanges[0].fromX);

        for (var rangeIndex = 0; rangeIndex < superSampleRanges.length; rangeIndex++) {
            var superSampleRange = superSampleRanges[rangeIndex];
            
            // If there is exactly one edge in the supersample range, and it is crossing
            // the entire scanline, we can perform the antialiasing by integrating the
            // edge function.
            if (superSampleRange.edges.length == 1 && (
                superSampleRange.edges[0].y0 <= ey && superSampleRange.edges[0].y1 >= ey + 1 ||
                superSampleRange.edges[0].y0 >= ey + 1 && superSampleRange.edges[0].y1 <= ey
                )) {
                var edge = superSampleRange.edges[0];

                // Determine the lower and upper x value where the edge 
                // intersects the scanline.
                var xey = edge.intersection(ey);
                var xey1 = edge.intersection(ey + 1);
                var x0 = Math.min(xey, xey1);
                var x1 = Math.max(xey, xey1);
                var width = x1 - x0;

                // Compute the average color of all subpixel layers before
                // and after the edge intersection.
                for (var sy = 0; sy < usedLayers; sy++) {
                    var subScanlineLayers = layers[sy];
                    superSampleBuffer.add(subScanlineLayers.color, 1);
                    subScanlineLayers.add(edge);
                    superSampleBuffer.add(subScanlineLayers.color, 2);
                    superSampleBuffer.rewind();
                }

                var fromColor = superSampleBuffer.getColorAt(0);
                color = superSampleBuffer.getColorAt(1);
                
                superSampleBuffer.clear();

                // Render pixels
                for (var x = superSampleRange.fromX; x < superSampleRange.toXExcl; x++) {
                    if (x0 >= x + 1) {
                        // Pixel not covered
                        writer.write(fromColor, 1);
                        continue;
                    }

                    if (x1 <= x) {
                        // Pixel fully covered
                        writer.write(color, 1);
                        continue;
                    }
                    
                    // toColor coverage in the range [0.0, 1.0]
                    // Initialize to the fully covered range of the pixel.
                    var coverage = x1 < x + 1 ? x + 1 - x1 : 0;

                    // Compute integral for non-vertical edges
                    if (width > 0.001) {
                        // Range to integrate
                        var integralFrom = Math.max(x0, x);
                        var integralTo = Math.min(x1, x + 1);

                        coverage += 
                            (
                                (integralTo * integralTo - integralFrom * integralFrom) / 2 +
                                x0 * (integralFrom - integralTo)
                            ) / width;
                    }

                    writer.write(colorUtils$4.mix(fromColor, color, coverage), 1);
                }

            } // /simplified antialiasing
            else {
                // There are more than a single intersecting edge in this range.
                // Use super sampling to render the pixels.
                var y = ey + SAMPLE_HEIGHT / 2;
                
                // Ensure all subpixel layers are initialized
                while (usedLayers < SAMPLES_PER_PIXEL_Y) {
                    layers[0].copyTo(layers[usedLayers]);
                    usedLayers++;
                }

                // Average color of the pixels following the current supersample range.
                for (var sy = 0; sy < SAMPLES_PER_PIXEL_Y; sy++ , y += SAMPLE_HEIGHT) {
                    var subScanlineLayers = layers[sy];
                    color = subScanlineLayers.color;

                    var intersections = getIntersections(superSampleRange.edges, y);

                    for (var i = 0; i < intersections.length; i++) {
                        var intersection = intersections[i];
                        superSampleBuffer.add(color, intersection.x - superSampleRange.fromX);
                        subScanlineLayers.add(intersection.edge);
                        color = subScanlineLayers.color;
                    }

                    // Write an extra pixel that will contain the color that
                    // will be forwarded until the next supersample range.
                    superSampleBuffer.add(color, superSampleRange.width + 1);
                    superSampleBuffer.rewind();
                } // /subpixel
                
                // Get color to be forwarded
                color = superSampleBuffer.getColorAt(superSampleRange.width);

                // Blend subpixels
                superSampleBuffer.writeTo(writer, superSampleRange.width);
                superSampleBuffer.clear();
            }
            
            // Forward last color
            if (rangeIndex + 1 < superSampleRanges.length) {
                var nextRangeX = superSampleRanges[rangeIndex + 1].fromX;
                writer.write(color, nextRangeX - superSampleRange.toXExcl);
            }
            else {
                writer.write(color, edgeTable.width - superSampleRange.toXExcl);
            }
        } // /range
    }

    return writer.canvas;
}

/**
 * Determines what edges that intersect a horizontal line with the specified y coordinate.
 * For each intersecting edge the intersecting x coordinate is returned.
 * @param {Array} scanline  Array of edges in the current scanline.
 * @returns {Array} Array with objects like { x: number, edge: Edge }. Objects
 * are sorted ascending by x coordinate.
 */
function getIntersections(edges, y) {
    var intersections = [];

    for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];

        if (edge.y0 < y && edge.y1 >= y ||
            edge.y0 >= y && edge.y1 < y) {
            var x = edge.x0 +
                (edge.x1 - edge.x0) * (y - edge.y0) /
                (edge.y1 - edge.y0);

            intersections.push({
                edge: edge,
                x: x
            });
        }
    }

    intersections.sort(function (a, b) {
        return a.x - b.x;
    });

    return intersections;
}

/**
 * Determines what ranges of a scanline that needs to be supersampled.
 * @param {Array} scanline  Array of edges in the current scanline.
 * @returns {Array}  Array of ranges like { fromX: number, toXExcl: number, edges: Edge[] }
 */
function getSuperSampleRanges(scanline, width) {
    var superSampleRanges = [];

    var rangeIndex = 0;

    while (rangeIndex < scanline.length) {
        var superSampleRange = {
            fromX: scanline[rangeIndex].fromX,
            toXExcl: scanline[rangeIndex].fromX + scanline[rangeIndex].width,
            edges: [scanline[rangeIndex].edge]
        };

        if (superSampleRange.fromX >= width) {
            break;
        }

        superSampleRanges.push(superSampleRange);

        rangeIndex++;

        for (var i = rangeIndex; i < scanline.length; i++) {
            if (scanline[i].fromX < superSampleRange.toXExcl) {
                superSampleRange.toXExcl = Math.max(superSampleRange.toXExcl, scanline[i].fromX + scanline[i].width);
                superSampleRange.edges.push(scanline[i].edge);
                rangeIndex++;
            }
            else {
                break;
            }
        }

        superSampleRange.toXExcl = Math.min(superSampleRange.toXExcl, width);
        superSampleRange.width = superSampleRange.toXExcl - superSampleRange.fromX;
    }

    return superSampleRanges;
}

var rasterizer$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), rasterizer$1, {
    'default': rasterizer$1
}));

var require$$1$12 = /*@__PURE__*/getAugmentedNamespace(rasterizer$2);

const colorUtils$3 = require$$5$m;

/**
 * Creates a PNG color palette for the specified bitmap data.
 * @param {Array} colorRanges
 */
function PngPalette$1(colorRanges) {
    var lookup = {};
    var colors = [];
    var hasAlphaChannel = false;

    for (var i = 0; i + 1 < colorRanges.length && colors.length <= 256; i += 2) {
        var count = colorRanges[i + 0];
        var color = colorRanges[i + 1];

        if (!count) {
            // Empty range
            continue;
        }

        if (color in lookup) {
            // Color already processed
            continue;
        }

        if (!hasAlphaChannel && colorUtils$3.alpha(color) < 255) {
            hasAlphaChannel = true;
        }

        lookup[color] = colors.length;
        colors.push(color);
    }

    this.hasAlphaChannel = hasAlphaChannel;
    this.colors = colors;
    this.lookup = lookup;
    this.isValid = colors.length <= 256;
}

/**
 * Specifies if the palette is valid to be used for encoding a PNG image.
 */
PngPalette$1.prototype.isValid = false;

/**
 * Specifies if the palette has any partial or fully transparent
 * colors.
 */
PngPalette$1.prototype.hasAlphaChannel = false;

/**
 * Array of colors in the palette.
 */
PngPalette$1.prototype.colors = [];

/**
 * Lookup table from 32-bit color value to color index.
 */
PngPalette$1.prototype.lookup = {};

var pngPalette = PngPalette$1;

var pngPalette$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pngPalette, {
    'default': pngPalette
}));

var require$$2$M = /*@__PURE__*/getAugmentedNamespace(pngPalette$1);

var CRC_TABLE = makeCrcTable();

/**
 * Creates a new running CRC32 calculator.
 */
function Crc32$1() { }

/**
 * The current CRC32 value.
 */
Crc32$1.prototype.value = 0;

/**
 * Adds more data to the CRC32 sum.
 * @param {Buffer} buffer  Data is read from this buffer.
 * @param {number} bufferStart  Index of first byte to read.
 * @param {number} bufferEnd  Index of exclusive last byte to read.
 */
Crc32$1.prototype.update = function Crc32_update(buffer, bufferStart, bufferEnd) {
    var crc = this.value ^ 0xffffffff;

    if (typeof bufferStart !== "number") {
        bufferStart = 0;
    }

    if (typeof bufferEnd !== "number") {
        bufferEnd = buffer.length;
    }
    
    for (var i = bufferStart; i < bufferEnd; i++) {
        crc = CRC_TABLE[(crc ^ buffer[i]) & 0xff] ^ (crc >>> 8);
    }

    this.value = crc ^ 0xffffffff;
};


var crc32 = Crc32$1;


function makeCrcTable() {
    var crcTable = [];

    for (var n = 0; n < 256; n++) {
        var c = n;
        for (var k = 0; k < 8; k++) {
            if ((c & 1) == 1)
                c = 0xedb88320 ^ (c >>> 1);
            else
                c = c >>> 1;
        }
        crcTable[n] = c;
    }

    return crcTable;
}

var crc32$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), crc32, {
    'default': crc32
}));

var require$$0$P = /*@__PURE__*/getAugmentedNamespace(crc32$1);

const Crc32 = require$$0$P;

function PngBuffer$1() {
    this._buffer = Buffer$1.alloc(1024);
}

PngBuffer$1.prototype = {
    /**
     * The internal Buffer.
     * @private
     */
    _buffer: null,

    /**
     * The position of the next byte in _buffer.
     * @private
     */
    _position: 0,

    /**
     * Ensures there are enough free capacity in the buffer.
     * @param {number} bytesNeeded  The minimum free space in the buffer.
     * @private
     */
    _ensureCapacity: function _ensureCapacity(bytesNeeded) {
        var targetLength = this._position + bytesNeeded;

        if (this._buffer.length < targetLength) {
            // This approximately doubles the buffer, while ensuring that 
            // it will always be large enough for the requested length.
            var newCapacity = this._buffer.length + targetLength;

            var oldBuffer = this._buffer;
            this._buffer = Buffer$1.alloc(newCapacity);
            
            oldBuffer.copy(this._buffer);
        }
    },

    /**
     * Writes the content of a Buffer to the PngBuffer.
     * @param {Buffer} buffer  Data to write.
     * @param {number} [bufferStart]  Index of first byte to write. Defaults to 0.
     * @param {number} [bufferEnd]  Index of first byte that will not be written. Defaults to end of buffer.
     */
    writeBuffer: function writeBuffer(buffer, bufferStart, bufferEnd) {
        if (typeof bufferStart == "undefined") {
            bufferStart = 0;
        }
        if (typeof bufferEnd == "undefined") {
            bufferEnd = buffer.length;
        }

        this._ensureCapacity(bufferEnd - bufferStart);
        buffer.copy(this._buffer, this._position, bufferStart, bufferEnd);
        this._position += bufferEnd - bufferStart;
    },

    /**
     * Writes a string to the buffer.
     * @param {string} str  String to write.
     */
    writeString: function writeString(str) {
        const encodedStr = Buffer$1.from(str, "latin1");
        this.writeBuffer(encodedStr);
    },

    /**
     * Writes a 32 bit signed int to the buffer in Big Endian format.
     * @param {number} value  Value to write.
     */
    writeInt32BE: function writeInt32BE(value) {
        this._ensureCapacity(4);
        this._buffer.writeInt32BE(value, this._position);
        this._position += 4;
    },

    /**
     * Writes a 32 bit unsigned int to the buffer in Big Endian format.
     * @param {number} value  Value to write.
     */
    writeUInt32BE: function writeUInt32BE(value) {
        this._ensureCapacity(4);
        this._buffer.writeUInt32BE(value, this._position, true);
        this._position += 4;
    },

    /**
     * Writes an 8 bit signed int to the buffer.
     * @param {number} value  Value to write.
     */
    writeInt8: function writeInt8(value) {
        this._ensureCapacity(1);
        this._buffer.writeInt8(value, this._position++);
    },

    /**
     * Writes an 8 bit unsigned int to the buffer.
     * @param {number} value  Value to write.
     */
    writeUInt8: function writeUInt8(value) {
        this._ensureCapacity(1);
        this._buffer.writeUInt8(value, this._position++);
    },

    /**
     * Starts a new PNG chunk.
     * @param {string} type  Name of the chunk. Must contain exactly 4 ASCII characters.
     */
    startChunk: function startChunk(type) {
        // Save the start index of the chunk since we need it to
        // calculate the crc32 and to update the data length.
        this._chunkStart = this._position;

        // Ensure capacity for length, name and crc32.
        this._ensureCapacity(12); 

        // Length, reserve space
        this._position += 4;
        
        // Name
        this._buffer.write(type, this._position, 4, "ascii");
        this._position += 4;
    },

    /**
     * Closes the current PNG chunk.
     */
    endChunk: function endChunk() {
        // Compute Crc32 for type + data
        var crc = new Crc32();
        crc.update(this._buffer, this._chunkStart + 4, this._position);

        // Length
        var dataLength = this._position - (this._chunkStart + 8);
        this._buffer.writeInt32BE(dataLength, this._chunkStart);

        // Crc32
        this.writeInt32BE(crc.value);
    },

    /**
     * Gets a Buffer with the PNG encoded data.
     * @returns {Buffer}
     */
    getBuffer: function getBuffer() {
        return this._buffer.slice(0, this._position);
    }
};

var pngBuffer = PngBuffer$1;

var pngBuffer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pngBuffer, {
    'default': pngBuffer
}));

var require$$1$11 = /*@__PURE__*/getAugmentedNamespace(pngBuffer$1);

const zlib$4 = require$$0$_;
const PngBuffer = require$$1$11;
const colorUtils$2 = require$$5$m;

var SIGNATURE = Buffer$1.from([137, 80, 78, 71, 13, 10, 26, 10]);

function PngEncoder$1() {
    this._buffer = new PngBuffer();
    this._buffer.writeBuffer(SIGNATURE);
}

PngEncoder$1.prototype.writeImageHeader = function PngEncoder_writeImageHeader(width, height, colorType) {
    this._buffer.startChunk("IHDR");
    this._buffer.writeUInt32BE(width);
    this._buffer.writeUInt32BE(height);
    this._buffer.writeUInt8(8); // Bit depth
    this._buffer.writeUInt8(colorType);
    this._buffer.writeUInt8(0); // Compression
    this._buffer.writeUInt8(0); // Filter
    this._buffer.writeUInt8(0); // Interlace
    this._buffer.endChunk();
};

PngEncoder$1.prototype.writeImageGamma = function PngEncoder_writeImageGamma(gamma) {
    this._buffer.startChunk("gAMA");
    this._buffer.writeUInt32BE(gamma || 45455);
    this._buffer.endChunk();
};

PngEncoder$1.prototype.writeTrueColorWithAlpha = function PngEncoder_writeTrueColorWithAlpha(colorRanges, width, height) {
    this._buffer.startChunk("IDAT");

    var buffer = Buffer$1.alloc(width * height * 4 + height);
    var outputCursor = 0;
    var canvasCursor = 0;

    for (var y = 0; y < height; y++) {
        buffer.writeUInt8(0); // No filtering
        outputCursor++;

        for (var x = 0; x < width; canvasCursor++) {
            var count = colorRanges[canvasCursor * 2 + 0];

            // Use a bitwise operator to ensure the color is expressed as a signed 32-bit integer
            var color = colorRanges[canvasCursor * 2 + 1] & 0xffffffff;

            for (var i = 0; i < count; i++) {
                buffer.writeInt32BE(color, outputCursor);
                outputCursor += 4;
            }

            x += count;
        }
    }

    var compressed = zlib$4.deflateSync(buffer);
    this._buffer.writeBuffer(compressed);

    this._buffer.endChunk();
};

PngEncoder$1.prototype.writeIndexed = function PngEncoder_writeIndexed(colorRanges, palette, width, height) {
    this._buffer.startChunk("IDAT");

    var buffer = Buffer$1.alloc(width * height + height);
    var outputCursor = 0;
    var canvasCursor = 0;

    for (var y = 0; y < height; y++) {
        buffer.writeUInt8(0); // No filtering
        outputCursor++;

        for (var x = 0; x < width; canvasCursor++) {
            var count = colorRanges[canvasCursor * 2 + 0];
            var color = colorRanges[canvasCursor * 2 + 1];
            var colorIndex = palette.lookup[color];

            for (var i = 0; i < count; i++) {
                buffer.writeUInt8(colorIndex, outputCursor);
                outputCursor++;
            }

            x += count;
        }
    }

    var compressed = zlib$4.deflateSync(buffer);
    this._buffer.writeBuffer(compressed);

    this._buffer.endChunk();
};

PngEncoder$1.prototype.writePalette = function PngEncoder_writePalette(palette) {
    if (palette && palette.isValid) {
        this._buffer.startChunk("PLTE");

        for (var i = 0; i < palette.colors.length; i++) {
            this._buffer.writeUInt8(colorUtils$2.red(palette.colors[i]));
            this._buffer.writeUInt8(colorUtils$2.green(palette.colors[i]));
            this._buffer.writeUInt8(colorUtils$2.blue(palette.colors[i]));
        }

        this._buffer.endChunk();
    }
};

PngEncoder$1.prototype.writeTransparency = function PngEncoder_writeTransparency(palette) {
    if (palette && palette.isValid && palette.hasAlphaChannel) {
        this._buffer.startChunk("tRNS");

        for (var i = 0; i < palette.colors.length; i++) {
            this._buffer.writeUInt8(colorUtils$2.alpha(palette.colors[i]));
        }

        this._buffer.endChunk();
    }
};

PngEncoder$1.prototype.writeTextualData = function PngEncoder_writeTextualData(key, value) {
    this._buffer.startChunk("tEXt");
    this._buffer.writeString(key);
    this._buffer.writeUInt8(0);
    this._buffer.writeString(value);
    this._buffer.endChunk();
};

PngEncoder$1.prototype.writeImageEnd = function PngEncoder_writeImageEnd() {
    this._buffer.startChunk("IEND");
    this._buffer.endChunk();
};

PngEncoder$1.prototype.getBuffer = function PngEncoder_getBuffer() {
    return this._buffer.getBuffer();
};

PngEncoder$1.GRAYSCALE = 0;
PngEncoder$1.TRUE_COLOR = 2;
PngEncoder$1.INDEXED_COLOR = 3;
PngEncoder$1.GRAYSCALE_WITH_ALPHA = 4;
PngEncoder$1.TRUE_COLOR_WITH_ALPHA = 6;

var pngEncoder = PngEncoder$1;

var pngEncoder$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pngEncoder, {
    'default': pngEncoder
}));

var require$$3$B = /*@__PURE__*/getAugmentedNamespace(pngEncoder$1);

function Edge$1(polygonId, x0, y0, x1, y1, color, windingRule) {
    this.polygonId = polygonId;
    this.x0 = x0;
    this.x1 = x1;
    this.y0 = y0;
    this.y1 = y1;
    this.color = color;
    this.windingRule = windingRule;
}

Edge$1.prototype.intersection = function intersection(y) {
    var dx = (this.x1 - this.x0) * (this.y0 - y) / (this.y0 - this.y1);
    return this.x0 + dx;
};

var edge = Edge$1;

var edge$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), edge, {
    'default': edge
}));

var require$$0$O = /*@__PURE__*/getAugmentedNamespace(edge$1);

/**
 * Creates a new transformation matrix.
 */
function Matrix$1(a, b, c, d, e, f) {
    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
    this._e = e;
    this._f = f;
}

/**
 * Gets a value determining if this matrix has skewing values.
 * @returns {Boolean}
 */
Matrix$1.prototype.hasSkewing = function Matrix_hasSkewing() {
    return this._b || this._c;
};

/**
 * Gets a value determining if this matrix has translation values.
 * @returns {Boolean}
 */
Matrix$1.prototype.hasTranslation = function Matrix_hasTranslation() {
    return this._e || this._f;
};

/**
 * Gets a value determining if this matrix has scaling values.
 * @returns {Boolean}
 */
Matrix$1.prototype.hasScaling = function Matrix_hasScaling() {
    return this._a !== 1 || this._d !== 1;
};

/**
 * Returns a new matrix based on the current matrix multiplied with the specified matrix values.
 * @returns {Matrix}
 */
Matrix$1.prototype.multiply = function Matrix_multiply(a, b, c, d, e, f) {
    return new Matrix$1(
        this._a * a + this._c * b,
        this._b * a + this._d * b,
        this._a * c + this._c * d,
        this._b * c + this._d * d,
        this._a * e + this._c * f + this._e,
        this._b * e + this._d * f + this._f
    );
};

/**
 * Multiplies the specified point with the current matrix and returns the resulting point.
 * @param {number} x  X coordinate.
 * @param {number} y  Y coordinate.
 * @returns {{x:number, y:number}}
 */
Matrix$1.prototype.multiplyPoint = function Matrix_multiplyPoint(x, y) {
    return {
        x: this._a * x + this._c * y + this._e,
        y: this._b * x + this._d * y + this._f
    };
};

/**
 * Returns a new matrix based on the current matrix with a rotation transformation applied.
 * @param {number} angle  Rotation angle in radians.
 * @returns {Matrix}
 */
Matrix$1.prototype.rotate = function Matrix_rotate(angle) {
    var sin = Math.sin(angle),
        cos = Math.cos(angle);
    return this.multiply(cos, sin, -sin, cos, 0, 0);
};

/**
 * Returns a new matrix based on the current matrix with a translation transformation applied.
 * @param {number} x  Horizontal move distance.
 * @param {number} y  Vertical move distance.
 * @returns {Matrix}
 */
Matrix$1.prototype.translate = function Matrix_translate(x, y) {
    return this.multiply(1, 0, 0, 1, x, y);
};

/**
 * Returns a new matrix based on the current matrix with a scaling transformation applied.
 * @param {number} x  Horizontal scale.
 * @param {number} y  Vertical scale.
 * @returns {Matrix}
 */
Matrix$1.prototype.scale = function Matrix_scale(x, y) {
    return this.multiply(x, 0, 0, y, 0, 0);
};

var matrix = Matrix$1;

var matrix$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), matrix, {
    'default': matrix
}));

var require$$2$L = /*@__PURE__*/getAugmentedNamespace(matrix$1);

/**
 * Captures the current state of a specified canvas context.
 * @param {CanvasContext} ctx  Canvas context whose state will be captured.
 */
function canvasState_capture(ctx) {
    return {
        fillStyle: ctx.fillStyle,
        transform: ctx._transform
    };
}

/**
 * Restores the specified canvas state.
 * @param {CanvasContext} ctx  Canvas context whose state will be restored.
 * @param {CanvasState} state  State to restore.
 */
function canvasState_restore(ctx, state) {
    ctx.fillStyle = state.fillStyle;
    ctx._transform = state.transform;
}

var canvasState$1 = {
    capture: canvasState_capture,
    restore: canvasState_restore
};

var canvasState$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), canvasState$1, {
    'default': canvasState$1
}));

var require$$3$A = /*@__PURE__*/getAugmentedNamespace(canvasState$2);

const Edge = require$$0$O;
const colorUtils$1 = require$$5$m;
const Matrix = require$$2$L;
const canvasState = require$$3$A;

/**
 * Creates a new canvas with the specified dimensions given in pixels.
 */
function CanvasContext$1(canvas) {
    this.canvas = canvas;

    this._edges = canvas._edges;
    this.beginPath();
    
    this._savedStates = [];

    this.resetTransform();
}

/**
 * Specifies the fill color that is used when the fill method is called. Allowed values are:
 * - 32 bit integers on the format `0xRRGGBBAA`
 * - strings on the format `"#RGB"`
 * - strings on the format `"#RGBA"`
 * - strings on the format `"#RRGGBB"`
 * - strings on the format `"#RRGGBBAA"`
 * - strings on the format `"rgb(255, 255, 255)"`
 * - strings on the format `"rgb(255, 255, 255, 0.5)"`
 * - strings on the format `"rgb(255, 255, 255, 50%)"`
 * - strings on the format `"rgba(255, 255, 255, 0.5)"`
 * - strings on the format `"rgba(255, 255, 255, 50%)"`
 * - strings on the format `"hsl(134, 50%, 50%)"`
 * - strings on the format `"hsl(134, 50%, 50%, 0.5)"`
 * - strings on the format `"hsl(134, 50%, 50%, 50%)"`
 * - strings on the format `"hsla(134, 50%, 50%, 0.5)"`
 * - strings on the format `"hsla(134, 50%, 50%, 50%)"`
 * - strings on the format `"hwb(134, 50%, 50%)"`
 * - strings on the format `"hwb(134, 50%, 50%, 0.5)"`
 * - strings on the format `"hwb(134, 50%, 50%, 50%)"`
 * @type {string|number}
 */
CanvasContext$1.prototype.fillStyle = 0x000000ff;

/**
 * Saves the current drawing state to a stack. The state can later be restored by calling `CanvasContext.restore()`.
 * 
 * The following state is included when being saved to the stack:
 * - Current transformation matrix
 * - Current fill style
 */
CanvasContext$1.prototype.save = function CanvasContext_save() {
    this._savedStates.push(canvasState.capture(this));
};

/**
 * Restores the last drawing state that was saved with `CanvasContext.save()`, and then removes it from the state stack.
 */
CanvasContext$1.prototype.restore = function CanvasContext_restore() {
    if (this._savedStates.length) {
        canvasState.restore(this, this._savedStates.pop());
    }
};

/**
 * Restores the current transformation to the identity matrix.
 */
CanvasContext$1.prototype.resetTransform = function CanvasContext_resetTransform() {
    this._transform = new Matrix(1, 0, 0, 1, 0, 0);
};

/**
 * Multiplies the current transformation matrix with the specified values.
 */
CanvasContext$1.prototype.transform = function CanvasContext_transform(a, b, c, d, e, f) {
    if (!Number.isFinite(a) ||
        !Number.isFinite(b) ||
        !Number.isFinite(c) ||
        !Number.isFinite(d) ||
        !Number.isFinite(e) ||
        !Number.isFinite(f)) {
        return;
    }

    this._transform = this._transform.multiply(a, b, c, d, e, f);
};

/**
 * Sets the transformation matrix to the specified matrix.
 */
CanvasContext$1.prototype.setTransform = function CanvasContext_transform(a, b, c, d, e, f) {
    if (!Number.isFinite(a) ||
        !Number.isFinite(b) ||
        !Number.isFinite(c) ||
        !Number.isFinite(d) ||
        !Number.isFinite(e) ||
        !Number.isFinite(f)) {
        return;
    }

    this._transform = new Matrix(a, b, c, d, e, f);
};

/**
 * Applies a translation transformation on top of the current transform.
 * @param {number} x  Distance to move in the horizontal direction in pixels.
 * @param {number} y  Distance to move in the vertical direction in pixels.
 */
CanvasContext$1.prototype.translate = function CanvasContext_translate(x, y) {
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
        return;
    }

    this._transform = this._transform.translate(x, y);
};

/**
 * Applies a scale transformation on top of the current transform.
 * @param {number} x  Scale in the horizontal direction. `1` means no horizontal scaling.
 * @param {number} y  Scale in the vertical direction. `1` means no vertical scaling.
 */
CanvasContext$1.prototype.scale = function CanvasContext_scale(x, y) {
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
        return;
    }

    this._transform = this._transform.scale(x, y);
};

/**
 * Applies a rotation transformation on top of the current transform around the current canvas origo.
 * @param {number} angle  Angle in radians measured clockwise from the positive x axis.
 */
CanvasContext$1.prototype.rotate = function CanvasContext_rotate(angle) {
    if (!Number.isFinite(angle)) {
        return;
    }

    this._transform = this._transform.rotate(angle);
};

/**
 * Removes all existing subpaths and begins a new path.
 */
CanvasContext$1.prototype.beginPath = function CanvasContext_beginPath() {
    this._paths = [];
};

/**
 * Starts a new subpath that begins in the same point as the start and end point of the previous one.
 */
CanvasContext$1.prototype.closePath = function CanvasContext_closePath() {
    if (this._paths.length) {
        var path = this._paths[this._paths.length - 1];
        if (path.length > 2) {
            // Close path
            if (path[0] != path[path.length - 2] ||
                path[1] != path[path.length - 1]) {
                path.push(path[0]);
                path.push(path[1]);
            }

            // Begin a new path
            this._paths.push([path[0], path[1]]);
        }
    }
};

/**
 * Begins a new subpath by moving the cursor to the specified position.
 * @param {number} x  X coordinate.
 * @param {number} y  Y coordinate.
 */
CanvasContext$1.prototype.moveTo = function CanvasContext_moveTo(x, y) {
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
        return;
    }

    var p = this._transform.multiplyPoint(x, y);
    this._paths.push([p.x, p.y]);
};

/**
 * Inserts an edge between the last and specified position.
 * @param {number} x  Target X coordinate.
 * @param {number} y  Target Y coordinate.
 */
CanvasContext$1.prototype.lineTo = function CanvasContext_lineTo(x, y) {
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
        return;
    }

    if (!this._paths.length) {
        this._paths.push([]);
    }

    var p = this._transform.multiplyPoint(x, y);
    var path = this._paths[this._paths.length - 1];
    path.push(p.x);
    path.push(p.y);
};

/**
 * Adds an arc to the current path.
 * @param {number} x  X coordinate of the center of the arc.
 * @param {number} y  Y coordinate of the center of the arc.
 * @param {number} radius  Radius of the arc.
 * @param {number} startAngle  The angle in radians at which the arc starts, measured clockwise from the positive x axis.
 * @param {number} endAngle  The angle in radians at which the arc end, measured clockwise from the positive x axis.
 * @param {boolean} [anticlockwise]  Specifies whether the arc will be drawn counter clockwise. Default is clockwise.
 */
CanvasContext$1.prototype.arc = function CanvasContext_arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    if (!Number.isFinite(x) || !Number.isFinite(y) ||
        !Number.isFinite(radius) ||
        !Number.isFinite(startAngle) || !Number.isFinite(endAngle)) {
        return;
    }

    const TARGET_CHORD_LENGTH_PIXELS = 3;
    
    var sectors = Math.floor((Math.PI * radius * 2) / TARGET_CHORD_LENGTH_PIXELS);
    if (sectors < 9) {
        sectors = 9;
    }
    
    var sectorAngle = Math.PI * 2 / sectors;

    if (startAngle === endAngle) {
        return;
    }

    if (anticlockwise) {
        sectorAngle = -sectorAngle;

        if (startAngle - endAngle >= Math.PI * 2) {
            endAngle = startAngle - Math.PI * 2;
        }
        else {
            // Normalize end angle so that the sweep angle is in the range (0, -2PI]
            endAngle += Math.PI * 2 * Math.ceil((startAngle - endAngle) / (Math.PI * 2) - 1);
        }
    }
    else {
        if (endAngle - startAngle >= Math.PI * 2) {
            endAngle = startAngle + Math.PI * 2;
        }
        else {
            // Normalize end angle so that the sweep angle is in the range (0, 2PI]
            endAngle -= Math.PI * 2 * Math.ceil((endAngle - startAngle) / (Math.PI * 2) - 1);
        }
    }
    
    var dx, dy;
    sectors = (endAngle - startAngle) / sectorAngle;

    var angle = startAngle;
    
    for (var i = 0; i < sectors; i++) {
        dx = Math.cos(angle) * radius;
        dy = Math.sin(angle) * radius;
        this.lineTo(x + dx, y + dy);
        angle += sectorAngle;
    }

    dx = Math.cos(endAngle) * radius;
    dy = Math.sin(endAngle) * radius;
    this.lineTo(x + dx, y + dy);
};

/**
 * Fills a specified rectangle with fully transparent black without blending with the background or affecting the current paths.
 * @param {number} x  X coordinate of the left side of the rectangle.
 * @param {number} y  Y coordinate of the top of the rectangle.
 * @param {number} width  Width of the rectangle.
 * @param {number} height  Height of the rectangle.
 */
CanvasContext$1.prototype.clearRect = function CanvasContext_clearRect(x, y, width, height) {
    var fullCanvas = false;

    if (!this._transform.hasSkewing()) {
        // Check if the whole canvas is cleared
        var topLeft = this._transform.multiplyPoint(x, y);
        if (topLeft.x <= 0 && topLeft.y <= 0) {
            var bottomRight = this._transform.multiplyPoint(x + width, y + height);
            if (bottomRight.x >= this.canvas.width &&
                bottomRight.y >= this.canvas.height
            ) {
                fullCanvas = true;
            }
        }
    }

    if (fullCanvas) {
        this._edges.clear();
    }
    else {
        this._fillRect(colorUtils$1.FORCE_TRANSPARENT, x, y, width, height);
    }
};

/**
 * Fills a specified rectangle without affecting the current paths.
 * @param {number} x  X coordinate of the left side of the rectangle.
 * @param {number} y  Y coordinate of the top of the rectangle.
 * @param {number} width  Width of the rectangle.
 * @param {number} height  Height of the rectangle.
 */
CanvasContext$1.prototype.fillRect = function CanvasContext_fillRect(x, y, width, height) {
    var fillColor = colorUtils$1.parse(this.fillStyle);
    this._fillRect(fillColor, x, y, width, height);
};

CanvasContext$1.prototype._fillRect = function CanvasContext__fillRect(fillColor, x, y, width, height) {
    if (!Number.isFinite(x) || !Number.isFinite(y) ||
        !Number.isFinite(width) || !Number.isFinite(height) ||
        !width || !height) {
        return;
    }

    var id = this._edges.nextId++;
    
    var points = [
        this._transform.multiplyPoint(x, y),
        this._transform.multiplyPoint(x + width, y),
        this._transform.multiplyPoint(x + width, y + height),
        this._transform.multiplyPoint(x, y + height),
        this._transform.multiplyPoint(x, y)
    ];

    for (var i = 1; i < points.length; i++) {
        this._edges.add(new Edge(
            id,
            points[i - 1].x,
            points[i - 1].y,
            points[i].x,
            points[i].y,
            fillColor));
    }
};

/**
 * Fills the defined paths.
 * @param {string} [windingRule]  The winding rule to be used for determining
 *     which areas are covered by the current path. Valid values are "evenodd" and
 *     "nonzero". Default is `"nonzero"`.
 */
CanvasContext$1.prototype.fill = function CanvasContext_fill(windingRule) {
    var id = this._edges.nextId++;
    var fillColor = colorUtils$1.parse(this.fillStyle);
    
    for (var p = 0; p < this._paths.length; p++) {
        var points = this._paths[p];

        if (points.length <= 2) {
            // Nothing to fill
            continue;
        }

        for (var i = 2; i < points.length; i += 2) {
            this._edges.add(new Edge(
                id,
                points[i - 2],
                points[i - 1],
                points[i],
                points[i + 1],
                fillColor,
                windingRule));
        }
        
        // Close path
        if (points[0] != points[points.length - 2] ||
            points[1] != points[points.length - 1]) {
            this._edges.add(new Edge(
                id,
                points[points.length - 2],
                points[points.length - 1],
                points[0],
                points[1],
                fillColor,
                windingRule));
        }
    }
};

var canvasContext = CanvasContext$1;

var canvasContext$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), canvasContext, {
    'default': canvasContext
}));

var require$$4$p = /*@__PURE__*/getAugmentedNamespace(canvasContext$1);

const EdgeTable = require$$0$R;
const rasterizer = require$$1$12;
const PngPalette = require$$2$M;
const PngEncoder = require$$3$B;
const CanvasContext = require$$4$p;
const colorUtils = require$$5$m;

/**
 * Creates a new canvas with the specified dimensions given in pixels.
 * @param {number} width  Canvas width in pixels.
 * @param {number} height  Canvas height in pixels.
 * @constructor
 */
function Canvas$1(width, height) {
    this.width = width;
    this.height = height;
    this._edges = new EdgeTable(width, height);
}

/**
 * The width of the canvas in pixels.
 * @type {number}
 */
Canvas$1.prototype.width = 0;

/**
 * The height of the canvas in pixels.
 * @type {number}
 */
Canvas$1.prototype.height = 0;

/**
 * Specifies the background color. Default is fully transparent. Allowed values are:
 * - 32 bit integers on the format `0xRRGGBBAA`
 * - strings on the format `"#RGB"`
 * - strings on the format `"#RGBA"`
 * - strings on the format `"#RRGGBB"`
 * - strings on the format `"#RRGGBBAA"`
 * - strings on the format `"rgb(255, 255, 255)"`
 * - strings on the format `"rgb(255, 255, 255, 0.5)"`
 * - strings on the format `"rgb(255, 255, 255, 50%)"`
 * - strings on the format `"rgba(255, 255, 255, 0.5)"`
 * - strings on the format `"rgba(255, 255, 255, 50%)"`
 * - strings on the format `"hsl(134, 50%, 50%)"`
 * - strings on the format `"hsl(134, 50%, 50%, 0.5)"`
 * - strings on the format `"hsl(134, 50%, 50%, 50%)"`
 * - strings on the format `"hsla(134, 50%, 50%, 0.5)"`
 * - strings on the format `"hsla(134, 50%, 50%, 50%)"`
 * - strings on the format `"hwb(134, 50%, 50%)"`
 * - strings on the format `"hwb(134, 50%, 50%, 0.5)"`
 * - strings on the format `"hwb(134, 50%, 50%, 50%)"`
 * @type {string|number}
 */
Canvas$1.prototype.backColor = 0x00000000;

/**
 * Gets a context used to draw polygons on this canvas.
 * @returns {CanvasContext}
 */
Canvas$1.prototype.getContext = function Canvas_getContext() {
    return new CanvasContext(this);
};

/**
 * Renders the canvas as a PNG data stream.
 * @param {Object} [keywords]  Keywords to be written to the PNG stream. See https://www.w3.org/TR/PNG/#11keywords.
 * @returns {Buffer}
 */
Canvas$1.prototype.toPng = function Canvas_toPng(keywords) {
    var backColor = colorUtils.parse(this.backColor);
    var colorRanges = rasterizer(this._edges, backColor);

    var palette = new PngPalette(colorRanges);
    var png = new PngEncoder();

    png.writeImageHeader(this.width, this.height, palette.isValid ?
        PngEncoder.INDEXED_COLOR : PngEncoder.TRUE_COLOR_WITH_ALPHA);

    png.writeImageGamma();
    
    if (keywords) {
        for (var key in keywords) {
            if (keywords.hasOwnProperty(key)) {
                png.writeTextualData(key, keywords[key]);
            }
        }
    }

    if (palette && palette.isValid) {
        png.writePalette(palette);
        png.writeTransparency(palette);
        png.writeIndexed(colorRanges, palette, this.width, this.height);
    }
    else {
        png.writeTrueColorWithAlpha(colorRanges, this.width, this.height);
    }

    png.writeImageEnd();

    return png.getBuffer();
};

/**
 * Renders the canvas as a data URI. Only type `"image/png"` is supported.
 * @returns {string}
 */
Canvas$1.prototype.toDataURL = function Canvas_toDataURL() {
    if (this.width <= 0 || this.height <= 0) {
        return "data:,";
    }
    
    var png = this.toPng();
    return "data:image/png;base64," + png.toString("base64");
};

var canvas$2 = Canvas$1;

var canvas$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), canvas$2, {
    'default': canvas$2
}));

var require$$0$N = /*@__PURE__*/getAugmentedNamespace(canvas$3);

/**
 * canvas-renderer
 * https://github.com/dmester/canvas-renderer
 * 
 * Copyright (c) 2017-2018 Daniel Mester Pirttijärvi
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the 
 * "Software"), to deal in the Software without restriction, including 
 * without limitation the rights to use, copy, modify, merge, publish, 
 * distribute, sublicense, and/or sell copies of the Software, and to 
 * permit persons to whom the Software is furnished to do so, subject to 
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

const Canvas = require$$0$N;

var canvasRenderer$1 = {
    /**
     * Creates a new canvas.
     * @param {number} width  Width of the canvas in pixels.
     * @param {number} heigth  Height of the canvas in pixels.
     * @returns {Canvas}
     */
    createCanvas: function (width, height) {
        return new Canvas(width, height);
    }
};

var canvasRenderer$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), canvasRenderer$1, {
    'default': canvasRenderer$1
}));

var require$$0$M = /*@__PURE__*/getAugmentedNamespace(canvasRenderer$2);

var canvasRenderer = require$$0$M;

function _interopDefaultLegacy$1 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var canvasRenderer__default = /*#__PURE__*/_interopDefaultLegacy$1(canvasRenderer);

/**
 * Parses a substring of the hash as a number.
 * @param {number} startPosition 
 * @param {number=} octets
 */
function parseHex(hash, startPosition, octets) {
    return parseInt(hash.substr(startPosition, octets), 16);
}

function decToHex(v) {
    v |= 0; // Ensure integer value
    return v < 0 ? "00" :
        v < 16 ? "0" + v.toString(16) :
        v < 256 ? v.toString(16) :
        "ff";
}

function hueToRgb(m1, m2, h) {
    h = h < 0 ? h + 6 : h > 6 ? h - 6 : h;
    return decToHex(255 * (
        h < 1 ? m1 + (m2 - m1) * h :
        h < 3 ? m2 :
        h < 4 ? m1 + (m2 - m1) * (4 - h) :
        m1));
}

/**
 * @param {string} color  Color value to parse. Currently hexadecimal strings on the format #rgb[a] and #rrggbb[aa] are supported.
 * @returns {string}
 */
function parseColor(color) {
    if (/^#[0-9a-f]{3,8}$/i.test(color)) {
        let result;
        const colorLength = color.length;

        if (colorLength < 6) {
            const r = color[1],
                  g = color[2],
                  b = color[3],
                  a = color[4] || "";
            result = "#" + r + r + g + g + b + b + a + a;
        }
        if (colorLength == 7 || colorLength > 8) {
            result = color;
        }
        
        return result;
    }
}

/**
 * Converts a hexadecimal color to a CSS3 compatible color.
 * @param {string} hexColor  Color on the format "#RRGGBB" or "#RRGGBBAA"
 * @returns {string}
 */
function toCss3Color(hexColor) {
    const a = parseHex(hexColor, 7, 2);
    let result;

    if (isNaN(a)) {
        result = hexColor;
    } else {
        const r = parseHex(hexColor, 1, 2),
            g = parseHex(hexColor, 3, 2),
            b = parseHex(hexColor, 5, 2);
        result = "rgba(" + r + "," + g + "," + b + "," + (a / 255).toFixed(2) + ")";
    }

    return result;
}

/**
 * Converts an HSL color to a hexadecimal RGB color.
 * @param {number} hue  Hue in range [0, 1]
 * @param {number} saturation  Saturation in range [0, 1]
 * @param {number} lightness  Lightness in range [0, 1]
 * @returns {string}
 */
function hsl(hue, saturation, lightness) {
    // Based on http://www.w3.org/TR/2011/REC-css3-color-20110607/#hsl-color
    let result;

    if (saturation == 0) {
        const partialHex = decToHex(lightness * 255);
        result = partialHex + partialHex + partialHex;
    }
    else {
        const m2 = lightness <= 0.5 ? lightness * (saturation + 1) : lightness + saturation - lightness * saturation,
              m1 = lightness * 2 - m2;
        result =
            hueToRgb(m1, m2, hue * 6 + 2) +
            hueToRgb(m1, m2, hue * 6) +
            hueToRgb(m1, m2, hue * 6 - 2);
    }

    return "#" + result;
}

/**
 * Converts an HSL color to a hexadecimal RGB color. This function will correct the lightness for the "dark" hues
 * @param {number} hue  Hue in range [0, 1]
 * @param {number} saturation  Saturation in range [0, 1]
 * @param {number} lightness  Lightness in range [0, 1]
 * @returns {string}
 */
function correctedHsl(hue, saturation, lightness) {
    // The corrector specifies the perceived middle lightness for each hue
    const correctors = [ 0.55, 0.5, 0.5, 0.46, 0.6, 0.55, 0.55 ],
          corrector = correctors[(hue * 6 + 0.5) | 0];
    
    // Adjust the input lightness relative to the corrector
    lightness = lightness < 0.5 ? lightness * corrector * 2 : corrector + (lightness - 0.5) * (1 - corrector) * 2;
    
    return hsl(hue, saturation, lightness);
}

// In the future we can replace `GLOBAL` with `globalThis`, but for now use the old school global detection for
// backward compatibility.

const GLOBAL = 
    typeof window !== "undefined" ? window :
    typeof self !== "undefined" ? self :
    typeof commonjsGlobal !== "undefined" ? commonjsGlobal :
    {};

/**
 * @typedef {Object} ParsedConfiguration
 * @property {number} colorSaturation
 * @property {number} grayscaleSaturation
 * @property {string} backColor
 * @property {number} iconPadding
 * @property {function(number):number} hue
 * @property {function(number):number} colorLightness
 * @property {function(number):number} grayscaleLightness
 */

const CONFIG_PROPERTIES = {
    GLOBAL: "jdenticon_config",
    MODULE: "config",
};

var rootConfigurationHolder = {};

/**
 * Defines the deprecated `config` property on the root Jdenticon object. When the property is set a warning is 
 * printed in the console. To minimize bundle size, this is only used in Node bundles.
 * @param {!Object} rootObject 
 */
function defineConfigPropertyWithWarn(rootObject) {
    Object.defineProperty(rootObject, CONFIG_PROPERTIES.MODULE, {
        configurable: true,
        get: () => rootConfigurationHolder[CONFIG_PROPERTIES.MODULE],
        set: newConfiguration => {
            rootConfigurationHolder[CONFIG_PROPERTIES.MODULE] = newConfiguration;
            console.warn("jdenticon.config is deprecated. Use jdenticon.configure() instead.");
        },
    });
}

/**
 * Sets a new icon style configuration. The new configuration is not merged with the previous one. * 
 * @param {Object} newConfiguration - New configuration object.
 */
function configure(newConfiguration) {
    if (arguments.length) {
        rootConfigurationHolder[CONFIG_PROPERTIES.MODULE] = newConfiguration;
    }
    return rootConfigurationHolder[CONFIG_PROPERTIES.MODULE];
}

/**
 * Gets the normalized current Jdenticon color configuration. Missing fields have default values.
 * @param {Object|number|undefined} paddingOrLocalConfig - Configuration passed to the called API method. A
 *    local configuration overrides the global configuration in it entirety. This parameter can for backward
 *    compatibility also contain a padding value. A padding value only overrides the global padding, not the
 *    entire global configuration.
 * @param {number} defaultPadding - Padding used if no padding is specified in neither the configuration nor
 *    explicitly to the API method.
 * @returns {ParsedConfiguration}
 */
function getConfiguration(paddingOrLocalConfig, defaultPadding) {
    const configObject = 
            typeof paddingOrLocalConfig == "object" && paddingOrLocalConfig ||
            rootConfigurationHolder[CONFIG_PROPERTIES.MODULE] ||
            GLOBAL[CONFIG_PROPERTIES.GLOBAL] ||
            { },

        lightnessConfig = configObject["lightness"] || { },
        
        // In versions < 2.1.0 there was no grayscale saturation -
        // saturation was the color saturation.
        saturation = configObject["saturation"] || { },
        colorSaturation = "color" in saturation ? saturation["color"] : saturation,
        grayscaleSaturation = saturation["grayscale"],

        backColor = configObject["backColor"],
        padding = configObject["padding"];
    
    /**
     * Creates a lightness range.
     */
    function lightness(configName, defaultRange) {
        let range = lightnessConfig[configName];
        
        // Check if the lightness range is an array-like object. This way we ensure the
        // array contain two values at the same time.
        if (!(range && range.length > 1)) {
            range = defaultRange;
        }

        /**
         * Gets a lightness relative the specified value in the specified lightness range.
         */
        return function (value) {
            value = range[0] + value * (range[1] - range[0]);
            return value < 0 ? 0 : value > 1 ? 1 : value;
        };
    }

    /**
     * Gets a hue allowed by the configured hue restriction,
     * provided the originally computed hue.
     */
    function hueFunction(originalHue) {
        const hueConfig = configObject["hues"];
        let hue;
        
        // Check if 'hues' is an array-like object. This way we also ensure that
        // the array is not empty, which would mean no hue restriction.
        if (hueConfig && hueConfig.length > 0) {
            // originalHue is in the range [0, 1]
            // Multiply with 0.999 to change the range to [0, 1) and then truncate the index.
            hue = hueConfig[0 | (0.999 * originalHue * hueConfig.length)];
        }

        return typeof hue == "number" ?
            
            // A hue was specified. We need to convert the hue from
            // degrees on any turn - e.g. 746° is a perfectly valid hue -
            // to turns in the range [0, 1).
            ((((hue / 360) % 1) + 1) % 1) :

            // No hue configured => use original hue
            originalHue;
    }
        
    return {
        hue: hueFunction,
        colorSaturation: typeof colorSaturation == "number" ? colorSaturation : 0.5,
        grayscaleSaturation: typeof grayscaleSaturation == "number" ? grayscaleSaturation : 0,
        colorLightness: lightness("color", [0.4, 0.8]),
        grayscaleLightness: lightness("grayscale", [0.3, 0.9]),
        backColor: parseColor(backColor),
        iconPadding: 
            typeof paddingOrLocalConfig == "number" ? paddingOrLocalConfig : 
            typeof padding == "number" ? padding : 
            defaultPadding
    }
}

/**
 * Represents a point.
 */
class Point {
    /**
     * @param {number} x 
     * @param {number} y 
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

/**
 * Translates and rotates a point before being passed on to the canvas context. This was previously done by the canvas context itself, 
 * but this caused a rendering issue in Chrome on sizes > 256 where the rotation transformation of inverted paths was not done properly.
 */
class Transform {
    /**
     * @param {number} x The x-coordinate of the upper left corner of the transformed rectangle.
     * @param {number} y The y-coordinate of the upper left corner of the transformed rectangle.
     * @param {number} size The size of the transformed rectangle.
     * @param {number} rotation Rotation specified as 0 = 0 rad, 1 = 0.5π rad, 2 = π rad, 3 = 1.5π rad
     */
    constructor(x, y, size, rotation) {
        this._x = x;
        this._y = y;
        this._size = size;
        this._rotation = rotation;
    }

    /**
     * Transforms the specified point based on the translation and rotation specification for this Transform.
     * @param {number} x x-coordinate
     * @param {number} y y-coordinate
     * @param {number=} w The width of the transformed rectangle. If greater than 0, this will ensure the returned point is of the upper left corner of the transformed rectangle.
     * @param {number=} h The height of the transformed rectangle. If greater than 0, this will ensure the returned point is of the upper left corner of the transformed rectangle.
     */
    transformIconPoint(x, y, w, h) {
        const right = this._x + this._size,
              bottom = this._y + this._size,
              rotation = this._rotation;
        return rotation === 1 ? new Point(right - y - (h || 0), this._y + x) :
               rotation === 2 ? new Point(right - x - (w || 0), bottom - y - (h || 0)) :
               rotation === 3 ? new Point(this._x + y, bottom - x - (w || 0)) :
               new Point(this._x + x, this._y + y);
    }
}

const NO_TRANSFORM = new Transform(0, 0, 0, 0);



/**
 * Provides helper functions for rendering common basic shapes.
 */
class Graphics {
    /**
     * @param {Renderer} renderer 
     */
    constructor(renderer) {
        /**
         * @type {Renderer}
         * @private
         */
        this._renderer = renderer;

        /**
         * @type {Transform}
         */
        this.currentTransform = NO_TRANSFORM;
    }

    /**
     * Adds a polygon to the underlying renderer.
     * @param {Array<number>} points The points of the polygon clockwise on the format [ x0, y0, x1, y1, ..., xn, yn ]
     * @param {boolean=} invert Specifies if the polygon will be inverted.
     */
    addPolygon(points, invert) {
        const di = invert ? -2 : 2,
              transformedPoints = [];
        
        for (let i = invert ? points.length - 2 : 0; i < points.length && i >= 0; i += di) {
            transformedPoints.push(this.currentTransform.transformIconPoint(points[i], points[i + 1]));
        }
        
        this._renderer.addPolygon(transformedPoints);
    }
    
    /**
     * Adds a polygon to the underlying renderer.
     * Source: http://stackoverflow.com/a/2173084
     * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the entire ellipse.
     * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the entire ellipse.
     * @param {number} size The size of the ellipse.
     * @param {boolean=} invert Specifies if the ellipse will be inverted.
     */
    addCircle(x, y, size, invert) {
        const p = this.currentTransform.transformIconPoint(x, y, size, size);
        this._renderer.addCircle(p, size, invert);
    }

    /**
     * Adds a rectangle to the underlying renderer.
     * @param {number} x The x-coordinate of the upper left corner of the rectangle.
     * @param {number} y The y-coordinate of the upper left corner of the rectangle.
     * @param {number} w The width of the rectangle.
     * @param {number} h The height of the rectangle.
     * @param {boolean=} invert Specifies if the rectangle will be inverted.
     */
    addRectangle(x, y, w, h, invert) {
        this.addPolygon([
            x, y, 
            x + w, y,
            x + w, y + h,
            x, y + h
        ], invert);
    }

    /**
     * Adds a right triangle to the underlying renderer.
     * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the triangle.
     * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the triangle.
     * @param {number} w The width of the triangle.
     * @param {number} h The height of the triangle.
     * @param {number} r The rotation of the triangle (clockwise). 0 = right corner of the triangle in the lower left corner of the bounding rectangle.
     * @param {boolean=} invert Specifies if the triangle will be inverted.
     */
    addTriangle(x, y, w, h, r, invert) {
        const points = [
            x + w, y, 
            x + w, y + h, 
            x, y + h,
            x, y
        ];
        points.splice(((r || 0) % 4) * 2, 2);
        this.addPolygon(points, invert);
    }

    /**
     * Adds a rhombus to the underlying renderer.
     * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the rhombus.
     * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the rhombus.
     * @param {number} w The width of the rhombus.
     * @param {number} h The height of the rhombus.
     * @param {boolean=} invert Specifies if the rhombus will be inverted.
     */
    addRhombus(x, y, w, h, invert) {
        this.addPolygon([
            x + w / 2, y,
            x + w, y + h / 2,
            x + w / 2, y + h,
            x, y + h / 2
        ], invert);
    }
}

/**
 * @param {number} index
 * @param {Graphics} g
 * @param {number} cell
 * @param {number} positionIndex
 */
function centerShape(index, g, cell, positionIndex) {
    index = index % 14;

    let k, m, w, h, inner, outer;

    !index ? (
        k = cell * 0.42,
        g.addPolygon([
            0, 0,
            cell, 0,
            cell, cell - k * 2,
            cell - k, cell,
            0, cell
        ])) :

    index == 1 ? (
        w = 0 | (cell * 0.5), 
        h = 0 | (cell * 0.8),

        g.addTriangle(cell - w, 0, w, h, 2)) :

    index == 2 ? (
        w = 0 | (cell / 3),
        g.addRectangle(w, w, cell - w, cell - w)) :

    index == 3 ? (
        inner = cell * 0.1,
        // Use fixed outer border widths in small icons to ensure the border is drawn
        outer = 
            cell < 6 ? 1 :
            cell < 8 ? 2 :
            (0 | (cell * 0.25)),
        
        inner = 
            inner > 1 ? (0 | inner) : // large icon => truncate decimals
            inner > 0.5 ? 1 :         // medium size icon => fixed width
            inner,                    // small icon => anti-aliased border

        g.addRectangle(outer, outer, cell - inner - outer, cell - inner - outer)) :

    index == 4 ? (
        m = 0 | (cell * 0.15),
        w = 0 | (cell * 0.5),
        g.addCircle(cell - w - m, cell - w - m, w)) :

    index == 5 ? (
        inner = cell * 0.1,
        outer = inner * 4,

        // Align edge to nearest pixel in large icons
        outer > 3 && (outer = 0 | outer),
        
        g.addRectangle(0, 0, cell, cell),
        g.addPolygon([
            outer, outer,
            cell - inner, outer,
            outer + (cell - outer - inner) / 2, cell - inner
        ], true)) :

    index == 6 ? 
        g.addPolygon([
            0, 0,
            cell, 0,
            cell, cell * 0.7,
            cell * 0.4, cell * 0.4,
            cell * 0.7, cell,
            0, cell
        ]) :

    index == 7 ? 
        g.addTriangle(cell / 2, cell / 2, cell / 2, cell / 2, 3) :

    index == 8 ? (
        g.addRectangle(0, 0, cell, cell / 2),
        g.addRectangle(0, cell / 2, cell / 2, cell / 2),
        g.addTriangle(cell / 2, cell / 2, cell / 2, cell / 2, 1)) :

    index == 9 ? (
        inner = cell * 0.14,
        // Use fixed outer border widths in small icons to ensure the border is drawn
        outer = 
            cell < 4 ? 1 :
            cell < 6 ? 2 :
            (0 | (cell * 0.35)),

        inner = 
            cell < 8 ? inner : // small icon => anti-aliased border
            (0 | inner),       // large icon => truncate decimals

        g.addRectangle(0, 0, cell, cell),
        g.addRectangle(outer, outer, cell - outer - inner, cell - outer - inner, true)) :

    index == 10 ? (
        inner = cell * 0.12,
        outer = inner * 3,

        g.addRectangle(0, 0, cell, cell),
        g.addCircle(outer, outer, cell - inner - outer, true)) :

    index == 11 ? 
        g.addTriangle(cell / 2, cell / 2, cell / 2, cell / 2, 3) :

    index == 12 ? (
        m = cell * 0.25,
        g.addRectangle(0, 0, cell, cell),
        g.addRhombus(m, m, cell - m, cell - m, true)) :

    // 13
    (
        !positionIndex && (
            m = cell * 0.4, w = cell * 1.2,
            g.addCircle(m, m, w)
        )
    );
}

/**
 * @param {number} index
 * @param {Graphics} g
 * @param {number} cell
 */
function outerShape(index, g, cell) {
    index = index % 4;

    let m;

    !index ?
        g.addTriangle(0, 0, cell, cell, 0) :
        
    index == 1 ?
        g.addTriangle(0, cell / 2, cell, cell / 2, 0) :

    index == 2 ?
        g.addRhombus(0, 0, cell, cell) :

    // 3
    (
        m = cell / 6,
        g.addCircle(m, m, cell - 2 * m)
    );
}

/**
 * Gets a set of identicon color candidates for a specified hue and config.
 * @param {number} hue
 * @param {ParsedConfiguration} config
 */
function colorTheme(hue, config) {
    hue = config.hue(hue);
    return [
        // Dark gray
        correctedHsl(hue, config.grayscaleSaturation, config.grayscaleLightness(0)),
        // Mid color
        correctedHsl(hue, config.colorSaturation, config.colorLightness(0.5)),
        // Light gray
        correctedHsl(hue, config.grayscaleSaturation, config.grayscaleLightness(1)),
        // Light color
        correctedHsl(hue, config.colorSaturation, config.colorLightness(1)),
        // Dark color
        correctedHsl(hue, config.colorSaturation, config.colorLightness(0))
    ];
}

/**
 * Draws an identicon to a specified renderer.
 * @param {Renderer} renderer
 * @param {string} hash
 * @param {Object|number=} config
 */
function iconGenerator(renderer, hash, config) {
    const parsedConfig = getConfiguration(config, 0.08);

    // Set background color
    if (parsedConfig.backColor) {
        renderer.setBackground(parsedConfig.backColor);
    }
    
    // Calculate padding and round to nearest integer
    let size = renderer.iconSize;
    const padding = (0.5 + size * parsedConfig.iconPadding) | 0;
    size -= padding * 2;
    
    const graphics = new Graphics(renderer);
    
    // Calculate cell size and ensure it is an integer
    const cell = 0 | (size / 4);
    
    // Since the cell size is integer based, the actual icon will be slightly smaller than specified => center icon
    const x = 0 | (padding + size / 2 - cell * 2);
    const y = 0 | (padding + size / 2 - cell * 2);

    function renderShape(colorIndex, shapes, index, rotationIndex, positions) {
        const shapeIndex = parseHex(hash, index, 1);
        let r = rotationIndex ? parseHex(hash, rotationIndex, 1) : 0;
        
        renderer.beginShape(availableColors[selectedColorIndexes[colorIndex]]);
        
        for (let i = 0; i < positions.length; i++) {
            graphics.currentTransform = new Transform(x + positions[i][0] * cell, y + positions[i][1] * cell, cell, r++ % 4);
            shapes(shapeIndex, graphics, cell, i);
        }
        
        renderer.endShape();
    }

    // AVAILABLE COLORS
    const hue = parseHex(hash, -7) / 0xfffffff,
    
          // Available colors for this icon
          availableColors = colorTheme(hue, parsedConfig),

          // The index of the selected colors
          selectedColorIndexes = [];

    let index;

    function isDuplicate(values) {
        if (values.indexOf(index) >= 0) {
            for (let i = 0; i < values.length; i++) {
                if (selectedColorIndexes.indexOf(values[i]) >= 0) {
                    return true;
                }
            }
        }
    }

    for (let i = 0; i < 3; i++) {
        index = parseHex(hash, 8 + i, 1) % availableColors.length;
        if (isDuplicate([0, 4]) || // Disallow dark gray and dark color combo
            isDuplicate([2, 3])) { // Disallow light gray and light color combo
            index = 1;
        }
        selectedColorIndexes.push(index);
    }

    // ACTUAL RENDERING
    // Sides
    renderShape(0, outerShape, 2, 3, [[1, 0], [2, 0], [2, 3], [1, 3], [0, 1], [3, 1], [3, 2], [0, 2]]);
    // Corners
    renderShape(1, outerShape, 4, 5, [[0, 0], [3, 0], [3, 3], [0, 3]]);
    // Center
    renderShape(2, centerShape, 1, null, [[1, 1], [2, 1], [2, 2], [1, 2]]);
    
    renderer.finish();
}

/**
 * Computes a SHA1 hash for any value and returns it as a hexadecimal string.
 * 
 * This function is optimized for minimal code size and rather short messages.
 * 
 * @param {string} message 
 */
function sha1(message) {
    const HASH_SIZE_HALF_BYTES = 40;
    const BLOCK_SIZE_WORDS = 16;

    // Variables
    // `var` is used to be able to minimize the number of `var` keywords.
    var i = 0,
        f = 0,
    
        // Use `encodeURI` to UTF8 encode the message without any additional libraries
        // We could use `unescape` + `encodeURI` to minimize the code, but that would be slightly risky
        // since `unescape` is deprecated.
        urlEncodedMessage = encodeURI(message) + "%80", // trailing '1' bit padding
        
        // This can be changed to a preallocated Uint32Array array for greater performance and larger code size
        data = [],
        dataSize,
        
        hashBuffer = [],

        a = 0x67452301,
        b = 0xefcdab89,
        c = ~a,
        d = ~b,
        e = 0xc3d2e1f0,
        hash = [a, b, c, d, e],

        blockStartIndex = 0,
        hexHash = "";

    /**
     * Rotates the value a specified number of bits to the left.
     * @param {number} value  Value to rotate
     * @param {number} shift  Bit count to shift.
     */
    function rotl(value, shift) {
        return (value << shift) | (value >>> (32 - shift));
    }

    // Message data
    for ( ; i < urlEncodedMessage.length; f++) {
        data[f >> 2] = data[f >> 2] |
            (
                (
                    urlEncodedMessage[i] == "%"
                        // Percent encoded byte
                        ? parseInt(urlEncodedMessage.substring(i + 1, i += 3), 16)
                        // Unencoded byte
                        : urlEncodedMessage.charCodeAt(i++)
                )

                // Read bytes in reverse order (big endian words)
                << ((3 - (f & 3)) * 8)
            );
    }

    // f is now the length of the utf8 encoded message
    // 7 = 8 bytes (64 bit) for message size, -1 to round down
    // >> 6 = integer division with block size
    dataSize = (((f + 7) >> 6) + 1) * BLOCK_SIZE_WORDS;

    // Message size in bits.
    // SHA1 uses a 64 bit integer to represent the size, but since we only support short messages only the least
    // significant 32 bits are set. -8 is for the '1' bit padding byte.
    data[dataSize - 1] = f * 8 - 8;
    
    // Compute hash
    for ( ; blockStartIndex < dataSize; blockStartIndex += BLOCK_SIZE_WORDS) {
        for (i = 0; i < 80; i++) {
            f = rotl(a, 5) + e + (
                    // Ch
                    i < 20 ? ((b & c) ^ ((~b) & d)) + 0x5a827999 :
                    
                    // Parity
                    i < 40 ? (b ^ c ^ d) + 0x6ed9eba1 :
                    
                    // Maj
                    i < 60 ? ((b & c) ^ (b & d) ^ (c & d)) + 0x8f1bbcdc :
                    
                    // Parity
                    (b ^ c ^ d) + 0xca62c1d6
                ) + ( 
                    hashBuffer[i] = i < BLOCK_SIZE_WORDS
                        // Bitwise OR is used to coerse `undefined` to 0
                        ? (data[blockStartIndex + i] | 0)
                        : rotl(hashBuffer[i - 3] ^ hashBuffer[i - 8] ^ hashBuffer[i - 14] ^ hashBuffer[i - 16], 1)
                );

            e = d;
            d = c;
            c = rotl(b, 30);
            b = a;
            a = f;
        }

        hash[0] = a = ((hash[0] + a) | 0);
        hash[1] = b = ((hash[1] + b) | 0);
        hash[2] = c = ((hash[2] + c) | 0);
        hash[3] = d = ((hash[3] + d) | 0);
        hash[4] = e = ((hash[4] + e) | 0);
    }

    // Format hex hash
    for (i = 0; i < HASH_SIZE_HALF_BYTES; i++) {
        hexHash += (
            (
                // Get word (2^3 half-bytes per word)
                hash[i >> 3] >>>

                // Append half-bytes in reverse order
                ((7 - (i & 7)) * 4)
            ) 
            // Clamp to half-byte
            & 0xf
        ).toString(16);
    }

    return hexHash;
}

/**
 * Inputs a value that might be a valid hash string for Jdenticon and returns it 
 * if it is determined valid, otherwise a falsy value is returned.
 */
function isValidHash(hashCandidate) {
    return /^[0-9a-f]{11,}$/i.test(hashCandidate) && hashCandidate;
}

/**
 * Computes a hash for the specified value. Currently SHA1 is used. This function
 * always returns a valid hash.
 */
function computeHash(value) {
    return sha1(value == null ? "" : "" + value);
}



/**
 * Renderer redirecting drawing commands to a canvas context.
 * @implements {Renderer}
 */
class CanvasRenderer$1 {
    /**
     * @param {number=} iconSize
     */
    constructor(ctx, iconSize) {
        const canvas = ctx.canvas; 
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.save();
        
        if (!iconSize) {
            iconSize = Math.min(width, height);
            
            ctx.translate(
                ((width - iconSize) / 2) | 0,
                ((height - iconSize) / 2) | 0);
        }

        /**
         * @private
         */
        this._ctx = ctx;
        this.iconSize = iconSize;
        
        ctx.clearRect(0, 0, iconSize, iconSize);
    }

    /**
     * Fills the background with the specified color.
     * @param {string} fillColor  Fill color on the format #rrggbb[aa].
     */
    setBackground(fillColor) {
        const ctx = this._ctx;
        const iconSize = this.iconSize;

        ctx.fillStyle = toCss3Color(fillColor);
        ctx.fillRect(0, 0, iconSize, iconSize);
    }

    /**
     * Marks the beginning of a new shape of the specified color. Should be ended with a call to endShape.
     * @param {string} fillColor Fill color on format #rrggbb[aa].
     */
    beginShape(fillColor) {
        const ctx = this._ctx;
        ctx.fillStyle = toCss3Color(fillColor);
        ctx.beginPath();
    }

    /**
     * Marks the end of the currently drawn shape. This causes the queued paths to be rendered on the canvas.
     */
    endShape() {
        this._ctx.fill();
    }

    /**
     * Adds a polygon to the rendering queue.
     * @param points An array of Point objects.
     */
    addPolygon(points) {
        const ctx = this._ctx;
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
    }

    /**
     * Adds a circle to the rendering queue.
     * @param {Point} point The upper left corner of the circle bounding box.
     * @param {number} diameter The diameter of the circle.
     * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).
     */
    addCircle(point, diameter, counterClockwise) {
        const ctx = this._ctx,
              radius = diameter / 2;
        ctx.moveTo(point.x + radius, point.y + radius);
        ctx.arc(point.x + radius, point.y + radius, radius, 0, Math.PI * 2, counterClockwise);
        ctx.closePath();
    }

    /**
     * Called when the icon has been completely drawn.
     */
    finish() {
        this._ctx.restore();
    }
}

/**
 * Draws an identicon to a context.
 * @param {CanvasRenderingContext2D} ctx - Canvas context on which the icon will be drawn at location (0, 0).
 * @param {*} hashOrValue - A hexadecimal hash string or any value that will be hashed by Jdenticon.
 * @param {number} size - Icon size in pixels.
 * @param {Object|number=} config - Optional configuration. If specified, this configuration object overrides any
 *    global configuration in its entirety. For backward compatibility a padding value in the range [0.0, 0.5) can be
 *    specified in place of a configuration object.
 */
function drawIcon(ctx, hashOrValue, size, config) {
    if (!ctx) {
        throw new Error("No canvas specified.");
    }
    
    iconGenerator(new CanvasRenderer$1(ctx, size), 
        isValidHash(hashOrValue) || computeHash(hashOrValue), 
        config);
}

/**
 * Draws an identicon as PNG.
 * @param {*} hashOrValue - A hexadecimal hash string or any value that will be hashed by Jdenticon.
 * @param {number} size - Icon size in pixels.
 * @param {Object|number=} config - Optional configuration. If specified, this configuration object overrides any
 *    global configuration in its entirety. For backward compatibility a padding value in the range [0.0, 0.5) can be
 *    specified in place of a configuration object.
 * @returns {Buffer} PNG data
 */
function toPng(hashOrValue, size, config) {
    const canvas = canvasRenderer__default['default'].createCanvas(size, size);
    const ctx = canvas.getContext("2d");
    
    iconGenerator(new CanvasRenderer$1(ctx, size), 
        isValidHash(hashOrValue) || computeHash(hashOrValue), 
        config);
    
    return canvas.toPng({ "Software": "Jdenticon" });
}

/**
 * Prepares a measure to be used as a measure in an SVG path, by
 * rounding the measure to a single decimal. This reduces the file
 * size of the generated SVG with more than 50% in some cases.
 */
function svgValue(value) {
    return ((value * 10 + 0.5) | 0) / 10;
}

/**
 * Represents an SVG path element.
 */
class SvgPath {
    constructor() {
        /**
         * This property holds the data string (path.d) of the SVG path.
         * @type {string}
         */
        this.dataString = "";
    }

    /**
     * Adds a polygon with the current fill color to the SVG path.
     * @param points An array of Point objects.
     */
    addPolygon(points) {
        let dataString = "";
        for (let i = 0; i < points.length; i++) {
            dataString += (i ? "L" : "M") + svgValue(points[i].x) + " " + svgValue(points[i].y);
        }
        this.dataString += dataString + "Z";
    }

    /**
     * Adds a circle with the current fill color to the SVG path.
     * @param {Point} point The upper left corner of the circle bounding box.
     * @param {number} diameter The diameter of the circle.
     * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).
     */
    addCircle(point, diameter, counterClockwise) {
        const sweepFlag = counterClockwise ? 0 : 1,
              svgRadius = svgValue(diameter / 2),
              svgDiameter = svgValue(diameter),
              svgArc = "a" + svgRadius + "," + svgRadius + " 0 1," + sweepFlag + " ";
            
        this.dataString += 
            "M" + svgValue(point.x) + " " + svgValue(point.y + diameter / 2) +
            svgArc + svgDiameter + ",0" + 
            svgArc + (-svgDiameter) + ",0";
    }
}



/**
 * Renderer producing SVG output.
 * @implements {Renderer}
 */
class SvgRenderer$2 {
    /**
     * @param {SvgElement|SvgWriter} target 
     */
    constructor(target) {
        /**
         * @type {SvgPath}
         * @private
         */
        this._path;

        /**
         * @type {Object.<string,SvgPath>}
         * @private
         */
        this._pathsByColor = { };

        /**
         * @type {SvgElement|SvgWriter}
         * @private
         */
        this._target = target;

        /**
         * @type {number}
         */
        this.iconSize = target.iconSize;
    }

    /**
     * Fills the background with the specified color.
     * @param {string} fillColor  Fill color on the format #rrggbb[aa].
     */
    setBackground(fillColor) {
        const match = /^(#......)(..)?/.exec(fillColor),
              opacity = match[2] ? parseHex(match[2], 0) / 255 : 1;
        this._target.setBackground(match[1], opacity);
    }

    /**
     * Marks the beginning of a new shape of the specified color. Should be ended with a call to endShape.
     * @param {string} color Fill color on format #xxxxxx.
     */
    beginShape(color) {
        this._path = this._pathsByColor[color] || (this._pathsByColor[color] = new SvgPath());
    }

    /**
     * Marks the end of the currently drawn shape.
     */
    endShape() { }

    /**
     * Adds a polygon with the current fill color to the SVG.
     * @param points An array of Point objects.
     */
    addPolygon(points) {
        this._path.addPolygon(points);
    }

    /**
     * Adds a circle with the current fill color to the SVG.
     * @param {Point} point The upper left corner of the circle bounding box.
     * @param {number} diameter The diameter of the circle.
     * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).
     */
    addCircle(point, diameter, counterClockwise) {
        this._path.addCircle(point, diameter, counterClockwise);
    }

    /**
     * Called when the icon has been completely drawn.
     */
    finish() { 
        const pathsByColor = this._pathsByColor;
        for (let color in pathsByColor) {
            // hasOwnProperty cannot be shadowed in pathsByColor
            // eslint-disable-next-line no-prototype-builtins
            if (pathsByColor.hasOwnProperty(color)) {
                this._target.appendPath(color, pathsByColor[color].dataString);
            }
        }
    }
}

const SVG_CONSTANTS = {
    XMLNS: "http://www.w3.org/2000/svg",
    WIDTH: "width",
    HEIGHT: "height",
};

/**
 * Renderer producing SVG output.
 */
class SvgWriter {
    /**
     * @param {number} iconSize - Icon width and height in pixels.
     */
    constructor(iconSize) {
        /**
         * @type {number}
         */
        this.iconSize = iconSize;

        /**
         * @type {string}
         * @private
         */
        this._s =
            '<svg xmlns="' + SVG_CONSTANTS.XMLNS + '" width="' + 
            iconSize + '" height="' + iconSize + '" viewBox="0 0 ' + 
            iconSize + ' ' + iconSize + '">';
    }

    /**
     * Fills the background with the specified color.
     * @param {string} fillColor  Fill color on the format #rrggbb.
     * @param {number} opacity  Opacity in the range [0.0, 1.0].
     */
    setBackground(fillColor, opacity) {
        if (opacity) {
            this._s += '<rect width="100%" height="100%" fill="' + 
                fillColor + '" opacity="' + opacity.toFixed(2) + '"/>';
        }
    }

    /**
     * Writes a path to the SVG string.
     * @param {string} color Fill color on format #rrggbb.
     * @param {string} dataString The SVG path data string.
     */
    appendPath(color, dataString) {
        this._s += '<path fill="' + color + '" d="' + dataString + '"/>';
    }

    /**
     * Gets the rendered image as an SVG string.
     */
    toString() {
        return this._s + "</svg>";
    }
}

/**
 * Draws an identicon as an SVG string.
 * @param {*} hashOrValue - A hexadecimal hash string or any value that will be hashed by Jdenticon.
 * @param {number} size - Icon size in pixels.
 * @param {Object|number=} config - Optional configuration. If specified, this configuration object overrides any
 *    global configuration in its entirety. For backward compatibility a padding value in the range [0.0, 0.5) can be
 *    specified in place of a configuration object.
 * @returns {string} SVG string
 */
function toSvg(hashOrValue, size, config) {
    const writer = new SvgWriter(size);
    iconGenerator(new SvgRenderer$2(writer), 
        isValidHash(hashOrValue) || computeHash(hashOrValue),
        config);
    return writer.toString();
}

// This file is compiled to dist/jdenticon-node.js

if (typeof browser$1$1 === "undefined" &&
    typeof window !== "undefined" &&
    typeof document !== "undefined"
) {
    console.warn(
        "Jdenticon: 'dist/jdenticon-node.js' is only intended for Node.js environments and will increase your " +
        "bundle size when included in browser bundles. If you want to run Jdenticon in the browser, please add a " +
        "reference to 'dist/jdenticon.js' or 'dist/jdenticon.min.js' instead.");
}

/**
 * @throws {Error}
 */
function jdenticon() {
    throw new Error("jdenticon() is not supported on Node.js.");
}

defineConfigPropertyWithWarn(jdenticon);

jdenticon.configure = configure;
jdenticon.drawIcon = drawIcon;
jdenticon.toPng = toPng;
jdenticon.toSvg = toSvg;

/**
 * Specifies the version of the Jdenticon package in use.
 * @type {string}
 */
jdenticon.version = "3.1.1";

/**
 * Specifies which bundle of Jdenticon that is used.
 * @type {string}
 */
jdenticon.bundle = "node-cjs";

/**
 * @throws {Error}
 */
jdenticon.update = function update() {
    throw new Error("jdenticon.update() is not supported on Node.js.");
};

/**
 * @throws {Error}
 */
jdenticon.updateCanvas = function updateCanvas() {
    throw new Error("jdenticon.updateCanvas() is not supported on Node.js.");
};

/**
 * @throws {Error}
 */
jdenticon.updateSvg = function updateSvg() {
    throw new Error("jdenticon.updateSvg() is not supported on Node.js.");
};

var jdenticonNode = jdenticon;

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
function Identicon$3({
  className = '',
  publicKey,
  size,
  style
}) {
  const html = useMemo$1(() => ({
    __html: jdenticonNode.toSvg(publicKey.substr(2), size)
  }), [publicKey, size]);
  return /*#__PURE__*/jsx("div", {
    className: className,
    dangerouslySetInnerHTML: html,
    style: style
  });
}
const Jdenticon = /*#__PURE__*/r$3.memo(Identicon$3);

// Copyright 2018-2022 @polkadot/react-identicon authors & contributors
function renderCircle({
  cx,
  cy,
  fill,
  r
}, key) {
  return /*#__PURE__*/jsx("circle", {
    cx: cx,
    cy: cy,
    fill: fill,
    r: r
  }, key);
}
function Identicon$2({
  address,
  className = '',
  isAlternative = false,
  size,
  style
}) {
  const circles = useMemo$1(() => polkadotIcon(address, {
    isAlternative
  }), [address, isAlternative]);
  return /*#__PURE__*/jsx("svg", {
    className: className,
    height: size,
    id: address,
    name: address,
    style: style,
    viewBox: "0 0 64 64",
    width: size,
    children: circles.map(renderCircle)
  });
}
const Polkadot = /*#__PURE__*/r$3.memo(Identicon$2);

var Component$2 = {};

var toggleSelection = function () {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function () {};
  }
  var active = document.activeElement;

  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }

  switch (active.tagName.toUpperCase()) { // .toUpperCase handles XHTML
    case 'INPUT':
    case 'TEXTAREA':
      active.blur();
      break;

    default:
      active = null;
      break;
  }

  selection.removeAllRanges();
  return function () {
    selection.type === 'Caret' &&
    selection.removeAllRanges();

    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }

    active &&
    active.focus();
  };
};

var toggleSelection$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), toggleSelection, {
    'default': toggleSelection
}));

var require$$0$L = /*@__PURE__*/getAugmentedNamespace(toggleSelection$1);

var deselectCurrent = require$$0$L;

var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};

var defaultMessage = "Copy to clipboard: #{key}, Enter";

function format$3(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}

function copy$1(text, options) {
  var debug,
    message,
    reselectPrevious,
    range,
    selection,
    mark,
    success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();

    range = document.createRange();
    selection = document.getSelection();

    mark = document.createElement("span");
    mark.textContent = text;
    // avoid screen readers from reading out loud the text
    mark.ariaHidden = "true";
    // reset user styles for span element
    mark.style.all = "unset";
    // prevents scrolling to the end of the page
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    // used to preserve spaces and line breaks
    mark.style.whiteSpace = "pre";
    // do not inherit user-select (it may be `none`)
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e) {
      e.stopPropagation();
      if (options.format) {
        e.preventDefault();
        if (typeof e.clipboardData === "undefined") { // IE 11
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format, text);
        } else { // all other browsers
          e.clipboardData.clearData();
          e.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e.preventDefault();
        options.onCopy(e.clipboardData);
      }
    });

    document.body.appendChild(mark);

    range.selectNodeContents(mark);
    selection.addRange(range);

    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err) {
      debug && console.error("unable to copy using clipboardData: ", err);
      debug && console.error("falling back to prompt");
      message = format$3("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }

    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }

  return success;
}

var copyToClipboard = copy$1;

var copyToClipboard$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), copyToClipboard, {
    'default': copyToClipboard
}));

var require$$2$K = /*@__PURE__*/getAugmentedNamespace(copyToClipboard$1);

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(Component$2, "__esModule", {
  value: true
});
var CopyToClipboard_1 = Component$2.CopyToClipboard = void 0;

var _react = _interopRequireDefault(r$3);

var _copyToClipboard = _interopRequireDefault(require$$2$K);

var _excluded = ["text", "onCopy", "options", "children"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var CopyToClipboard$1 = /*#__PURE__*/function (_React$PureComponent) {
  _inherits(CopyToClipboard, _React$PureComponent);

  var _super = _createSuper(CopyToClipboard);

  function CopyToClipboard() {
    var _this;

    _classCallCheck(this, CopyToClipboard);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "onClick", function (event) {
      var _this$props = _this.props,
          text = _this$props.text,
          onCopy = _this$props.onCopy,
          children = _this$props.children,
          options = _this$props.options;

      var elem = _react["default"].Children.only(children);

      var result = (0, _copyToClipboard["default"])(text, options);

      if (onCopy) {
        onCopy(text, result);
      } // Bypass onClick if it was present


      if (elem && elem.props && typeof elem.props.onClick === 'function') {
        elem.props.onClick(event);
      }
    });

    return _this;
  }

  _createClass(CopyToClipboard, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props;
          _this$props2.text;
          _this$props2.onCopy;
          _this$props2.options;
          var children = _this$props2.children,
          props = _objectWithoutProperties(_this$props2, _excluded);

      var elem = _react["default"].Children.only(children);

      return /*#__PURE__*/_react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
        onClick: this.onClick
      }));
    }
  }]);

  return CopyToClipboard;
}(_react["default"].PureComponent);

CopyToClipboard_1 = Component$2.CopyToClipboard = CopyToClipboard$1;

_defineProperty(CopyToClipboard$1, "defaultProps", {
  onCopy: undefined,
  options: undefined
});

var Component$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), Component$2, {
    get CopyToClipboard () { return CopyToClipboard_1; },
    'default': Component$2
}));

var require$$0$K = /*@__PURE__*/getAugmentedNamespace(Component$1);

var _require = require$$0$K,
    CopyToClipboard = _require.CopyToClipboard;

CopyToClipboard.CopyToClipboard = CopyToClipboard;
var lib$4 = CopyToClipboard;

var eventemitter3 = {exports: {}};

(function (module) {

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
{
  module.exports = EventEmitter;
}
}(eventemitter3));

var EventEmitter$2 = eventemitter3.exports;

var assign = make_assign();
var create$5 = make_create();
var trim$1 = make_trim();
var Global$5 = (typeof window !== 'undefined' ? window : commonjsGlobal);

var util$d = {
	assign: assign,
	create: create$5,
	trim: trim$1,
	bind: bind$1,
	slice: slice$1,
	each: each$7,
	map: map,
	pluck: pluck$1,
	isList: isList$1,
	isFunction: isFunction$1,
	isObject: isObject$3,
	Global: Global$5
};

function make_assign() {
	if (Object.assign) {
		return Object.assign
	} else {
		return function shimAssign(obj, props1, props2, etc) {
			for (var i = 1; i < arguments.length; i++) {
				each$7(Object(arguments[i]), function(val, key) {
					obj[key] = val;
				});
			}			
			return obj
		}
	}
}

function make_create() {
	if (Object.create) {
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice$1(arguments, 1);
			return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
		}
	} else {
		function F() {} // eslint-disable-line no-inner-declarations
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice$1(arguments, 1);
			F.prototype = obj;
			return assign.apply(this, [new F()].concat(assignArgsList))
		}
	}
}

function make_trim() {
	if (String.prototype.trim) {
		return function trim(str) {
			return String.prototype.trim.call(str)
		}
	} else {
		return function trim(str) {
			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
		}
	}
}

function bind$1(obj, fn) {
	return function() {
		return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
	}
}

function slice$1(arr, index) {
	return Array.prototype.slice.call(arr, index || 0)
}

function each$7(obj, fn) {
	pluck$1(obj, function(val, key) {
		fn(val, key);
		return false
	});
}

function map(obj, fn) {
	var res = (isList$1(obj) ? [] : {});
	pluck$1(obj, function(v, k) {
		res[k] = fn(v, k);
		return false
	});
	return res
}

function pluck$1(obj, fn) {
	if (isList$1(obj)) {
		for (var i=0; i<obj.length; i++) {
			if (fn(obj[i], i)) {
				return obj[i]
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn(obj[key], key)) {
					return obj[key]
				}
			}
		}
	}
}

function isList$1(val) {
	return (val != null && typeof val != 'function' && typeof val.length == 'number')
}

function isFunction$1(val) {
	return val && {}.toString.call(val) === '[object Function]'
}

function isObject$3(val) {
	return val && {}.toString.call(val) === '[object Object]'
}

var util$e = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), util$d, {
    'default': util$d
}));

var require$$0$J = /*@__PURE__*/getAugmentedNamespace(util$e);

var util$c = require$$0$J;
var slice = util$c.slice;
var pluck = util$c.pluck;
var each$6 = util$c.each;
var bind = util$c.bind;
var create$4 = util$c.create;
var isList = util$c.isList;
var isFunction = util$c.isFunction;
var isObject$2 = util$c.isObject;

var storeEngine = {
	createStore: createStore
};

var storeAPI = {
	version: '2.0.12',
	enabled: false,
	
	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key);
		return this._deserialize(data, optionalDefaultValue)
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function(key, value) {
		if (value === undefined) {
			return this.remove(key)
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value));
		return value
	},

	// remove deletes the key and value stored at the given key.
	remove: function(key) {
		this.storage.remove(this._namespacePrefix + key);
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function(callback) {
		var self = this;
		this.storage.each(function(val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''));
		});
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function() {
		this.storage.clearAll();
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function(namespace) {
		return (this._namespacePrefix == '__storejs_'+namespace+'_')
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function() {
		return createStore.apply(this, arguments)
	},
	
	addPlugin: function(plugin) {
		this._addPlugin(plugin);
	},
	
	namespace: function(namespace) {
		return createStore(this.storage, this.plugins, namespace)
	}
};

function _warn() {
	var _console = (typeof console == 'undefined' ? null : console);
	if (!_console) { return }
	var fn = (_console.warn ? _console.warn : _console.log);
	fn.apply(_console, arguments);
}

function createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = '';
	}
	if (storages && !isList(storages)) {
		storages = [storages];
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins];
	}

	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '');
	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null);
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/; // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
	}
	
	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function(storage) {
			try {
				var testStr = '__storejs__test__';
				storage.write(testStr, testStr);
				var ok = (storage.read(testStr) === testStr);
				storage.remove(testStr);
				return ok
			} catch(e) {
				return false
			}
		},

		_assignPluginFnProp: function(pluginFnProp, propName) {
			var oldFn = this[propName];
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0);
				var self = this;

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) { return }
					each$6(arguments, function(arg, i) {
						args[i] = arg;
					});
					return oldFn.apply(self, args)
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args);

				return pluginFnProp.apply(self, newFnArgs)
			};
		},

		_serialize: function(obj) {
			return JSON.stringify(obj)
		},

		_deserialize: function(strVal, defaultVal) {
			if (!strVal) { return defaultVal }
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = '';
			try { val = JSON.parse(strVal); }
			catch(e) { val = strVal; }

			return (val !== undefined ? val : defaultVal)
		},
		
		_addStorage: function(storage) {
			if (this.enabled) { return }
			if (this._testStorage(storage)) {
				this.storage = storage;
				this.enabled = true;
			}
		},

		_addPlugin: function(plugin) {
			var self = this;

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each$6(plugin, function(plugin) {
					self._addPlugin(plugin);
				});
				return
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
				return (plugin === seenPlugin)
			});
			if (seenPlugin) {
				return
			}
			this.plugins.push(plugin);

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects')
			}

			var pluginProperties = plugin.call(this);
			if (!isObject$2(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties')
			}

			// Add the plugin function properties to this store instance.
			each$6(pluginProperties, function(pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
				}
				self._assignPluginFnProp(pluginFnProp, propName);
			});
		},
		
		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.
		
		// Deprecated: addStorage
		addStorage: function(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])');
			this._addStorage(storage);
		}
	};

	var store = create$4(_privateStoreProps, storeAPI, {
		plugins: []
	});
	store.raw = {};
	each$6(store, function(prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop);			
		}
	});
	each$6(storages, function(storage) {
		store._addStorage(storage);
	});
	each$6(plugins, function(plugin) {
		store._addPlugin(plugin);
	});
	return store
}

var storeEngine$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), storeEngine, {
    'default': storeEngine
}));

var require$$0$I = /*@__PURE__*/getAugmentedNamespace(storeEngine$1);

var util$b = require$$0$J;
var Global$4 = util$b.Global;

var localStorage_1 = {
	name: 'localStorage',
	read: read$7,
	write: write$7,
	each: each$5,
	remove: remove$5,
	clearAll: clearAll$5,
};

function localStorage() {
	return Global$4.localStorage
}

function read$7(key) {
	return localStorage().getItem(key)
}

function write$7(key, data) {
	return localStorage().setItem(key, data)
}

function each$5(fn) {
	for (var i = localStorage().length - 1; i >= 0; i--) {
		var key = localStorage().key(i);
		fn(read$7(key), key);
	}
}

function remove$5(key) {
	return localStorage().removeItem(key)
}

function clearAll$5() {
	return localStorage().clear()
}

var localStorage$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), localStorage_1, {
    'default': localStorage_1
}));

var require$$0$H = /*@__PURE__*/getAugmentedNamespace(localStorage$1);

// oldFF-globalStorage provides storage for Firefox
// versions 6 and 7, where no localStorage, etc
// is available.

var util$a = require$$0$J;
var Global$3 = util$a.Global;

var oldFFGlobalStorage = {
	name: 'oldFF-globalStorage',
	read: read$6,
	write: write$6,
	each: each$4,
	remove: remove$4,
	clearAll: clearAll$4,
};

var globalStorage = Global$3.globalStorage;

function read$6(key) {
	return globalStorage[key]
}

function write$6(key, data) {
	globalStorage[key] = data;
}

function each$4(fn) {
	for (var i = globalStorage.length - 1; i >= 0; i--) {
		var key = globalStorage.key(i);
		fn(globalStorage[key], key);
	}
}

function remove$4(key) {
	return globalStorage.removeItem(key)
}

function clearAll$4() {
	each$4(function(key, _) {
		delete globalStorage[key];
	});
}

var oldFFGlobalStorage$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), oldFFGlobalStorage, {
    'default': oldFFGlobalStorage
}));

var require$$1$10 = /*@__PURE__*/getAugmentedNamespace(oldFFGlobalStorage$1);

// oldIE-userDataStorage provides storage for Internet Explorer
// versions 6 and 7, where no localStorage, sessionStorage, etc
// is available.

var util$9 = require$$0$J;
var Global$2 = util$9.Global;

var oldIEUserDataStorage = {
	name: 'oldIE-userDataStorage',
	write: write$5,
	read: read$5,
	each: each$3,
	remove: remove$3,
	clearAll: clearAll$3,
};

var storageName = 'storejs';
var doc$1 = Global$2.document;
var _withStorageEl = _makeIEStorageElFunction();
var disable = (Global$2.navigator ? Global$2.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./); // MSIE 9.x, MSIE 10.x

function write$5(unfixedKey, data) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey);
	_withStorageEl(function(storageEl) {
		storageEl.setAttribute(fixedKey, data);
		storageEl.save(storageName);
	});
}

function read$5(unfixedKey) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey);
	var res = null;
	_withStorageEl(function(storageEl) {
		res = storageEl.getAttribute(fixedKey);
	});
	return res
}

function each$3(callback) {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes;
		for (var i=attributes.length-1; i>=0; i--) {
			var attr = attributes[i];
			callback(storageEl.getAttribute(attr.name), attr.name);
		}
	});
}

function remove$3(unfixedKey) {
	var fixedKey = fixKey(unfixedKey);
	_withStorageEl(function(storageEl) {
		storageEl.removeAttribute(fixedKey);
		storageEl.save(storageName);
	});
}

function clearAll$3() {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes;
		storageEl.load(storageName);
		for (var i=attributes.length-1; i>=0; i--) {
			storageEl.removeAttribute(attributes[i].name);
		}
		storageEl.save(storageName);
	});
}

// Helpers
//////////

// In IE7, keys cannot start with a digit or contain certain chars.
// See https://github.com/marcuswestin/store.js/issues/40
// See https://github.com/marcuswestin/store.js/issues/83
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
function fixKey(key) {
	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
}

function _makeIEStorageElFunction() {
	if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior) {
		return null
	}
	var scriptTag = 'script',
		storageOwner,
		storageContainer,
		storageEl;

	// Since #userData storage applies only to specific paths, we need to
	// somehow link our data to a specific path.  We choose /favicon.ico
	// as a pretty safe option, since all browsers already make a request to
	// this URL anyway and being a 404 will not hurt us here.  We wrap an
	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
	// since the iframe access rules appear to allow direct access and
	// manipulation of the document element, even for a 404 page.  This
	// document can be used instead of the current document (which would
	// have been limited to the current path) to perform #userData storage.
	try {
		/* global ActiveXObject */
		storageContainer = new ActiveXObject('htmlfile');
		storageContainer.open();
		storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>');
		storageContainer.close();
		storageOwner = storageContainer.w.frames[0].document;
		storageEl = storageOwner.createElement('div');
	} catch(e) {
		// somehow ActiveXObject instantiation failed (perhaps some special
		// security settings or otherwse), fall back to per-path storage
		storageEl = doc$1.createElement('div');
		storageOwner = doc$1.body;
	}

	return function(storeFunction) {
		var args = [].slice.call(arguments, 0);
		args.unshift(storageEl);
		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
		storageOwner.appendChild(storageEl);
		storageEl.addBehavior('#default#userData');
		storageEl.load(storageName);
		storeFunction.apply(this, args);
		storageOwner.removeChild(storageEl);
		return
	}
}

var oldIEUserDataStorage$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), oldIEUserDataStorage, {
    'default': oldIEUserDataStorage
}));

var require$$2$J = /*@__PURE__*/getAugmentedNamespace(oldIEUserDataStorage$1);

// cookieStorage is useful Safari private browser mode, where localStorage
// doesn't work but cookies do. This implementation is adopted from
// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

var util$8 = require$$0$J;
var Global$1 = util$8.Global;
var trim = util$8.trim;

var cookieStorage = {
	name: 'cookieStorage',
	read: read$4,
	write: write$4,
	each: each$2,
	remove: remove$2,
	clearAll: clearAll$2,
};

var doc = Global$1.document;

function read$4(key) {
	if (!key || !_has(key)) { return null }
	var regexpStr = "(?:^|.*;\\s*)" +
		escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
		"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
}

function each$2(callback) {
	var cookies = doc.cookie.split(/; ?/g);
	for (var i = cookies.length - 1; i >= 0; i--) {
		if (!trim(cookies[i])) {
			continue
		}
		var kvp = cookies[i].split('=');
		var key = unescape(kvp[0]);
		var val = unescape(kvp[1]);
		callback(val, key);
	}
}

function write$4(key, data) {
	if(!key) { return }
	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
}

function remove$2(key) {
	if (!key || !_has(key)) {
		return
	}
	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
}

function clearAll$2() {
	each$2(function(_, key) {
		remove$2(key);
	});
}

function _has(key) {
	return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
}

var cookieStorage$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cookieStorage, {
    'default': cookieStorage
}));

var require$$3$z = /*@__PURE__*/getAugmentedNamespace(cookieStorage$1);

var util$7 = require$$0$J;
var Global = util$7.Global;

var sessionStorage_1 = {
	name: 'sessionStorage',
	read: read$3,
	write: write$3,
	each: each$1,
	remove: remove$1,
	clearAll: clearAll$1
};

function sessionStorage() {
	return Global.sessionStorage
}

function read$3(key) {
	return sessionStorage().getItem(key)
}

function write$3(key, data) {
	return sessionStorage().setItem(key, data)
}

function each$1(fn) {
	for (var i = sessionStorage().length - 1; i >= 0; i--) {
		var key = sessionStorage().key(i);
		fn(read$3(key), key);
	}
}

function remove$1(key) {
	return sessionStorage().removeItem(key)
}

function clearAll$1() {
	return sessionStorage().clear()
}

var sessionStorage$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), sessionStorage_1, {
    'default': sessionStorage_1
}));

var require$$4$o = /*@__PURE__*/getAugmentedNamespace(sessionStorage$1);

// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

var memoryStorage_1 = {
	name: 'memoryStorage',
	read: read$2,
	write: write$2,
	each: each,
	remove: remove,
	clearAll: clearAll,
};

var memoryStorage = {};

function read$2(key) {
	return memoryStorage[key]
}

function write$2(key, data) {
	memoryStorage[key] = data;
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key);
		}
	}
}

function remove(key) {
	delete memoryStorage[key];
}

function clearAll(key) {
	memoryStorage = {};
}

var memoryStorage$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), memoryStorage_1, {
    'default': memoryStorage_1
}));

var require$$5$l = /*@__PURE__*/getAugmentedNamespace(memoryStorage$1);

var all = [
	// Listed in order of usage preference
	require$$0$H,
	require$$1$10,
	require$$2$J,
	require$$3$z,
	require$$4$o,
	require$$5$l
];

var all$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), all, {
    'default': all
}));

var require$$1$$ = /*@__PURE__*/getAugmentedNamespace(all$1);

/* eslint-disable */

//  json2.js
//  2016-10-28
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
    eval, for, this
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== "object") {
    JSON = {};
}

(function () {

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z"
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i;          // The loop counter.
        var k;          // The member key.
        var v;          // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === "object" &&
                typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case "string":
            return quote(value);

        case "number":

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value)
                ? String(value)
                : "null";

        case "boolean":
        case "null":

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce "null". The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is "object", we might be dealing with an object or an array or
// null.

        case "object":

// Due to a specification blunder in ECMAScript, typeof null is "object",
// so watch out for that case.

            if (!value) {
                return "null";
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === "[object Array]") {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === "string") {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" &&
                    (typeof replacer !== "object" ||
                    typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }

// Make a fake root object containing our value under the key of "".
// Return the result of stringifying the value.

            return str("", {"": value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" +
                            ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with "()" and "new"
// because they can cause invocation, and "=" because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
// replace all simple value tokens with "]" characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or "]" or
// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval("(" + text + ")");

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
}());

var json2 = json2Plugin;

function json2Plugin() {
	
	return {}
}

var json2$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), json2, {
    'default': json2
}));

var require$$2$I = /*@__PURE__*/getAugmentedNamespace(json2$1);

var engine$6 = require$$0$I;

var storages = require$$1$$;
var plugins = [require$$2$I];

var store_legacy = engine$6.createStore(storages, plugins);

// Copyright 2017-2022 @polkadot/ui-settings authors & contributors
// SPDX-License-Identifier: Apache-2.0

const CRYPTOS = [{
  info: 'sr25519',
  text: 'Schnorrkel (sr25519, recommended)',
  value: 'sr25519'
}, {
  info: 'ed25519',
  text: 'Edwards (ed25519, alternative)',
  value: 'ed25519'
}, {
  info: 'ecdsa',
  text: 'ECDSA (Non BTC/ETH compatible)',
  value: 'ecdsa'
}];
const CRYPTOS_ETH = [{
  info: 'ethereum',
  text: 'ECDSA (ETH compatible)',
  value: 'ethereum'
}];
const CRYPTOS_LEDGER = [...CRYPTOS, {
  info: 'ed25519-ledger',
  text: 'Ledger (ed25519, BIP32 derivation)',
  value: 'ed25519-ledger'
}];

// Copyright 2017-2022 @polkadot/ui-settings authors & contributors
// SPDX-License-Identifier: Apache-2.0

const ENDPOINTS = [{
  info: 'local',
  text: 'Local Node (Own, 127.0.0.1:9944)',
  value: 'ws://127.0.0.1:9944/'
}];
const ENDPOINT_DEFAULT = ENDPOINTS[0];

// Copyright 2017-2022 @polkadot/ui-settings authors & contributors
// SPDX-License-Identifier: Apache-2.0

const LEDGER_CONN_DEFAULT = 'none';
const LEDGER_CONN = [{
  info: 'none',
  text: 'Do not attach Ledger devices',
  value: 'none'
},
// Deprecated
// {
//   info: 'u2f',
//   text: 'Attach Ledger via U2F',
//   value: 'u2f'
// },
{
  info: 'webusb',
  text: 'Attach Ledger via WebUSB (Chrome, recommended)',
  value: 'webusb'
}, {
  info: 'hid',
  text: 'Attach Ledger via WebHID (Chrome, experimental)',
  value: 'hid'
}];

// Copyright 2017-2022 @polkadot/ui-settings authors & contributors
const PREFIX_DEFAULT = -1;
const defaultNetwork = {
  info: 'default',
  text: 'Default for the connected node',
  value: -1
};
const networks$3 = availableNetworks.map(({
  displayName,
  network,
  prefix
}) => ({
  info: network,
  text: displayName,
  value: prefix
}));
const PREFIXES = [defaultNetwork, ...networks$3];

// Copyright 2017-2022 @polkadot/ui-settings authors & contributors
// SPDX-License-Identifier: Apache-2.0

// matches https://polkadot.js.org & https://*.polkadot.io
const isPolkadot = typeof window !== 'undefined' && window.location.host.includes('polkadot');

// Copyright 2017-2022 @polkadot/ui-settings authors & contributors
const UIMODE_DEFAULT = !isPolkadot && typeof window !== 'undefined' && window.location.host.includes('ui-light') ? 'light' : 'full';
const UIMODES = [{
  info: 'full',
  text: 'Fully featured',
  value: 'full'
}, {
  info: 'light',
  text: 'Basic features only',
  value: 'light'
}];
const UITHEME_DEFAULT = isPolkadot ? 'polkadot' : 'substrate';
const UITHEMES = [{
  info: 'polkadot',
  text: 'Polkadot',
  value: 'polkadot'
}, {
  info: 'substrate',
  text: 'Substrate',
  value: 'substrate'
}];
const ICON_DEFAULT = 'default';
const ICON_DEFAULT_HOST = isPolkadot ? 'polkadot' : 'substrate';
const ICONS = [{
  info: 'default',
  text: 'Default for the connected node',
  value: 'default'
}, {
  info: 'polkadot',
  text: 'Polkadot',
  value: 'polkadot'
}, {
  info: 'substrate',
  text: 'Substrate',
  value: 'substrate'
}, {
  info: 'beachball',
  text: 'Beachball',
  value: 'beachball'
}];
const NOTIFICATION_DEFAULT = 'popup';

// Copyright 2017-2022 @polkadot/ui-settings authors & contributors
const CAMERA_DEFAULT = 'off';
const CAMERA = [{
  info: 'on',
  text: 'Allow camera access',
  value: 'on'
}, {
  info: 'off',
  text: 'Do not allow camera access',
  value: 'off'
}];
const LANGUAGE_DEFAULT = 'default';
const LOCKING_DEFAULT = 'session';
const LOCKING = [{
  info: 'session',
  text: 'Once per session',
  value: 'session'
}, {
  info: 'tx',
  text: 'On each transaction',
  value: 'tx'
}];

function withDefault(options, option, fallback) {
  const _option = option || fallback;
  return options.some(({
    value
  }) => value === _option) ? _option : fallback;
}
class Settings {
  #emitter;
  #apiType;

  // will become deprecated for supporting substrate connect light clients. apiType structure should be used instead
  #apiUrl;
  #camera;
  #i18nLang;
  #icon;
  #ledgerConn;
  #locking;
  #prefix;
  #uiMode;
  #uiTheme;
  #notification;
  constructor() {
    const settings = store_legacy.get('settings') || {};
    this.#emitter = new EventEmitter$2();

    // will become deprecated for supporting substrate connect light clients. apiType structure should be used instead
    this.#apiUrl = typeof settings.apiUrl === 'string' && settings.apiUrl || hasProcess && browser$1$1.env && browser$1$1.env.WS_URL || ENDPOINT_DEFAULT.value;
    this.#apiType = {
      param: this.#apiUrl,
      type: 'json-rpc'
    };
    this.#camera = withDefault(CAMERA, settings.camera, CAMERA_DEFAULT);
    this.#ledgerConn = withDefault(LEDGER_CONN, settings.ledgerConn, LEDGER_CONN_DEFAULT);
    this.#i18nLang = settings.i18nLang || LANGUAGE_DEFAULT;
    this.#icon = settings.icon || ICON_DEFAULT;
    this.#locking = settings.locking || LOCKING_DEFAULT;
    this.#prefix = isUndefined$2(settings.prefix) ? PREFIX_DEFAULT : settings.prefix;
    this.#uiMode = settings.uiMode || UIMODE_DEFAULT;
    this.#uiTheme = settings.uiTheme || UITHEME_DEFAULT;
    this.#notification = settings.notification || NOTIFICATION_DEFAULT;
  }
  get camera() {
    return this.#camera;
  }
  get apiType() {
    return this.#apiType;
  }
  get apiUrl() {
    return this.#apiUrl;
  }
  get i18nLang() {
    return this.#i18nLang;
  }
  get icon() {
    return this.#icon;
  }
  get notification() {
    return this.#notification;
  }
  get ledgerConn() {
    return this.#ledgerConn;
  }
  get locking() {
    return this.#locking;
  }
  get prefix() {
    return this.#prefix;
  }
  get uiMode() {
    return this.#uiMode;
  }
  get uiTheme() {
    return this.#uiTheme;
  }
  get availableCamera() {
    return CAMERA;
  }
  get availableCryptos() {
    return CRYPTOS;
  }
  get availableCryptosEth() {
    return CRYPTOS_ETH;
  }
  get availableCryptosLedger() {
    return CRYPTOS_LEDGER;
  }
  get availableIcons() {
    return ICONS;
  }
  get availableLedgerConn() {
    return LEDGER_CONN;
  }
  get availableLocking() {
    return LOCKING;
  }
  get availableNodes() {
    return ENDPOINTS;
  }
  get availablePrefixes() {
    return PREFIXES;
  }
  get availableUIModes() {
    return UIMODES;
  }
  get availableUIThemes() {
    return UITHEMES;
  }
  get() {
    return {
      apiType: this.#apiType,
      apiUrl: this.#apiUrl,
      camera: this.#camera,
      i18nLang: this.#i18nLang,
      icon: this.#icon,
      ledgerConn: this.#ledgerConn,
      locking: this.#locking,
      notification: this.#notification,
      prefix: this.#prefix,
      uiMode: this.#uiMode,
      uiTheme: this.#uiTheme
    };
  }
  set(settings) {
    this.#apiType = settings.apiType || this.#apiType;
    this.#apiUrl = settings.apiUrl || this.#apiUrl;
    this.#camera = settings.camera || this.#camera;
    this.#ledgerConn = settings.ledgerConn || this.#ledgerConn;
    this.#i18nLang = settings.i18nLang || this.#i18nLang;
    this.#icon = settings.icon || this.#icon;
    this.#locking = settings.locking || this.#locking;
    this.#notification = settings.notification || this.#notification;
    this.#prefix = isUndefined$2(settings.prefix) ? this.#prefix : settings.prefix;
    this.#uiMode = settings.uiMode || this.#uiMode;
    this.#uiTheme = settings.uiTheme || this.#uiTheme;
    const newValues = this.get();
    store_legacy.set('settings', newValues);
    this.#emitter.emit('change', newValues);
  }
  on(type, cb) {
    this.#emitter.on(type, cb);
  }
}
const settings = new Settings();

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
const Fallback = Beachball;
const DEFAULT_SIZE = 64;
const Components = {
  beachball: Beachball,
  empty: Empty,
  ethereum: Ethereum,
  jdenticon: Jdenticon,
  polkadot: Polkadot,
  substrate: Jdenticon
};
const Wrapper = styled.div.withConfig({
  displayName: "Identicon__Wrapper",
  componentId: "sc-1gm2vek-0"
})(["cursor:copy;display:inline-block;line-height:0;> .container{position:relative;> div,> svg{position:relative;}&.highlight:before{position:absolute;top:0;left:0;right:0;bottom:0;border-radius:50%;box-shadow:0 0 5px 2px #aaa;content:'';}}"]);
class BaseIcon extends r$3.PureComponent {
  state = {
    address: '',
    publicKey: '0x'
  };
  static prefix = undefined;
  static setDefaultPrefix(prefix) {
    BaseIcon.prefix = prefix;
  }
  static getDerivedStateFromProps({
    prefix = BaseIcon.prefix,
    theme,
    value
  }, prevState) {
    if (theme === 'ethereum') {
      const address = isU8a(value) ? ethereumEncode(value) : value || '';
      return {
        address,
        publicKey: ''
      };
    }
    try {
      const address = isU8a(value) || isHex(value) ? encodeAddress(value, prefix) : value || '';
      const publicKey = u8aToHex(decodeAddress(address, false, prefix));
      return address === prevState.address ? null : {
        address,
        publicKey
      };
    } catch (error) {
      return {
        address: '',
        publicKey: '0x'
      };
    }
  }
  render() {
    const {
      address
    } = this.state;
    const wrapped = this.getWrapped(this.state, this.props);
    return !address ? wrapped : /*#__PURE__*/jsx(lib$4, {
      onCopy: this.onCopy,
      text: address,
      children: wrapped
    });
  }
  getWrapped({
    address,
    publicKey
  }, {
    Custom
  }) {
    const {
      className = '',
      isAlternative,
      isHighlight,
      size = DEFAULT_SIZE,
      style,
      theme = settings.icon
    } = this.props;
    const Component = !address ? Empty : Custom || Components[theme === 'default' ? ICON_DEFAULT_HOST : theme] || Fallback;
    return /*#__PURE__*/jsx(Wrapper, {
      className: `ui--IdentityIcon  ${className}`,
      style: style,
      children: /*#__PURE__*/jsx(Component, {
        address: address,
        className: isHighlight ? 'highlight' : '',
        isAlternative: isAlternative,
        publicKey: publicKey,
        size: size
      })
    }, address);
  }
  onCopy = () => {
    const {
      onCopy
    } = this.props;
    const {
      address
    } = this.state;
    if (address && onCopy) {
      onCopy(address);
    }
  };
}
function Icon(props) {
  return /*#__PURE__*/jsx(BaseIcon, {
    ...props
  });
}
const Identicon$1 = /*#__PURE__*/r$3.memo(Icon);

// Copyright 2017-2022 @polkadot/react-identicon authors & contributors
var Identicon = Identicon$1;

function AccountItem(_a) {
    var account = _a.account, selectActiveAccount = _a.selectActiveAccount, isActiveAccount = _a.isActiveAccount;
    var _b = useState$1(false), isHover = _b[0], setIsHover = _b[1];
    var extensionKey = account === null || account === void 0 ? void 0 : account.meta.source;
    return (jsxs("div", __assign({ style: __assign(__assign({}, styles$8.container), { backgroundColor: isActiveAccount ? "#3817B8" : isHover ? "rgba(56, 23, 184, 0.3)" : "#000" }), onMouseEnter: function () {
            setIsHover(true);
        }, onMouseLeave: function () {
            setIsHover(false);
        }, onClick: function () { return selectActiveAccount(account); } }, { children: [jsxs("div", __assign({ style: styles$8.accountInfo }, { children: [jsx(Identicon, { size: 32, value: account.address, theme: 'substrate' }, void 0), jsx("h1", __assign({ style: styles$8.accountName }, { children: account === null || account === void 0 ? void 0 : account.meta.name }), void 0)] }), void 0), jsx("img", { src: EXTENSIONS_LIST[extensionKey].logo, style: styles$8.extensionLogo }, void 0)] }), void 0));
}

function AccountList() {
    var _a = useTernoaConnect(), accounts = _a.accounts, currentActiveAccount = _a.currentActiveAccount, selectNewActiveAccount = _a.selectNewActiveAccount;
    return (jsx("div", __assign({ style: styles$9.container }, { children: accounts === null || accounts === void 0 ? void 0 : accounts.map(function (account) {
            var key = account.address + "_" + (account === null || account === void 0 ? void 0 : account.meta.source);
            var isActiveAccount = (((currentActiveAccount === null || currentActiveAccount === void 0 ? void 0 : currentActiveAccount.address) === account.address) && ((currentActiveAccount === null || currentActiveAccount === void 0 ? void 0 : currentActiveAccount.meta.source) === (account === null || account === void 0 ? void 0 : account.meta.source)));
            return (jsx(AccountItem, { account: account, selectActiveAccount: selectNewActiveAccount, isActiveAccount: isActiveAccount }, key));
        }) }), void 0));
}

var styles$7 = {
    container: {
        flex: 1,
        borderWidth: 1,
        borderColor: '#3817B8',
        borderRadius: 8,
        color: '#FFF',
        padding: 8,
        margin: 8,
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
    },
    extensionInfo: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'flex-start',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
    },
    logo: {
        height: 32,
        width: 32,
    },
    extensionName: {
        marginLeft: 8,
        fontSize: 16,
        fontWeight: '900',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
    },
    download: {
        padding: '2px 8px',
        backgroundColor: 'blue',
        borderRadius: 8,
    },
    disabled: {
        padding: '2px 8px',
        backgroundColor: 'red',
        borderRadius: 8,
    },
};

function ExtensionItem(_a) {
    var name = _a.name, logo = _a.logo, download_url = _a.download_url; _a.documentation_url; var isExtensionInstalled = _a.isExtensionInstalled, isExtensionEnabled = _a.isExtensionEnabled, isActiveExtension = _a.isActiveExtension;
    var _b = useState$1(false), isHover = _b[0], setIsHover = _b[1];
    var download = function () {
        window.open(download_url);
    };
    return (jsxs("div", __assign({ style: __assign(__assign({}, styles$7.container), { backgroundColor: isActiveExtension ? "#3817B8" : isHover ? "rgba(56, 23, 184, 0.3)" : "#000" }), onMouseEnter: function () {
            setIsHover(true);
        }, onMouseLeave: function () {
            setIsHover(false);
        } }, { children: [jsxs("div", __assign({ style: styles$7.extensionInfo }, { children: [jsx("img", { src: logo, style: styles$7.logo }, void 0), jsx("h1", __assign({ style: styles$7.extensionName }, { children: name }), void 0)] }), void 0), !isExtensionInstalled ? (jsx("button", __assign({ style: styles$7.download, onClick: download }, { children: "Download" }), void 0)) : null, !isExtensionEnabled ? (jsx("div", __assign({ style: styles$7.disabled }, { children: "Disabled" }), void 0)) : null] }), void 0));
}

var styles$6 = {
    container: {
        height: '100%',
        width: '100%',
        overflowX: 'hidden',
        overflowY: 'auto',
    },
};

function ExtensionList() {
    var _a = useTernoaConnect(), extensions = _a.extensions, currentActiveExtension = _a.currentActiveExtension;
    return (jsx("div", __assign({ style: styles$6.container }, { children: Object.keys(EXTENSIONS_LIST).map(function (key) {
            var _a;
            var extensionKey = key;
            var isExtensionInstalled = (_a = window === null || window === void 0 ? void 0 : window.injectedWeb3) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(key);
            var isExtensionEnabled = (extensions === null || extensions === void 0 ? void 0 : extensions.some(function (extension) { return extension.name === key; })) || false;
            var isActiveExtension = (currentActiveExtension === null || currentActiveExtension === void 0 ? void 0 : currentActiveExtension.name) === key || false;
            return (jsx("div", { children: jsx(ExtensionItem, { logo: EXTENSIONS_LIST[extensionKey].logo, name: EXTENSIONS_LIST[extensionKey].name, download_url: EXTENSIONS_LIST[extensionKey].download_url, documentation_url: EXTENSIONS_LIST[extensionKey].documentation_url, isExtensionInstalled: isExtensionInstalled, isExtensionEnabled: isExtensionEnabled, isActiveExtension: isActiveExtension }, void 0) }, extensionKey));
        }) }), void 0));
}

var styles$5 = {
    container: {
        width: '100%',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
    },
    titleContainer: {
        width: '100%',
        padding: 8,
        borderBottomWidth: 1,
        borderBottomColor: '#3817B8',
        display: 'flex',
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: 22,
        fontWeight: '900',
        color: '#FFF',
        textTransform: 'capitalize',
    },
    selectorContainer: {
        height: 42,
        width: '100%',
        display: 'flex',
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: 16,
        fontWeight: '900',
        color: '#FFF',
    },
    section: {
        flex: 1,
        height: '100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'pointer',
        color: '#FFF',
    },
    close: {
        position: 'absolute',
        right: 8,
    },
};

function ModalHeader(_a) {
    var title = _a.title, currentView = _a.currentView, setCurrentView = _a.setCurrentView;
    var toggleModal = useTernoaConnect().toggleModal;
    return (jsxs("div", __assign({ style: styles$5.container }, { children: [jsxs("div", __assign({ style: styles$5.titleContainer }, { children: [jsx("h1", { children: title }, void 0), jsx("button", __assign({ style: styles$5.close, onClick: toggleModal }, { children: jsx("img", { src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMS4wMTM1IDAuOTg2MzdDMTAuODA3NCAwLjc4MDI2IDEwLjQ3MzMgMC43ODAyNiAxMC4yNjcxIDAuOTg2MzdMNS45OTk5NSA1LjI1MzU3TDEuNzMyNzYgMC45ODYzODRMMS42ODk5MSAwLjk0NzkxMUMxLjQ4MjY2IDAuNzgxMTkgMS4xNzg3NCAwLjc5NDAxNSAwLjk4NjM3IDAuOTg2Mzg0QzAuNzgwMjYgMS4xOTI0OSAwLjc4MDI2IDEuNTI2NjYgMC45ODYzNyAxLjczMjc3TDUuMjUzNTYgNS45OTk5NkwwLjk4NjM3IDEwLjI2NzFMMC45NDc4OTYgMTAuMzFDMC43ODExNzYgMTAuNTE3MiAwLjc5NCAxMC44MjEyIDAuOTg2MzcgMTEuMDEzNUMxLjE5MjQ4IDExLjIxOTYgMS41MjY2NSAxMS4yMTk2IDEuNzMyNzYgMTEuMDEzNUw1Ljk5OTk1IDYuNzQ2MzVMMTAuMjY3MSAxMS4wMTM2TDEwLjMxIDExLjA1MkMxMC41MTcyIDExLjIxODcgMTAuODIxMiAxMS4yMDU5IDExLjAxMzUgMTEuMDEzNkMxMS4yMTk2IDEwLjgwNzQgMTEuMjE5NiAxMC40NzMzIDExLjAxMzUgMTAuMjY3Mkw2Ljc0NjM0IDUuOTk5OTZMMTEuMDEzNSAxLjczMjc2TDExLjA1MiAxLjY4OTkxQzExLjIxODcgMS40ODI2NiAxMS4yMDU5IDEuMTc4NzQgMTEuMDEzNSAwLjk4NjM3WiIgZmlsbD0iYmxhY2siLz4KPG1hc2sgaWQ9Im1hc2swXzEwMjk3XzU1MjMiIHN0eWxlPSJtYXNrLXR5cGU6YWxwaGEiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjAiIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTEuMDEzNSAwLjk4NjM3QzEwLjgwNzQgMC43ODAyNiAxMC40NzMzIDAuNzgwMjYgMTAuMjY3MSAwLjk4NjM3TDUuOTk5OTUgNS4yNTM1N0wxLjczMjc2IDAuOTg2Mzg0TDEuNjg5OTEgMC45NDc5MTFDMS40ODI2NiAwLjc4MTE5IDEuMTc4NzQgMC43OTQwMTUgMC45ODYzNyAwLjk4NjM4NEMwLjc4MDI2IDEuMTkyNDkgMC43ODAyNiAxLjUyNjY2IDAuOTg2MzcgMS43MzI3N0w1LjI1MzU2IDUuOTk5OTZMMC45ODYzNyAxMC4yNjcxTDAuOTQ3ODk2IDEwLjMxQzAuNzgxMTc2IDEwLjUxNzIgMC43OTQgMTAuODIxMiAwLjk4NjM3IDExLjAxMzVDMS4xOTI0OCAxMS4yMTk2IDEuNTI2NjUgMTEuMjE5NiAxLjczMjc2IDExLjAxMzVMNS45OTk5NSA2Ljc0NjM1TDEwLjI2NzEgMTEuMDEzNkwxMC4zMSAxMS4wNTJDMTAuNTE3MiAxMS4yMTg3IDEwLjgyMTIgMTEuMjA1OSAxMS4wMTM1IDExLjAxMzZDMTEuMjE5NiAxMC44MDc0IDExLjIxOTYgMTAuNDczMyAxMS4wMTM1IDEwLjI2NzJMNi43NDYzNCA1Ljk5OTk2TDExLjAxMzUgMS43MzI3NkwxMS4wNTIgMS42ODk5MUMxMS4yMTg3IDEuNDgyNjYgMTEuMjA1OSAxLjE3ODc0IDExLjAxMzUgMC45ODYzN1oiIGZpbGw9IndoaXRlIi8+CjwvbWFzaz4KPGcgbWFzaz0idXJsKCNtYXNrMF8xMDI5N181NTIzKSI+CjxyZWN0IHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0iI0ZGRiIvPgo8L2c+Cjwvc3ZnPgo=', style: { height: 12, width: 12 } }, void 0) }), void 0)] }), void 0), jsxs("div", __assign({ style: styles$5.selectorContainer }, { children: [jsx("div", __assign({ style: __assign(__assign({}, styles$5.section), { backgroundColor: currentView === 'EXTENSIONS' ? '#000' : 'rgba(56,23,184,0.5)', fontWeight: currentView === 'EXTENSIONS' ? '100' : '900' }), onClick: function () { return setCurrentView('EXTENSIONS'); } }, { children: "Extensions" }), void 0), jsx("div", __assign({ style: __assign(__assign({}, styles$5.section), { backgroundColor: currentView === 'ACCOUNTS' ? '#000' : 'rgba(56,23,184,0.5)' }), onClick: function () { return setCurrentView('ACCOUNTS'); } }, { children: "Accounts" }), void 0), jsx("div", __assign({ style: __assign(__assign({}, styles$5.section), { backgroundColor: currentView === 'WALLETS' ? '#000' : 'rgba(56,23,184,0.5)' }), onClick: function () { return setCurrentView('WALLETS'); } }, { children: "Wallets" }), void 0)] }), void 0)] }), void 0));
}

var styles$4 = {
    container: {
        position: 'fixed',
        zIndex: 99,
        height: '100%',
        width: '100%',
        display: 'flex',
        alignItems: 'flex-start',
        justifyContent: 'center',
        backgroundColor: 'rgba(0,0,0,0.5)',
    },
    modal: {
        position: 'absolute',
        flexDirection: 'column',
        height: 400,
        width: '95%',
        maxWidth: 400,
        backgroundColor: '#000',
        opacity: 1,
        top: 80,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#3817B8',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        overflow: 'hidden',
        transition: 'transform 0.3s ease-in-out',
        transform: 'translateY(-10px)',
        boxShadow: '0px 0px 7px 2px #3817B8',
    },
};

var styles$3 = {
    container: {
        flex: 1,
        borderWidth: 1,
        borderColor: '#3817B8',
        borderRadius: 8,
        color: '#FFF',
        padding: 8,
        margin: 8,
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
    },
    extensionInfo: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'flex-start',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
    },
    logo: {
        height: 32,
        width: 32,
    },
    extensionName: {
        marginLeft: 8,
        fontSize: 16,
        fontWeight: '900',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
    },
};

function WalletItem(_a) {
    var name = _a.name, logo = _a.logo, isActive = _a.isActive, onSelect = _a.onSelect; _a.key;
    var _b = useState$1(false), isHover = _b[0], setIsHover = _b[1];
    return (jsx("div", __assign({ style: __assign(__assign({}, styles$3.container), { backgroundColor: isActive
                ? '#3817B8'
                : isHover
                    ? 'rgba(56, 23, 184, 0.3)'
                    : '#000' }), onMouseEnter: function () {
            setIsHover(true);
        }, onMouseLeave: function () {
            setIsHover(false);
        }, onClick: onSelect }, { children: jsxs("div", __assign({ style: styles$3.extensionInfo }, { children: [jsx("img", { src: logo, style: styles$3.logo }, void 0), jsx("h1", __assign({ style: styles$3.extensionName }, { children: name }), void 0)] }), void 0) }), void 0));
}

var styles$2 = {
    container: {
        height: '100%',
        width: '100%',
        overflowX: 'hidden',
        overflowY: 'auto',
    },
};

function WalletList() {
    var _a = useTernoaConnect(), currentActiveWallet = _a.currentActiveWallet, selectWallet = _a.selectWallet;
    return (jsx("div", __assign({ style: styles$2.container }, { children: Object.keys(WALLETS_LIST).map(function (key) {
            var wallet = WALLETS_LIST[key];
            var isActiveWallet = (currentActiveWallet === null || currentActiveWallet === void 0 ? void 0 : currentActiveWallet.key) === key || false;
            return (jsx("div", { children: jsx(WalletItem, __assign({}, wallet, { isActive: isActiveWallet, onSelect: function () { return selectWallet(wallet.key); } }), void 0) }, wallet.key));
        }) }), void 0));
}

function Modal$1(_a) {
    var isModalVisible = _a.isModalVisible;
    if (!isModalVisible)
        return null;
    var _b = useState$1('ACCOUNTS'), currentView = _b[0], setCurrentView = _b[1];
    var modalRef = useRef$1();
    var toggleModal = useTernoaConnect().toggleModal;
    var closeModal = function (event) {
        if (modalRef.current === event.target) {
            toggleModal();
        }
    };
    return (jsx("div", __assign({ ref: modalRef, style: __assign({}, styles$4.container), onClick: closeModal }, { children: jsxs("div", __assign({ style: __assign({}, styles$4.modal) }, { children: [jsx(ModalHeader, { title: 'Ternoa Connect', currentView: currentView, setCurrentView: setCurrentView }, void 0), currentView === VIEWS.EXTENSIONS ? jsx(ExtensionList, {}, void 0) : null, currentView === VIEWS.ACCOUNTS ? jsx(AccountList, {}, void 0) : null, currentView === VIEWS.WALLETS ? jsx(WalletList, {}, void 0) : null] }), void 0) }), void 0));
}

var cjs$q = {};

var require$$0$G = /*@__PURE__*/getAugmentedNamespace(tslib_es6);

var client$6 = {};

var cjs$p = {};

var core$9 = {};

var pino$2 = {exports: {}};

var err = errSerializer$1;

const { toString: toString$9 } = Object.prototype;
const seen = Symbol('circular-ref-tag');
const rawSymbol$2 = Symbol('pino-raw-err-ref');
const pinoErrProto = Object.create({}, {
  type: {
    enumerable: true,
    writable: true,
    value: undefined
  },
  message: {
    enumerable: true,
    writable: true,
    value: undefined
  },
  stack: {
    enumerable: true,
    writable: true,
    value: undefined
  },
  raw: {
    enumerable: false,
    get: function () {
      return this[rawSymbol$2]
    },
    set: function (val) {
      this[rawSymbol$2] = val;
    }
  }
});
Object.defineProperty(pinoErrProto, rawSymbol$2, {
  writable: true,
  value: {}
});

function errSerializer$1 (err) {
  if (!(err instanceof Error)) {
    return err
  }

  err[seen] = undefined; // tag to prevent re-looking at this
  const _err = Object.create(pinoErrProto);
  _err.type = toString$9.call(err.constructor) === '[object Function]'
    ? err.constructor.name
    : err.name;
  _err.message = err.message;
  _err.stack = err.stack;
  for (const key in err) {
    if (_err[key] === undefined) {
      const val = err[key];
      if (val instanceof Error) {
        /* eslint-disable no-prototype-builtins */
        if (!val.hasOwnProperty(seen)) {
          _err[key] = errSerializer$1(val);
        }
      } else {
        _err[key] = val;
      }
    }
  }

  delete err[seen]; // clean up tag in case err is serialized again later
  _err.raw = err;
  return _err
}

var err$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), err, {
    'default': err
}));

var require$$0$F = /*@__PURE__*/getAugmentedNamespace(err$1);

var req = {
  mapHttpRequest: mapHttpRequest$1,
  reqSerializer
};

const rawSymbol$1 = Symbol('pino-raw-req-ref');
const pinoReqProto = Object.create({}, {
  id: {
    enumerable: true,
    writable: true,
    value: ''
  },
  method: {
    enumerable: true,
    writable: true,
    value: ''
  },
  url: {
    enumerable: true,
    writable: true,
    value: ''
  },
  query: {
    enumerable: true,
    writable: true,
    value: ''
  },
  params: {
    enumerable: true,
    writable: true,
    value: ''
  },
  headers: {
    enumerable: true,
    writable: true,
    value: {}
  },
  remoteAddress: {
    enumerable: true,
    writable: true,
    value: ''
  },
  remotePort: {
    enumerable: true,
    writable: true,
    value: ''
  },
  raw: {
    enumerable: false,
    get: function () {
      return this[rawSymbol$1]
    },
    set: function (val) {
      this[rawSymbol$1] = val;
    }
  }
});
Object.defineProperty(pinoReqProto, rawSymbol$1, {
  writable: true,
  value: {}
});

function reqSerializer (req) {
  // req.info is for hapi compat.
  const connection = req.info || req.socket;
  const _req = Object.create(pinoReqProto);
  _req.id = (typeof req.id === 'function' ? req.id() : (req.id || (req.info ? req.info.id : undefined)));
  _req.method = req.method;
  // req.originalUrl is for expressjs compat.
  if (req.originalUrl) {
    _req.url = req.originalUrl;
    _req.query = req.query;
    _req.params = req.params;
  } else {
    // req.url.path is  for hapi compat.
    _req.url = req.path || (req.url ? (req.url.path || req.url) : undefined);
  }
  _req.headers = req.headers;
  _req.remoteAddress = connection && connection.remoteAddress;
  _req.remotePort = connection && connection.remotePort;
  // req.raw is  for hapi compat/equivalence
  _req.raw = req.raw || req;
  return _req
}

function mapHttpRequest$1 (req) {
  return {
    req: reqSerializer(req)
  }
}

var req$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), req, {
    'default': req
}));

var require$$1$_ = /*@__PURE__*/getAugmentedNamespace(req$1);

var res = {
  mapHttpResponse: mapHttpResponse$1,
  resSerializer
};

const rawSymbol = Symbol('pino-raw-res-ref');
const pinoResProto = Object.create({}, {
  statusCode: {
    enumerable: true,
    writable: true,
    value: 0
  },
  headers: {
    enumerable: true,
    writable: true,
    value: ''
  },
  raw: {
    enumerable: false,
    get: function () {
      return this[rawSymbol]
    },
    set: function (val) {
      this[rawSymbol] = val;
    }
  }
});
Object.defineProperty(pinoResProto, rawSymbol, {
  writable: true,
  value: {}
});

function resSerializer (res) {
  const _res = Object.create(pinoResProto);
  _res.statusCode = res.statusCode;
  _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
  _res.raw = res;
  return _res
}

function mapHttpResponse$1 (res) {
  return {
    res: resSerializer(res)
  }
}

var res$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), res, {
    'default': res
}));

var require$$2$H = /*@__PURE__*/getAugmentedNamespace(res$1);

const errSerializer = require$$0$F;
const reqSerializers = require$$1$_;
const resSerializers = require$$2$H;

var pinoStdSerializers = {
  err: errSerializer,
  mapHttpRequest: reqSerializers.mapHttpRequest,
  mapHttpResponse: resSerializers.mapHttpResponse,
  req: reqSerializers.reqSerializer,
  res: resSerializers.resSerializer,

  wrapErrorSerializer: function wrapErrorSerializer (customSerializer) {
    if (customSerializer === errSerializer) return customSerializer
    return function wrapErrSerializer (err) {
      return customSerializer(errSerializer(err))
    }
  },

  wrapRequestSerializer: function wrapRequestSerializer (customSerializer) {
    if (customSerializer === reqSerializers.reqSerializer) return customSerializer
    return function wrappedReqSerializer (req) {
      return customSerializer(reqSerializers.reqSerializer(req))
    }
  },

  wrapResponseSerializer: function wrapResponseSerializer (customSerializer) {
    if (customSerializer === resSerializers.resSerializer) return customSerializer
    return function wrappedResSerializer (res) {
      return customSerializer(resSerializers.resSerializer(res))
    }
  }
};

var pinoStdSerializers$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pinoStdSerializers, {
    'default': pinoStdSerializers
}));

var require$$1$Z = /*@__PURE__*/getAugmentedNamespace(pinoStdSerializers$1);

const { createContext: createContext$1, runInContext } = require$$0$$;

var validator_1 = validator$2;

function validator$2 (opts = {}) {
  const {
    ERR_PATHS_MUST_BE_STRINGS = () => 'fast-redact - Paths must be (non-empty) strings',
    ERR_INVALID_PATH = (s) => `fast-redact – Invalid path (${s})`
  } = opts;

  return function validate ({ paths }) {
    paths.forEach((s) => {
      if (typeof s !== 'string') {
        throw Error(ERR_PATHS_MUST_BE_STRINGS())
      }
      try {
        if (/〇/.test(s)) throw Error()
        const proxy = new Proxy({}, { get: () => proxy, set: () => { throw Error() } });
        const expr = (s[0] === '[' ? '' : '.') + s.replace(/^\*/, '〇').replace(/\.\*/g, '.〇').replace(/\[\*\]/g, '[〇]');
        if (/\n|\r|;/.test(expr)) throw Error()
        if (/\/\*/.test(expr)) throw Error()
        runInContext(`
          (function () {
            'use strict'
            o${expr}
            if ([o${expr}].length !== 1) throw Error()
          })()
        `, createContext$1({ o: proxy, 〇: null }), {
          codeGeneration: { strings: false, wasm: false }
        });
      } catch (e) {
        throw Error(ERR_INVALID_PATH(s))
      }
    });
  }
}

var validator$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), validator_1, {
    'default': validator_1
}));

var require$$0$E = /*@__PURE__*/getAugmentedNamespace(validator$3);

var rx$4 = /[^.[\]]+|\[((?:.)*?)\]/g;

var rx$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), rx$4, {
    'default': rx$4
}));

var require$$6$g = /*@__PURE__*/getAugmentedNamespace(rx$5);

const rx$3 = require$$6$g;

var parse_1 = parse$2;

function parse$2 ({ paths }) {
  const wildcards = [];
  var wcLen = 0;
  const secret = paths.reduce(function (o, strPath, ix) {
    var path = strPath.match(rx$3).map((p) => p.replace(/'|"|`/g, ''));
    const leadingBracket = strPath[0] === '[';
    path = path.map((p) => {
      if (p[0] === '[') return p.substr(1, p.length - 2)
      else return p
    });
    const star = path.indexOf('*');
    if (star > -1) {
      const before = path.slice(0, star);
      const beforeStr = before.join('.');
      const after = path.slice(star + 1, path.length);
      const nested = after.length > 0;
      wcLen++;
      wildcards.push({
        before,
        beforeStr,
        after,
        nested
      });
    } else {
      o[strPath] = {
        path: path,
        val: undefined,
        precensored: false,
        circle: '',
        escPath: JSON.stringify(strPath),
        leadingBracket: leadingBracket
      };
    }
    return o
  }, {});

  return { wildcards, wcLen, secret }
}

var parse$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), parse_1, {
    'default': parse_1
}));

var require$$1$Y = /*@__PURE__*/getAugmentedNamespace(parse$3);

const rx$2 = require$$6$g;

var redactor_1 = redactor$1;

function redactor$1 ({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
  /* eslint-disable-next-line */
  const redact = Function('o', `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    ${resultTmpl(serialize)}
  `).bind(state);

  if (serialize === false) {
    redact.restore = (o) => state.restore(o);
  }

  return redact
}

function redactTmpl (secret, isCensorFct, censorFctTakesPath) {
  return Object.keys(secret).map((path) => {
    const { escPath, leadingBracket, path: arrPath } = secret[path];
    const skip = leadingBracket ? 1 : 0;
    const delim = leadingBracket ? '' : '.';
    const hops = [];
    var match;
    while ((match = rx$2.exec(path)) !== null) {
      const [ , ix ] = match;
      const { index, input } = match;
      if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
    }
    var existence = hops.map((p) => `o${delim}${p}`).join(' && ');
    if (existence.length === 0) existence += `o${delim}${path} != null`;
    else existence += ` && o${delim}${path} != null`;

    const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join('\n')}
      }
    `;

    const censorArgs = censorFctTakesPath
      ? `val, ${JSON.stringify(arrPath)}`
      : `val`;

    return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : 'censor'}
          ${circularDetection}
        }
      }
    `
  }).join('\n')
}

function dynamicRedactTmpl (hasWildcards, isCensorFct, censorFctTakesPath) {
  return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : ''
}

function resultTmpl (serialize) {
  return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `
}

function strictImpl (strict, serialize) {
  return strict === true
    ? `throw Error('fast-redact: primitives cannot be redacted')`
    : serialize === false ? `return o` : `return this.serialize(o)`
}

var redactor$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), redactor_1, {
    'default': redactor_1
}));

var require$$2$G = /*@__PURE__*/getAugmentedNamespace(redactor$2);

var modifiers = {
  groupRedact: groupRedact$1,
  groupRestore: groupRestore$1,
  nestedRedact: nestedRedact$1,
  nestedRestore: nestedRestore$1
};

function groupRestore$1 ({ keys, values, target }) {
  if (target == null) return
  const length = keys.length;
  for (var i = 0; i < length; i++) {
    const k = keys[i];
    target[k] = values[i];
  }
}

function groupRedact$1 (o, path, censor, isCensorFct, censorFctTakesPath) {
  const target = get(o, path);
  if (target == null) return { keys: null, values: null, target: null, flat: true }
  const keys = Object.keys(target);
  const keysLength = keys.length;
  const pathLength = path.length;
  const pathWithKey = censorFctTakesPath ? [...path] : undefined;
  const values = new Array(keysLength);

  for (var i = 0; i < keysLength; i++) {
    const key = keys[i];
    values[i] = target[key];

    if (censorFctTakesPath) {
      pathWithKey[pathLength] = key;
      target[key] = censor(target[key], pathWithKey);
    } else if (isCensorFct) {
      target[key] = censor(target[key]);
    } else {
      target[key] = censor;
    }
  }
  return { keys, values, target, flat: true }
}

function nestedRestore$1 (arr) {
  const length = arr.length;
  for (var i = 0; i < length; i++) {
    const { key, target, value } = arr[i];
    if (has(target, key)) {
      target[key] = value;
    }
    /* istanbul ignore else */
    if (typeof target === 'object') {
      const targetKeys = Object.keys(target);
      for (var j = 0; j < targetKeys.length; j++) {
        const tKey = targetKeys[j];
        const subTarget = target[tKey];
        if (has(subTarget, key)) {
          subTarget[key] = value;
        }
      }
    }
  }
}

function nestedRedact$1 (store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
  const target = get(o, path);
  if (target == null) return
  const keys = Object.keys(target);
  const keysLength = keys.length;
  for (var i = 0; i < keysLength; i++) {
    const key = keys[i];
    const { value, parent, exists } =
      specialSet(target, key, path, ns, censor, isCensorFct, censorFctTakesPath);

    if (exists === true && parent !== null) {
      store.push({ key: ns[ns.length - 1], target: parent, value });
    }
  }
  return store
}

function has (obj, prop) {
  return obj !== undefined && obj !== null
    ? ('hasOwn' in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop))
    : false
}

function specialSet (o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
  const afterPathLen = afterPath.length;
  const lastPathIndex = afterPathLen - 1;
  const originalKey = k;
  var i = -1;
  var n;
  var nv;
  var ov;
  var oov = null;
  var exists = true;
  var wc = null;
  ov = n = o[k];
  if (typeof n !== 'object') return { value: null, parent: null, exists }
  while (n != null && ++i < afterPathLen) {
    k = afterPath[i];
    oov = ov;
    if (k !== '*' && !wc && !(typeof n === 'object' && k in n)) {
      exists = false;
      break
    }
    if (k === '*') {
      wc = k;
      if (i !== lastPathIndex) {
        continue
      }
    }
    if (wc) {
      const wcKeys = Object.keys(n);
      for (var j = 0; j < wcKeys.length; j++) {
        const wck = wcKeys[j];
        const wcov = n[wck];
        const kIsWc = k === '*';
        if (kIsWc || (typeof wcov === 'object' && wcov !== null && k in wcov)) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = (i !== lastPathIndex)
            ? ov
            : (isCensorFct
              ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
              : censor);
          if (kIsWc) {
            n[wck] = nv;
          } else {
            if (wcov[k] === nv) {
              exists = false;
            } else {
              wcov[k] = (nv === undefined && censor !== undefined) || (has(wcov, k) && nv === ov) ? wcov[k] : nv;
            }
          }
        }
      }
      wc = null;
    } else {
      ov = n[k];
      nv = (i !== lastPathIndex)
        ? ov
        : (isCensorFct
          ? (censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov))
          : censor);
      n[k] = (has(n, k) && nv === ov) || (nv === undefined && censor !== undefined) ? n[k] : nv;
      n = n[k];
    }
    if (typeof n !== 'object') break
    // prevent circular structure, see https://github.com/pinojs/pino/issues/1513
    if (ov === oov) {
      exists = false;
    }
  }
  return { value: ov, parent: oov, exists }
}

function get (o, p) {
  var i = -1;
  var l = p.length;
  var n = o;
  while (n != null && ++i < l) {
    n = n[p[i]];
  }
  return n
}

var modifiers$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), modifiers, {
    'default': modifiers
}));

var require$$4$n = /*@__PURE__*/getAugmentedNamespace(modifiers$1);

const { groupRestore, nestedRestore } = require$$4$n;

var restorer_1 = restorer$1;

function restorer$1 ({ secret, wcLen }) {
  return function compileRestore () {
    if (this.restore) return
    const paths = Object.keys(secret);
    const resetters = resetTmpl(secret, paths);
    const hasWildcards = wcLen > 0;
    const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
    /* eslint-disable-next-line */
    this.restore = Function(
      'o',
      restoreTmpl(resetters, paths, hasWildcards)
    ).bind(state);
  }
}

/**
 * Mutates the original object to be censored by restoring its original values
 * prior to censoring.
 *
 * @param {object} secret Compiled object describing which target fields should
 * be censored and the field states.
 * @param {string[]} paths The list of paths to censor as provided at
 * initialization time.
 *
 * @returns {string} String of JavaScript to be used by `Function()`. The
 * string compiles to the function that does the work in the description.
 */
function resetTmpl (secret, paths) {
  return paths.map((path) => {
    const { circle, escPath, leadingBracket } = secret[path];
    const delim = leadingBracket ? '' : '.';
    const reset = circle
      ? `o.${circle} = secret[${escPath}].val`
      : `o${delim}${path} = secret[${escPath}].val`;
    const clear = `secret[${escPath}].val = undefined`;
    return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `
  }).join('')
}

/**
 * Creates the body of the restore function
 *
 * Restoration of the redacted object happens
 * backwards, in reverse order of redactions,
 * so that repeated redactions on the same object
 * property can be eventually rolled back to the
 * original value.
 *
 * This way dynamic redactions are restored first,
 * starting from the last one working backwards and
 * followed by the static ones.
 *
 * @returns {string} the body of the restore function
 */
function restoreTmpl (resetters, paths, hasWildcards) {
  const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : '';

  return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `
}

var restorer$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), restorer_1, {
    'default': restorer_1
}));

var require$$3$y = /*@__PURE__*/getAugmentedNamespace(restorer$2);

var state_1 = state$1;

function state$1 (o) {
  const {
    secret,
    censor,
    compileRestore,
    serialize,
    groupRedact,
    nestedRedact,
    wildcards,
    wcLen
  } = o;
  const builder = [{ secret, censor, compileRestore }];
  if (serialize !== false) builder.push({ serialize });
  if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
  return Object.assign(...builder)
}

var state$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), state_1, {
    'default': state_1
}));

var require$$5$k = /*@__PURE__*/getAugmentedNamespace(state$2);

const validator$1 = require$$0$E;
const parse$1 = require$$1$Y;
const redactor = require$$2$G;
const restorer = require$$3$y;
const { groupRedact, nestedRedact } = require$$4$n;
const state = require$$5$k;
const rx$1 = require$$6$g;
const validate$1 = validator$1();
const noop$3 = (o) => o;
noop$3.restore = noop$3;

const DEFAULT_CENSOR = '[REDACTED]';
fastRedact$1.rx = rx$1;
fastRedact$1.validator = validator$1;

var fastRedact_1 = fastRedact$1;

function fastRedact$1 (opts = {}) {
  const paths = Array.from(new Set(opts.paths || []));
  const serialize = 'serialize' in opts ? (
    opts.serialize === false ? opts.serialize
      : (typeof opts.serialize === 'function' ? opts.serialize : JSON.stringify)
  ) : JSON.stringify;
  const remove = opts.remove;
  if (remove === true && serialize !== JSON.stringify) {
    throw Error('fast-redact – remove option may only be set when serializer is JSON.stringify')
  }
  const censor = remove === true
    ? undefined
    : 'censor' in opts ? opts.censor : DEFAULT_CENSOR;

  const isCensorFct = typeof censor === 'function';
  const censorFctTakesPath = isCensorFct && censor.length > 1;

  if (paths.length === 0) return serialize || noop$3

  validate$1({ paths, serialize, censor });

  const { wildcards, wcLen, secret } = parse$1({ paths, censor });

  const compileRestore = restorer({ secret, wcLen });
  const strict = 'strict' in opts ? opts.strict : true;

  return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
    secret,
    censor,
    compileRestore,
    serialize,
    groupRedact,
    nestedRedact,
    wildcards,
    wcLen
  }))
}

var fastRedact$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), fastRedact_1, {
    'default': fastRedact_1
}));

var require$$0$D = /*@__PURE__*/getAugmentedNamespace(fastRedact$2);

const setLevelSym$2 = Symbol('pino.setLevel');
const getLevelSym$1 = Symbol('pino.getLevel');
const levelValSym$2 = Symbol('pino.levelVal');
const useLevelLabelsSym = Symbol('pino.useLevelLabels');
const useOnlyCustomLevelsSym$3 = Symbol('pino.useOnlyCustomLevels');
const mixinSym$2 = Symbol('pino.mixin');

const lsCacheSym$3 = Symbol('pino.lsCache');
const chindingsSym$3 = Symbol('pino.chindings');
const parsedChindingsSym$2 = Symbol('pino.parsedChindings');

const asJsonSym$1 = Symbol('pino.asJson');
const writeSym$2 = Symbol('pino.write');
const redactFmtSym$4 = Symbol('pino.redactFmt');

const timeSym$2 = Symbol('pino.time');
const timeSliceIndexSym$2 = Symbol('pino.timeSliceIndex');
const streamSym$4 = Symbol('pino.stream');
const stringifySym$3 = Symbol('pino.stringify');
const stringifiersSym$3 = Symbol('pino.stringifiers');
const endSym$2 = Symbol('pino.end');
const formatOptsSym$3 = Symbol('pino.formatOpts');
const messageKeySym$2 = Symbol('pino.messageKey');
const nestedKeySym$2 = Symbol('pino.nestedKey');
const mixinMergeStrategySym$2 = Symbol('pino.mixinMergeStrategy');

const wildcardFirstSym$2 = Symbol('pino.wildcardFirst');

// public symbols, no need to use the same pino
// version for these
const serializersSym$3 = Symbol.for('pino.serializers');
const formattersSym$4 = Symbol.for('pino.formatters');
const hooksSym$2 = Symbol.for('pino.hooks');
const needsMetadataGsym$2 = Symbol.for('pino.metadata');

var symbols$1 = {
  setLevelSym: setLevelSym$2,
  getLevelSym: getLevelSym$1,
  levelValSym: levelValSym$2,
  useLevelLabelsSym,
  mixinSym: mixinSym$2,
  lsCacheSym: lsCacheSym$3,
  chindingsSym: chindingsSym$3,
  parsedChindingsSym: parsedChindingsSym$2,
  asJsonSym: asJsonSym$1,
  writeSym: writeSym$2,
  serializersSym: serializersSym$3,
  redactFmtSym: redactFmtSym$4,
  timeSym: timeSym$2,
  timeSliceIndexSym: timeSliceIndexSym$2,
  streamSym: streamSym$4,
  stringifySym: stringifySym$3,
  stringifiersSym: stringifiersSym$3,
  endSym: endSym$2,
  formatOptsSym: formatOptsSym$3,
  messageKeySym: messageKeySym$2,
  nestedKeySym: nestedKeySym$2,
  wildcardFirstSym: wildcardFirstSym$2,
  needsMetadataGsym: needsMetadataGsym$2,
  useOnlyCustomLevelsSym: useOnlyCustomLevelsSym$3,
  formattersSym: formattersSym$4,
  hooksSym: hooksSym$2,
  mixinMergeStrategySym: mixinMergeStrategySym$2
};

var symbols$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), symbols$1, {
    'default': symbols$1
}));

var require$$5$j = /*@__PURE__*/getAugmentedNamespace(symbols$2);

const fastRedact = require$$0$D;
const { redactFmtSym: redactFmtSym$3, wildcardFirstSym: wildcardFirstSym$1 } = require$$5$j;
const { rx, validator } = fastRedact;

const validate = validator({
  ERR_PATHS_MUST_BE_STRINGS: () => 'pino – redacted paths must be strings',
  ERR_INVALID_PATH: (s) => `pino – redact paths array contains an invalid path (${s})`
});

const CENSOR = '[Redacted]';
const strict = false; // TODO should this be configurable?

function redaction$2 (opts, serialize) {
  const { paths, censor } = handle(opts);

  const shape = paths.reduce((o, str) => {
    rx.lastIndex = 0;
    const first = rx.exec(str);
    const next = rx.exec(str);

    // ns is the top-level path segment, brackets + quoting removed.
    let ns = first[1] !== undefined
      ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, '$1')
      : first[0];

    if (ns === '*') {
      ns = wildcardFirstSym$1;
    }

    // top level key:
    if (next === null) {
      o[ns] = null;
      return o
    }

    // path with at least two segments:
    // if ns is already redacted at the top level, ignore lower level redactions
    if (o[ns] === null) {
      return o
    }

    const { index } = next;
    const nextPath = `${str.substr(index, str.length - 1)}`;

    o[ns] = o[ns] || [];

    // shape is a mix of paths beginning with literal values and wildcard
    // paths [ "a.b.c", "*.b.z" ] should reduce to a shape of
    // { "a": [ "b.c", "b.z" ], *: [ "b.z" ] }
    // note: "b.z" is in both "a" and * arrays because "a" matches the wildcard.
    // (* entry has wildcardFirstSym as key)
    if (ns !== wildcardFirstSym$1 && o[ns].length === 0) {
      // first time ns's get all '*' redactions so far
      o[ns].push(...(o[wildcardFirstSym$1] || []));
    }

    if (ns === wildcardFirstSym$1) {
      // new * path gets added to all previously registered literal ns's.
      Object.keys(o).forEach(function (k) {
        if (o[k]) {
          o[k].push(nextPath);
        }
      });
    }

    o[ns].push(nextPath);
    return o
  }, {});

  // the redactor assigned to the format symbol key
  // provides top level redaction for instances where
  // an object is interpolated into the msg string
  const result = {
    [redactFmtSym$3]: fastRedact({ paths, censor, serialize, strict })
  };

  const topCensor = (...args) => {
    return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor)
  };

  return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
    // top level key:
    if (shape[k] === null) {
      o[k] = (value) => topCensor(value, [k]);
    } else {
      const wrappedCensor = typeof censor === 'function'
        ? (value, path) => {
            return censor(value, [k, ...path])
          }
        : censor;
      o[k] = fastRedact({
        paths: shape[k],
        censor: wrappedCensor,
        serialize,
        strict
      });
    }
    return o
  }, result)
}

function handle (opts) {
  if (Array.isArray(opts)) {
    opts = { paths: opts, censor: CENSOR };
    validate(opts);
    return opts
  }
  let { paths, censor = CENSOR, remove } = opts;
  if (Array.isArray(paths) === false) { throw Error('pino – redact must contain an array of strings') }
  if (remove === true) censor = undefined;
  validate({ paths, censor });

  return { paths, censor }
}

var redaction_1 = redaction$2;

var redaction$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), redaction_1, {
    'default': redaction_1
}));

var require$$2$F = /*@__PURE__*/getAugmentedNamespace(redaction$3);

const nullTime$1 = () => '';

const epochTime$1 = () => `,"time":${Date.now()}`;

const unixTime = () => `,"time":${Math.round(Date.now() / 1000.0)}`;

const isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`; // using Date.now() for testability

var time$4 = { nullTime: nullTime$1, epochTime: epochTime$1, unixTime, isoTime };

var time$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), time$4, {
    'default': time$4
}));

var require$$3$x = /*@__PURE__*/getAugmentedNamespace(time$5);

// You may be tempted to copy and paste this, 
// but take a look at the commit history first,
// this is a moving target so relying on the module
// is the best way to make sure the optimization
// method is kept up to date and compatible with
// every Node version.

function flatstr$3 (s) {
  return s
}

var flatstr_1 = flatstr$3;

var flatstr$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), flatstr_1, {
    'default': flatstr_1
}));

var require$$2$E = /*@__PURE__*/getAugmentedNamespace(flatstr$4);

var atomicSleep$2 = {exports: {}};

/* global SharedArrayBuffer, Atomics */

if (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {
  const nil = new Int32Array(new SharedArrayBuffer(4));

  function sleep (ms) {
    // also filters out NaN, non-number types, including empty strings, but allows bigints
    const valid = ms > 0 && ms < Infinity; 
    if (valid === false) {
      if (typeof ms !== 'number' && typeof ms !== 'bigint') {
        throw TypeError('sleep: ms must be a number')
      }
      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')
    }

    Atomics.wait(nil, 0, 0, Number(ms));
  }
  atomicSleep$2.exports = sleep;
} else {

  function sleep (ms) {
    // also filters out NaN, non-number types, including empty strings, but allows bigints
    const valid = ms > 0 && ms < Infinity; 
    if (valid === false) {
      if (typeof ms !== 'number' && typeof ms !== 'bigint') {
        throw TypeError('sleep: ms must be a number')
      }
      throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity')
    }
  }

  atomicSleep$2.exports = sleep;

}

var atomicSleep = atomicSleep$2.exports;

var atomicSleep$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), atomicSleep$2.exports, {
    'default': atomicSleep
}));

var require$$4$m = /*@__PURE__*/getAugmentedNamespace(atomicSleep$1);

const fs = require$$0$11;
const EventEmitter$1 = require$$1$19;
const flatstr$2 = require$$2$E;
const inherits = require$$0$10.inherits;

const BUSY_WRITE_TIMEOUT = 100;

const sleep = require$$4$m;

// 16 MB - magic number
// This constant ensures that SonicBoom only needs
// 32 MB of free memory to run. In case of having 1GB+
// of data to write, this prevents an out of memory
// condition.
const MAX_WRITE = 16 * 1024 * 1024;

function openFile (file, sonic) {
  sonic._opening = true;
  sonic._writing = true;
  sonic._asyncDrainScheduled = false;

  // NOTE: 'error' and 'ready' events emitted below only relevant when sonic.sync===false
  // for sync mode, there is no way to add a listener that will receive these

  function fileOpened (err, fd) {
    if (err) {
      sonic._reopening = false;
      sonic._writing = false;
      sonic._opening = false;

      if (sonic.sync) {
        browser$1$1.nextTick(() => {
          if (sonic.listenerCount('error') > 0) {
            sonic.emit('error', err);
          }
        });
      } else {
        sonic.emit('error', err);
      }
      return
    }

    sonic.fd = fd;
    sonic.file = file;
    sonic._reopening = false;
    sonic._opening = false;
    sonic._writing = false;

    if (sonic.sync) {
      browser$1$1.nextTick(() => sonic.emit('ready'));
    } else {
      sonic.emit('ready');
    }

    if (sonic._reopening) {
      return
    }

    // start
    const len = sonic._buf.length;
    if (len > 0 && len > sonic.minLength && !sonic.destroyed) {
      actualWrite(sonic);
    }
  }

  if (sonic.sync) {
    try {
      const fd = fs.openSync(file, 'a');
      fileOpened(null, fd);
    } catch (err) {
      fileOpened(err);
      throw err
    }
  } else {
    fs.open(file, 'a', fileOpened);
  }
}

function SonicBoom$2 (opts) {
  if (!(this instanceof SonicBoom$2)) {
    return new SonicBoom$2(opts)
  }

  let { fd, dest, minLength, sync } = opts || {};

  fd = fd || dest;

  this._buf = '';
  this.fd = -1;
  this._writing = false;
  this._writingBuf = '';
  this._ending = false;
  this._reopening = false;
  this._asyncDrainScheduled = false;
  this.file = null;
  this.destroyed = false;
  this.sync = sync || false;

  this.minLength = minLength || 0;

  if (typeof fd === 'number') {
    this.fd = fd;
    browser$1$1.nextTick(() => this.emit('ready'));
  } else if (typeof fd === 'string') {
    openFile(fd, this);
  } else {
    throw new Error('SonicBoom supports only file descriptors and files')
  }

  this.release = (err, n) => {
    if (err) {
      if (err.code === 'EAGAIN') {
        if (this.sync) {
          // This error code should not happen in sync mode, because it is
          // not using the underlining operating system asynchronous functions.
          // However it happens, and so we handle it.
          // Ref: https://github.com/pinojs/pino/issues/783
          try {
            sleep(BUSY_WRITE_TIMEOUT);
            this.release(undefined, 0);
          } catch (err) {
            this.release(err);
          }
        } else {
          // Let's give the destination some time to process the chunk.
          setTimeout(() => {
            fs.write(this.fd, this._writingBuf, 'utf8', this.release);
          }, BUSY_WRITE_TIMEOUT);
        }
      } else {
        // The error maybe recoverable later, so just put data back to this._buf
        this._buf = this._writingBuf + this._buf;
        this._writingBuf = '';
        this._writing = false;

        this.emit('error', err);
      }
      return
    }

    if (this._writingBuf.length !== n) {
      this._writingBuf = this._writingBuf.slice(n);
      if (this.sync) {
        try {
          do {
            n = fs.writeSync(this.fd, this._writingBuf, 'utf8');
            this._writingBuf = this._writingBuf.slice(n);
          } while (this._writingBuf.length !== 0)
        } catch (err) {
          this.release(err);
          return
        }
      } else {
        fs.write(this.fd, this._writingBuf, 'utf8', this.release);
        return
      }
    }

    this._writingBuf = '';

    if (this.destroyed) {
      return
    }

    const len = this._buf.length;
    if (this._reopening) {
      this._writing = false;
      this._reopening = false;
      this.reopen();
    } else if (len > 0 && len > this.minLength) {
      actualWrite(this);
    } else if (this._ending) {
      if (len > 0) {
        actualWrite(this);
      } else {
        this._writing = false;
        actualClose(this);
      }
    } else {
      this._writing = false;
      if (this.sync) {
        if (!this._asyncDrainScheduled) {
          this._asyncDrainScheduled = true;
          browser$1$1.nextTick(emitDrain, this);
        }
      } else {
        this.emit('drain');
      }
    }
  };

  this.on('newListener', function (name) {
    if (name === 'drain') {
      this._asyncDrainScheduled = false;
    }
  });
}

function emitDrain (sonic) {
  const hasListeners = sonic.listenerCount('drain') > 0;
  if (!hasListeners) return
  sonic._asyncDrainScheduled = false;
  sonic.emit('drain');
}

inherits(SonicBoom$2, EventEmitter$1);

SonicBoom$2.prototype.write = function (data) {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  this._buf += data;
  const len = this._buf.length;
  if (!this._writing && len > this.minLength) {
    actualWrite(this);
  }
  return len < 16384
};

SonicBoom$2.prototype.flush = function () {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  if (this._writing || this.minLength <= 0) {
    return
  }

  actualWrite(this);
};

SonicBoom$2.prototype.reopen = function (file) {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  if (this._opening) {
    this.once('ready', () => {
      this.reopen(file);
    });
    return
  }

  if (this._ending) {
    return
  }

  if (!this.file) {
    throw new Error('Unable to reopen a file descriptor, you must pass a file to SonicBoom')
  }

  this._reopening = true;

  if (this._writing) {
    return
  }

  const fd = this.fd;
  this.once('ready', () => {
    if (fd !== this.fd) {
      fs.close(fd, (err) => {
        if (err) {
          return this.emit('error', err)
        }
      });
    }
  });

  openFile(file || this.file, this);
};

SonicBoom$2.prototype.end = function () {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  if (this._opening) {
    this.once('ready', () => {
      this.end();
    });
    return
  }

  if (this._ending) {
    return
  }

  this._ending = true;

  if (!this._writing && this._buf.length > 0 && this.fd >= 0) {
    actualWrite(this);
    return
  }

  if (this._writing) {
    return
  }

  actualClose(this);
};

SonicBoom$2.prototype.flushSync = function () {
  if (this.destroyed) {
    throw new Error('SonicBoom destroyed')
  }

  if (this.fd < 0) {
    throw new Error('sonic boom is not ready yet')
  }

  while (this._buf.length > 0) {
    try {
      fs.writeSync(this.fd, this._buf, 'utf8');
      this._buf = '';
    } catch (err) {
      if (err.code !== 'EAGAIN') {
        throw err
      }

      sleep(BUSY_WRITE_TIMEOUT);
    }
  }
};

SonicBoom$2.prototype.destroy = function () {
  if (this.destroyed) {
    return
  }
  actualClose(this);
};

function actualWrite (sonic) {
  sonic._writing = true;
  let buf = sonic._buf;
  const release = sonic.release;
  if (buf.length > MAX_WRITE) {
    buf = buf.slice(0, MAX_WRITE);
    sonic._buf = sonic._buf.slice(MAX_WRITE);
  } else {
    sonic._buf = '';
  }
  flatstr$2(buf);
  sonic._writingBuf = buf;
  if (sonic.sync) {
    try {
      const written = fs.writeSync(sonic.fd, buf, 'utf8');
      release(null, written);
    } catch (err) {
      release(err);
    }
  } else {
    fs.write(sonic.fd, buf, 'utf8', release);
  }
}

function actualClose (sonic) {
  if (sonic.fd === -1) {
    sonic.once('ready', actualClose.bind(null, sonic));
    return
  }
  // TODO write a test to check if we are not leaking fds
  fs.close(sonic.fd, (err) => {
    if (err) {
      sonic.emit('error', err);
      return
    }

    if (sonic._ending && !sonic._writing) {
      sonic.emit('finish');
    }
    sonic.emit('close');
  });
  sonic.destroyed = true;
  sonic._buf = '';
}

var sonicBoom = SonicBoom$2;

var sonicBoom$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), sonicBoom, {
    'default': sonicBoom
}));

var require$$1$X = /*@__PURE__*/getAugmentedNamespace(sonicBoom$1);

const { format: format$2 } = require$$0$10;

function build () {
  const codes = {};
  const emitted = new Map();

  function create (name, code, message) {
    if (!name) throw new Error('Warning name must not be empty')
    if (!code) throw new Error('Warning code must not be empty')
    if (!message) throw new Error('Warning message must not be empty')

    code = code.toUpperCase();

    if (codes[code] !== undefined) {
      throw new Error(`The code '${code}' already exist`)
    }

    function buildWarnOpts (a, b, c) {
      // more performant than spread (...) operator
      let formatted;
      if (a && b && c) {
        formatted = format$2(message, a, b, c);
      } else if (a && b) {
        formatted = format$2(message, a, b);
      } else if (a) {
        formatted = format$2(message, a);
      } else {
        formatted = message;
      }

      return {
        code,
        name,
        message: formatted
      }
    }

    emitted.set(code, false);
    codes[code] = buildWarnOpts;

    return codes[code]
  }

  function emit (code, a, b, c) {
    if (codes[code] === undefined) throw new Error(`The code '${code}' does not exist`)
    if (emitted.get(code) === true) return
    emitted.set(code, true);

    const warning = codes[code](a, b, c);
    browser$1$1.emitWarning(warning.message, warning.name, warning.code);
  }

  return {
    create,
    emit,
    emitted
  }
}

var processWarning = build;

var processWarning$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), processWarning, {
    'default': processWarning
}));

var require$$0$C = /*@__PURE__*/getAugmentedNamespace(processWarning$1);

const warning$1 = require$$0$C();
var deprecations = warning$1;

const warnName = 'PinoWarning';

warning$1.create(warnName, 'PINODEP004', 'bindings.serializers is deprecated, use options.serializers option instead');

warning$1.create(warnName, 'PINODEP005', 'bindings.formatters is deprecated, use options.formatters option instead');

warning$1.create(warnName, 'PINODEP006', 'bindings.customLevels is deprecated, use options.customLevels option instead');

warning$1.create(warnName, 'PINODEP007', 'bindings.level is deprecated, use options.level option instead');

var deprecations$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), deprecations, {
    'default': deprecations
}));

var require$$3$w = /*@__PURE__*/getAugmentedNamespace(deprecations$1);

function tryStringify (o) {
  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
}

var quickFormatUnescaped = format$1;

function format$1(f, args, opts) {
  var ss = (opts && opts.stringify) || tryStringify;
  var offset = 1;
  if (typeof f === 'object' && f !== null) {
    var len = args.length + offset;
    if (len === 1) return f
    var objects = new Array(len);
    objects[0] = ss(f);
    for (var index = 1; index < len; index++) {
      objects[index] = ss(args[index]);
    }
    return objects.join(' ')
  }
  if (typeof f !== 'string') {
    return f
  }
  var argLen = args.length;
  if (argLen === 0) return f
  var str = '';
  var a = 1 - offset;
  var lastPos = -1;
  var flen = (f && f.length) || 0;
  for (var i = 0; i < flen;) {
    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
      lastPos = lastPos > -1 ? lastPos : 0;
      switch (f.charCodeAt(i + 1)) {
        case 100: // 'd'
        case 102: // 'f'
          if (a >= argLen)
            break
          if (args[a] == null)  break
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += Number(args[a]);
          lastPos = i + 2;
          i++;
          break
        case 105: // 'i'
          if (a >= argLen)
            break
          if (args[a] == null)  break
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += Math.floor(Number(args[a]));
          lastPos = i + 2;
          i++;
          break
        case 79: // 'O'
        case 111: // 'o'
        case 106: // 'j'
          if (a >= argLen)
            break
          if (args[a] === undefined) break
          if (lastPos < i)
            str += f.slice(lastPos, i);
          var type = typeof args[a];
          if (type === 'string') {
            str += '\'' + args[a] + '\'';
            lastPos = i + 2;
            i++;
            break
          }
          if (type === 'function') {
            str += args[a].name || '<anonymous>';
            lastPos = i + 2;
            i++;
            break
          }
          str += ss(args[a]);
          lastPos = i + 2;
          i++;
          break
        case 115: // 's'
          if (a >= argLen)
            break
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += String(args[a]);
          lastPos = i + 2;
          i++;
          break
        case 37: // '%'
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += '%';
          lastPos = i + 2;
          i++;
          a--;
          break
      }
      ++a;
    }
    ++i;
  }
  if (lastPos === -1)
    return f
  else if (lastPos < flen) {
    str += f.slice(lastPos);
  }

  return str
}

var quickFormatUnescaped$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), quickFormatUnescaped, {
    'default': quickFormatUnescaped
}));

var require$$0$B = /*@__PURE__*/getAugmentedNamespace(quickFormatUnescaped$1);

var fastSafeStringify = stringify$3;
stringify$3.default = stringify$3;
stringify$3.stable = deterministicStringify;
stringify$3.stableStringify = deterministicStringify;

var LIMIT_REPLACE_NODE = '[...]';
var CIRCULAR_REPLACE_NODE = '[Circular]';

var arr = [];
var replacerStack = [];

function defaultOptions$2 () {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  }
}

// Regular stringify
function stringify$3 (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions$2();
  }

  decirc(obj, '', 0, [], undefined, 0, options);
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res
}

function setReplace (replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}

function decirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return
      }
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return
    }

    stack.push(val);
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions$2();
  }

  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res
}

function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return
      }
    }
    try {
      if (typeof val.toJSON === 'function') {
        return
      }
    } catch (_) {
      return
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return
    }

    stack.push(val);
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {};
      var keys = Object.keys(val).sort(compareFunction);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        deterministicDecirc(val[key], key, i, stack, val, depth, options);
        tmp[key] = val[key];
      }
      if (typeof parent !== 'undefined') {
        arr.push([parent, k, val]);
        parent[k] = tmp;
      } else {
        return tmp
      }
    }
    stack.pop();
  }
}

// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues (replacer) {
  replacer =
    typeof replacer !== 'undefined'
      ? replacer
      : function (k, v) {
        return v
      };
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break
        }
      }
    }
    return replacer.call(this, key, val)
  }
}

var fastSafeStringify$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), fastSafeStringify, {
    'default': fastSafeStringify
}));

var require$$3$v = /*@__PURE__*/getAugmentedNamespace(fastSafeStringify$1);

var ansiStyles$3 = {exports: {}};

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var colorName$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), colorName, {
    'default': colorName
}));

var require$$0$A = /*@__PURE__*/getAugmentedNamespace(colorName$1);

/* MIT license */

/* eslint-disable no-mixed-operators */
const cssKeywords = require$$0$A;

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert$3 = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

var conversions$2 = convert$3;

// Hide .channels and .labels properties
for (const model of Object.keys(convert$3)) {
	if (!('channels' in convert$3[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert$3[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert$3[model].labels.length !== convert$3[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert$3[model];
	delete convert$3[model].channels;
	delete convert$3[model].labels;
	Object.defineProperty(convert$3[model], 'channels', {value: channels});
	Object.defineProperty(convert$3[model], 'labels', {value: labels});
}

convert$3.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert$3.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert$3.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert$3.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert$3.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert$3.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert$3.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert$3.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert$3.rgb.lab = function (rgb) {
	const xyz = convert$3.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$3.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert$3.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert$3.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert$3.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert$3.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert$3.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert$3.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert$3.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$3.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert$3.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert$3.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert$3.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert$3.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert$3.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert$3.rgb.ansi16(convert$3.hsv.rgb(args), args[2]);
};

convert$3.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert$3.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert$3.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert$3.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$3.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert$3.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert$3.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert$3.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert$3.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert$3.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert$3.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert$3.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$3.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert$3.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert$3.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert$3.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$3.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert$3.gray.hsv = convert$3.gray.hsl;

convert$3.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert$3.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert$3.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert$3.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$3.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

var conversions$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), conversions$2, {
    'default': conversions$2
}));

var require$$0$z = /*@__PURE__*/getAugmentedNamespace(conversions$3);

const conversions$1 = require$$0$z;

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions$1);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions$1[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions$1[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions$1[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route$1 = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

var route$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), route$1, {
    'default': route$1
}));

var require$$1$W = /*@__PURE__*/getAugmentedNamespace(route$2);

const conversions = require$$0$z;
const route = require$$1$W;

const convert$2 = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert$2[fromModel] = {};

	Object.defineProperty(convert$2[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert$2[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert$2[fromModel][toModel] = wrapRounded(fn);
		convert$2[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert$2;

var colorConvert$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), colorConvert, {
    'default': colorConvert
}));

var require$$0$y = /*@__PURE__*/getAugmentedNamespace(colorConvert$1);

(function (module) {

const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = require$$0$y;
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
}(ansiStyles$3));

var ansiStyles$1 = ansiStyles$3.exports;

var ansiStyles$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), ansiStyles$3.exports, {
    'default': ansiStyles$1
}));

var require$$0$x = /*@__PURE__*/getAugmentedNamespace(ansiStyles$2);

var hasFlag$1 = (flag, argv = browser$1$1.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};

var hasFlag$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), hasFlag$1, {
    'default': hasFlag$1
}));

var require$$2$D = /*@__PURE__*/getAugmentedNamespace(hasFlag$2);

const tty = require$$1$1a;
const hasFlag = require$$2$D;

const {env: env$4} = browser$1$1;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env$4) {
	if (env$4.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env$4.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env$4.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env$4.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env$4.TERM === 'dumb') {
		return min;
	}

	if ('CI' in env$4) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env$4) || env$4.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env$4) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$4.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env$4.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env$4) {
		const version = parseInt((env$4.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env$4.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env$4.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$4.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env$4) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

var supportsColor_1 = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};

var supportsColor$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), supportsColor_1, {
    'default': supportsColor_1
}));

var require$$1$V = /*@__PURE__*/getAugmentedNamespace(supportsColor$1);

const stringReplaceAll$1 = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

var util$5 = {
	stringReplaceAll: stringReplaceAll$1,
	stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
};

var util$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), util$5, {
    'default': util$5
}));

var require$$2$C = /*@__PURE__*/getAugmentedNamespace(util$6);

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape$1(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape$1(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

var templates = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape$1(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};

var templates$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), templates, {
    'default': templates
}));

var require$$3$u = /*@__PURE__*/getAugmentedNamespace(templates$1);

const ansiStyles = require$$0$x;
const {stdout: stdoutColor, stderr: stderrColor} = require$$1$V;
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = require$$2$C;

const {isArray: isArray$1} = Array;

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles$1 = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles$1[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles$1.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles$1[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles$1[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto$3 = Object.defineProperties(() => {}, {
	...styles$1,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray$1(arguments_[0]) && isArray$1(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto$3);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray$1(firstString) || !isArray$1(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = require$$3$u;
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles$1);

const chalk$2 = Chalk(); // eslint-disable-line new-cap
chalk$2.supportsColor = stdoutColor;
chalk$2.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk$2.stderr.supportsColor = stderrColor;

var source = chalk$2;

var source$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), source, {
    'default': source
}));

var require$$0$w = /*@__PURE__*/getAugmentedNamespace(source$1);

var jmespath$2 = {};

(function (exports) {
(function(exports) {

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    // Check the scalar case first.
    if (first === second) {
      return true;
    }

    // Check if they are the same type.
    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    // We know that first and second have the same type so we can just check the
    // first type from now on.
    if (isArray(first) === true) {
      // Short circuit if they're not the same length;
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      // An object is equal if it has the same key/value pairs.
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      // Now check that there aren't any keys in second that weren't
      // in first.
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {
    // From the spec:
    // A false value corresponds to the following values:
    // Empty list
    // Empty object
    // Empty string
    // False boolean
    // null value

    // First check the scalar values.
    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        // Check for an empty array.
        return true;
    } else if (isObject(obj)) {
        // Check for an empty object.
        for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  // Type constants used to define functions.
  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";

  // The "&", "[", "<", ">" tokens
  // are not in basicToken because
  // there are two token variants
  // ("&&", "[?", "<=", ">=").  This is specially handled
  // below.

  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  // No need to increment this._current.  This happens
                  // in _consumeLBracket
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  // Ignore whitespace.
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              // You can escape a double quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              // You can escape a single quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              // You can escape a literal char or you can escape the escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              // Try to JSON parse it as "<literal>"
              literal = JSON.parse("\"" + literalString + "\"");
          }
          // +1 gets us to the ending "`", +1 to move on to the next char.
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            } else {
                return node;
            }
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            } else {
                return this._parseMultiselectList();
            }
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            } else {
                // Creating a projection.
                this._advance();
                right = this._parseProjectionRHS(rbp);
                return {type: "ValueProjection", children: [left, right]};
            }
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            } else {
                this._match(TOK_STAR);
                this._match(TOK_RBRACKET);
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection", children: [left, right]};
            }
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value === null ) {
                  return null;
              } else if (isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              } else {
                return null;
              }
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              // Tag the node with a specific attribute so the type
              // checker verify the type.
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        // name: [function, <signature>]
        // The <signature> can be:
        //
        // {
        //   args: [[type1, type2], [type1, type2]],
        //   variadic: true|false
        // }
        //
        // Each arg in the arg list is a list of valid types
        // (if the function is overloaded and supports multiple
        // types.  If the type is "any" then no type checking
        // occurs on the argument.  Variadic is optional
        // and if not provided is assumed to be false.
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        // Validating the args requires validating
        // the correct arity and the correct type of each arg.
        // If the last argument is declared as variadic, then we need
        // a minimum number of args to be required.  Otherwise it has to
        // be an exact amount.
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + currentSpec +
                                " but received type " + actualType +
                                " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                // Otherwise we need to check subtypes.
                // I think this has potential to be improved.
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         // As far as I can tell, there's no way to get the length
         // of an object without O(n) iteration through the object.
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        // In order to get a stable sort out of an unstable
        // sort algorithm, we decorate/sort/undecorate (DSU)
        // by creating a new list of [index, element] pairs.
        // In the cmp function, if the evaluated elements are
        // equal, then the index will be used as the tiebreaker.
        // After the decorated list has been sorted, it will be
        // undecorated to extract the original elements.
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            // If they're equal compare the items by their
            // order to maintain relative order of equal keys
            // (i.e. to get a stable sort).
            return a[0] - b[0];
          }
        });
        // Undecorate: extract out the original list elements.
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      // This needs to be improved.  Both the interpreter and runtime depend on
      // each other.  The runtime needs the interpreter to support exprefs.
      // There's likely a clean way to avoid the cyclic dependency.
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})(exports);
}(jmespath$2));

var jmespath$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), jmespath$2, {
    'default': jmespath$2
}));

var require$$1$U = /*@__PURE__*/getAugmentedNamespace(jmespath$1);

var constants$j = {
  DATE_FORMAT: 'yyyy-mm-dd HH:MM:ss.l o',

  ERROR_LIKE_KEYS: ['err', 'error'],

  MESSAGE_KEY: 'msg',

  LEVEL_KEY: 'level',

  LEVEL_LABEL: 'levelLabel',

  TIMESTAMP_KEY: 'time',

  LEVELS: {
    default: 'USERLVL',
    60: 'FATAL',
    50: 'ERROR',
    40: 'WARN',
    30: 'INFO',
    20: 'DEBUG',
    10: 'TRACE'
  },

  LEVEL_NAMES: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },

  // Object keys that probably came from a logger like Pino or Bunyan.
  LOGGER_KEYS: [
    'pid',
    'hostname',
    'name',
    'level',
    'time',
    'timestamp',
    'caller'
  ]
};

var constants$k = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constants$j, {
    'default': constants$j
}));

var require$$3$t = /*@__PURE__*/getAugmentedNamespace(constants$k);

const { LEVELS: LEVELS$1, LEVEL_NAMES } = require$$3$t;

const nocolor = input => input;
const plain = {
  default: nocolor,
  60: nocolor,
  50: nocolor,
  40: nocolor,
  30: nocolor,
  20: nocolor,
  10: nocolor,
  message: nocolor,
  greyMessage: nocolor
};

const chalk$1 = require$$0$w;
const ctx = new chalk$1.Instance({ level: 3 });
const colored = {
  default: ctx.white,
  60: ctx.bgRed,
  50: ctx.red,
  40: ctx.yellow,
  30: ctx.green,
  20: ctx.blue,
  10: ctx.grey,
  message: ctx.cyan,
  greyMessage: ctx.grey
};

function colorizeLevel (level, colorizer) {
  if (Number.isInteger(+level)) {
    return Object.prototype.hasOwnProperty.call(LEVELS$1, level)
      ? colorizer[level](LEVELS$1[level])
      : colorizer.default(LEVELS$1.default)
  }
  const levelNum = LEVEL_NAMES[level.toLowerCase()] || 'default';
  return colorizer[levelNum](LEVELS$1[levelNum])
}

function plainColorizer (level) {
  return colorizeLevel(level, plain)
}
plainColorizer.message = plain.message;
plainColorizer.greyMessage = plain.greyMessage;

function coloredColorizer (level) {
  return colorizeLevel(level, colored)
}
coloredColorizer.message = colored.message;
coloredColorizer.greyMessage = colored.greyMessage;

/**
 * Factory function get a function to colorized levels. The returned function
 * also includes a `.message(str)` method to colorize strings.
 *
 * @param {boolean} [useColors=false] When `true` a function that applies standard
 * terminal colors is returned.
 *
 * @returns {function} `function (level) {}` has a `.message(str)` method to
 * apply colorization to a string. The core function accepts either an integer
 * `level` or a `string` level. The integer level will map to a known level
 * string or to `USERLVL` if not known.  The string `level` will map to the same
 * colors as the integer `level` and will also default to `USERLVL` if the given
 * string is not a recognized level name.
 */
var colors$1 = function getColorizer (useColors = false) {
  return useColors ? coloredColorizer : plainColorizer
};

var colors$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), colors$1, {
    'default': colors$1
}));

var require$$2$B = /*@__PURE__*/getAugmentedNamespace(colors$2);

var utils$c = {exports: {}};

var rfdc_1 = rfdc;

function copyBuffer (cur) {
  if (cur instanceof Buffer$1) {
    return Buffer$1.from(cur)
  }

  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
}

function rfdc (opts) {
  opts = opts || {};

  if (opts.circles) return rfdcCircles(opts)
  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a);
    var a2 = new Array(keys.length);
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      var cur = a[k];
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur;
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur);
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur);
      } else {
        a2[k] = fn(cur);
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))
    var o2 = {};
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k];
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur;
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur);
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), clone));
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), clone));
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        o2[k] = clone(cur);
      }
    }
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))
    var o2 = {};
    for (var k in o) {
      var cur = o[k];
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur;
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur);
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        o2[k] = cloneProto(cur);
      }
    }
    return o2
  }
}

function rfdcCircles (opts) {
  var refs = [];
  var refsNew = [];

  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a);
    var a2 = new Array(keys.length);
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      var cur = a[k];
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur;
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur);
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur);
      } else {
        var index = refs.indexOf(cur);
        if (index !== -1) {
          a2[k] = refsNew[index];
        } else {
          a2[k] = fn(cur);
        }
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))
    var o2 = {};
    refs.push(o);
    refsNew.push(o2);
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k];
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur;
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur);
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), clone));
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), clone));
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        var i = refs.indexOf(cur);
        if (i !== -1) {
          o2[k] = refsNew[i];
        } else {
          o2[k] = clone(cur);
        }
      }
    }
    refs.pop();
    refsNew.pop();
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))
    var o2 = {};
    refs.push(o);
    refsNew.push(o2);
    for (var k in o) {
      var cur = o[k];
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur;
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur);
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur);
      } else {
        var i = refs.indexOf(cur);
        if (i !== -1) {
          o2[k] = refsNew[i];
        } else {
          o2[k] = cloneProto(cur);
        }
      }
    }
    refs.pop();
    refsNew.pop();
    return o2
  }
}

var rfdc$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), rfdc_1, {
    'default': rfdc_1
}));

var require$$0$v = /*@__PURE__*/getAugmentedNamespace(rfdc$1);

var dateformat$3 = {exports: {}};

(function (module, exports) {
function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj};}else {_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};}return _typeof(obj)}(function(global){var _arguments=arguments;var dateFormat=function(){var token=/d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g;var timezone=/\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;var timezoneClip=/[^-+\dA-Z]/g;return function(date,mask,utc,gmt){if(_arguments.length===1&&kindOf(date)==="string"&&!/\d/.test(date)){mask=date;date=undefined;}date=date||date===0?date:new Date;if(!(date instanceof Date)){date=new Date(date);}if(isNaN(date)){throw TypeError("Invalid date")}mask=String(dateFormat.masks[mask]||mask||dateFormat.masks["default"]);var maskSlice=mask.slice(0,4);if(maskSlice==="UTC:"||maskSlice==="GMT:"){mask=mask.slice(4);utc=true;if(maskSlice==="GMT:"){gmt=true;}}var _=function _(){return utc?"getUTC":"get"};var _d=function d(){return date[_()+"Date"]()};var D=function D(){return date[_()+"Day"]()};var _m=function m(){return date[_()+"Month"]()};var y=function y(){return date[_()+"FullYear"]()};var _H=function H(){return date[_()+"Hours"]()};var _M=function M(){return date[_()+"Minutes"]()};var _s=function s(){return date[_()+"Seconds"]()};var _L=function L(){return date[_()+"Milliseconds"]()};var _o=function o(){return utc?0:date.getTimezoneOffset()};var _W=function W(){return getWeek(date)};var _N=function N(){return getDayOfWeek(date)};var flags={d:function d(){return _d()},dd:function dd(){return pad(_d())},ddd:function ddd(){return dateFormat.i18n.dayNames[D()]},DDD:function DDD(){return getDayName({y:y(),m:_m(),d:_d(),_:_(),dayName:dateFormat.i18n.dayNames[D()],short:true})},dddd:function dddd(){return dateFormat.i18n.dayNames[D()+7]},DDDD:function DDDD(){return getDayName({y:y(),m:_m(),d:_d(),_:_(),dayName:dateFormat.i18n.dayNames[D()+7]})},m:function m(){return _m()+1},mm:function mm(){return pad(_m()+1)},mmm:function mmm(){return dateFormat.i18n.monthNames[_m()]},mmmm:function mmmm(){return dateFormat.i18n.monthNames[_m()+12]},yy:function yy(){return String(y()).slice(2)},yyyy:function yyyy(){return pad(y(),4)},h:function h(){return _H()%12||12},hh:function hh(){return pad(_H()%12||12)},H:function H(){return _H()},HH:function HH(){return pad(_H())},M:function M(){return _M()},MM:function MM(){return pad(_M())},s:function s(){return _s()},ss:function ss(){return pad(_s())},l:function l(){return pad(_L(),3)},L:function L(){return pad(Math.floor(_L()/10))},t:function t(){return _H()<12?dateFormat.i18n.timeNames[0]:dateFormat.i18n.timeNames[1]},tt:function tt(){return _H()<12?dateFormat.i18n.timeNames[2]:dateFormat.i18n.timeNames[3]},T:function T(){return _H()<12?dateFormat.i18n.timeNames[4]:dateFormat.i18n.timeNames[5]},TT:function TT(){return _H()<12?dateFormat.i18n.timeNames[6]:dateFormat.i18n.timeNames[7]},Z:function Z(){return gmt?"GMT":utc?"UTC":(String(date).match(timezone)||[""]).pop().replace(timezoneClip,"").replace(/GMT\+0000/g,"UTC")},o:function o(){return (_o()>0?"-":"+")+pad(Math.floor(Math.abs(_o())/60)*100+Math.abs(_o())%60,4)},p:function p(){return (_o()>0?"-":"+")+pad(Math.floor(Math.abs(_o())/60),2)+":"+pad(Math.floor(Math.abs(_o())%60),2)},S:function S(){return ["th","st","nd","rd"][_d()%10>3?0:(_d()%100-_d()%10!=10)*_d()%10]},W:function W(){return _W()},WW:function WW(){return pad(_W())},N:function N(){return _N()}};return mask.replace(token,function(match){if(match in flags){return flags[match]()}return match.slice(1,match.length-1)})}}();dateFormat.masks={default:"ddd mmm dd yyyy HH:MM:ss",shortDate:"m/d/yy",paddedShortDate:"mm/dd/yyyy",mediumDate:"mmm d, yyyy",longDate:"mmmm d, yyyy",fullDate:"dddd, mmmm d, yyyy",shortTime:"h:MM TT",mediumTime:"h:MM:ss TT",longTime:"h:MM:ss TT Z",isoDate:"yyyy-mm-dd",isoTime:"HH:MM:ss",isoDateTime:"yyyy-mm-dd'T'HH:MM:sso",isoUtcDateTime:"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",expiresHeaderFormat:"ddd, dd mmm yyyy HH:MM:ss Z"};dateFormat.i18n={dayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","January","February","March","April","May","June","July","August","September","October","November","December"],timeNames:["a","p","am","pm","A","P","AM","PM"]};var pad=function pad(val,len){val=String(val);len=len||2;while(val.length<len){val="0"+val;}return val};var getDayName=function getDayName(_ref){var y=_ref.y,m=_ref.m,d=_ref.d,_=_ref._,dayName=_ref.dayName,_ref$short=_ref["short"],_short=_ref$short===void 0?false:_ref$short;var today=new Date;var yesterday=new Date;yesterday.setDate(yesterday[_+"Date"]()-1);var tomorrow=new Date;tomorrow.setDate(tomorrow[_+"Date"]()+1);var today_d=function today_d(){return today[_+"Date"]()};var today_m=function today_m(){return today[_+"Month"]()};var today_y=function today_y(){return today[_+"FullYear"]()};var yesterday_d=function yesterday_d(){return yesterday[_+"Date"]()};var yesterday_m=function yesterday_m(){return yesterday[_+"Month"]()};var yesterday_y=function yesterday_y(){return yesterday[_+"FullYear"]()};var tomorrow_d=function tomorrow_d(){return tomorrow[_+"Date"]()};var tomorrow_m=function tomorrow_m(){return tomorrow[_+"Month"]()};var tomorrow_y=function tomorrow_y(){return tomorrow[_+"FullYear"]()};if(today_y()===y&&today_m()===m&&today_d()===d){return _short?"Tdy":"Today"}else if(yesterday_y()===y&&yesterday_m()===m&&yesterday_d()===d){return _short?"Ysd":"Yesterday"}else if(tomorrow_y()===y&&tomorrow_m()===m&&tomorrow_d()===d){return _short?"Tmw":"Tomorrow"}return dayName};var getWeek=function getWeek(date){var targetThursday=new Date(date.getFullYear(),date.getMonth(),date.getDate());targetThursday.setDate(targetThursday.getDate()-(targetThursday.getDay()+6)%7+3);var firstThursday=new Date(targetThursday.getFullYear(),0,4);firstThursday.setDate(firstThursday.getDate()-(firstThursday.getDay()+6)%7+3);var ds=targetThursday.getTimezoneOffset()-firstThursday.getTimezoneOffset();targetThursday.setHours(targetThursday.getHours()-ds);var weekDiff=(targetThursday-firstThursday)/(864e5*7);return 1+Math.floor(weekDiff)};var getDayOfWeek=function getDayOfWeek(date){var dow=date.getDay();if(dow===0){dow=7;}return dow};var kindOf=function kindOf(val){if(val===null){return "null"}if(val===undefined){return "undefined"}if(_typeof(val)!=="object"){return _typeof(val)}if(Array.isArray(val)){return "array"}return {}.toString.call(val).slice(8,-1).toLowerCase()};if((_typeof(exports))==="object"){module.exports=dateFormat;}else {global.dateFormat=dateFormat;}})(void 0);
}(dateformat$3, dateformat$3.exports));

var dateformat$1 = dateformat$3.exports;

var dateformat$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), dateformat$3.exports, {
    'default': dateformat$1
}));

var require$$1$T = /*@__PURE__*/getAugmentedNamespace(dateformat$2);

const clone = require$$0$v();
const dateformat = require$$1$T;
const stringifySafe$1 = require$$3$v;
const defaultColorizer = require$$2$B();
const {
  DATE_FORMAT,
  ERROR_LIKE_KEYS: ERROR_LIKE_KEYS$1,
  MESSAGE_KEY: MESSAGE_KEY$1,
  LEVEL_KEY,
  LEVEL_LABEL,
  TIMESTAMP_KEY: TIMESTAMP_KEY$1,
  LOGGER_KEYS,
  LEVELS
} = require$$3$t;

utils$c.exports = {
  isObject: isObject$1,
  prettifyErrorLog: prettifyErrorLog$1,
  prettifyLevel: prettifyLevel$1,
  prettifyMessage: prettifyMessage$1,
  prettifyMetadata: prettifyMetadata$1,
  prettifyObject: prettifyObject$1,
  prettifyTime: prettifyTime$1,
  filterLog: filterLog$1
};

var internals = utils$c.exports.internals = {
  formatTime,
  joinLinesWithIndentation,
  prettifyError,
  deleteLogProperty
};

/**
 * Converts a given `epoch` to a desired display format.
 *
 * @param {number|string} epoch The time to convert. May be any value that is
 * valid for `new Date()`.
 * @param {boolean|string} [translateTime=false] When `false`, the given `epoch`
 * will simply be returned. When `true`, the given `epoch` will be converted
 * to a string at UTC using the `DATE_FORMAT` constant. If `translateTime` is
 * a string, the following rules are available:
 *
 * - `<format string>`: The string is a literal format string. This format
 * string will be used to interpret the `epoch` and return a display string
 * at UTC.
 * - `SYS:STANDARD`: The returned display string will follow the `DATE_FORMAT`
 * constant at the system's local timezone.
 * - `SYS:<format string>`: The returned display string will follow the given
 * `<format string>` at the system's local timezone.
 * - `UTC:<format string>`: The returned display string will follow the given
 * `<format string>` at UTC.
 *
 * @returns {number|string} The formatted time.
 */
function formatTime (epoch, translateTime = false) {
  if (translateTime === false) {
    return epoch
  }

  const instant = new Date(epoch);
  if (translateTime === true) {
    return dateformat(instant, 'UTC:' + DATE_FORMAT)
  }

  const upperFormat = translateTime.toUpperCase();
  if (upperFormat === 'SYS:STANDARD') {
    return dateformat(instant, DATE_FORMAT)
  }

  const prefix = upperFormat.substr(0, 4);
  if (prefix === 'SYS:' || prefix === 'UTC:') {
    if (prefix === 'UTC:') {
      return dateformat(instant, translateTime)
    }
    return dateformat(instant, translateTime.slice(4))
  }

  return dateformat(instant, `UTC:${translateTime}`)
}

function isObject$1 (input) {
  return Object.prototype.toString.apply(input) === '[object Object]'
}

/**
 * Given a string with line separators, either `\r\n` or `\n`, add indentation
 * to all lines subsequent to the first line and rejoin the lines using an
 * end of line sequence.
 *
 * @param {object} input
 * @param {string} input.input The string to split and reformat.
 * @param {string} [input.ident] The indentation string. Default: `    ` (4 spaces).
 * @param {string} [input.eol] The end of line sequence to use when rejoining
 * the lines. Default: `'\n'`.
 *
 * @returns {string} A string with lines subsequent to the first indented
 * with the given indentation sequence.
 */
function joinLinesWithIndentation ({ input, ident = '    ', eol = '\n' }) {
  const lines = input.split(/\r?\n/);
  for (let i = 1; i < lines.length; i += 1) {
    lines[i] = ident + lines[i];
  }
  return lines.join(eol)
}

/**
 * Given a log object that has a `type: 'Error'` key, prettify the object and
 * return the result. In other
 *
 * @param {object} input
 * @param {object} input.log The error log to prettify.
 * @param {string} [input.messageKey] The name of the key that contains a
 * general log message. This is not the error's message property but the logger
 * messsage property. Default: `MESSAGE_KEY` constant.
 * @param {string} [input.ident] The sequence to use for indentation. Default: `'    '`.
 * @param {string} [input.eol] The sequence to use for EOL. Default: `'\n'`.
 * @param {string[]} [input.errorLikeKeys] A set of keys that should be considered
 * to have error objects as values. Default: `ERROR_LIKE_KEYS` constant.
 * @param {string[]} [input.errorProperties] A set of specific error object
 * properties, that are not the value of `messageKey`, `type`, or `stack`, to
 * include in the prettified result. The first entry in the list may be `'*'`
 * to indicate that all sibiling properties should be prettified. Default: `[]`.
 *
 * @returns {string} A sring that represents the prettified error log.
 */
function prettifyErrorLog$1 ({
  log,
  messageKey = MESSAGE_KEY$1,
  ident = '    ',
  eol = '\n',
  errorLikeKeys = ERROR_LIKE_KEYS$1,
  errorProperties = []
}) {
  const stack = log.stack;
  const joinedLines = joinLinesWithIndentation({ input: stack, ident, eol });
  let result = `${ident}${joinedLines}${eol}`;

  if (errorProperties.length > 0) {
    const excludeProperties = LOGGER_KEYS.concat(messageKey, 'type', 'stack');
    let propertiesToPrint;
    if (errorProperties[0] === '*') {
      // Print all sibling properties except for the standard exclusions.
      propertiesToPrint = Object.keys(log).filter(k => excludeProperties.includes(k) === false);
    } else {
      // Print only sepcified properties unless the property is a standard exclusion.
      propertiesToPrint = errorProperties.filter(k => excludeProperties.includes(k) === false);
    }

    for (let i = 0; i < propertiesToPrint.length; i += 1) {
      const key = propertiesToPrint[i];
      if (key in log === false) continue
      if (isObject$1(log[key])) {
        // The nested object may have "logger" type keys but since they are not
        // at the root level of the object being processed, we want to print them.
        // Thus, we invoke with `excludeLoggerKeys: false`.
        const prettifiedObject = prettifyObject$1({ input: log[key], errorLikeKeys, excludeLoggerKeys: false, eol, ident });
        result = `${result}${key}: {${eol}${prettifiedObject}}${eol}`;
        continue
      }
      result = `${result}${key}: ${log[key]}${eol}`;
    }
  }

  return result
}

/**
 * Checks if the passed in log has a `level` value and returns a prettified
 * string for that level if so.
 *
 * @param {object} input
 * @param {object} input.log The log object.
 * @param {function} [input.colorizer] A colorizer function that accepts a level
 * value and returns a colorized string. Default: a no-op colorizer.
 * @param {string} [levelKey='level'] The key to find the level under.
 *
 * @returns {undefined|string} If `log` does not have a `level` property then
 * `undefined` will be returned. Otherwise, a string from the specified
 * `colorizer` is returned.
 */
function prettifyLevel$1 ({ log, colorizer = defaultColorizer, levelKey = LEVEL_KEY }) {
  if (levelKey in log === false) return undefined
  return colorizer(log[levelKey])
}

/**
 * Prettifies a message string if the given `log` has a message property.
 *
 * @param {object} input
 * @param {object} input.log The log object with the message to colorize.
 * @param {string} [input.messageKey='msg'] The property of the `log` that is the
 * message to be prettified.
 * @param {string|function} [input.messageFormat=undefined] A format string or function that defines how the
 *  logged message should be formatted, e.g. `'{level} - {pid}'`.
 * @param {function} [input.colorizer] A colorizer function that has a
 * `.message(str)` method attached to it. This function should return a colorized
 * string which will be the "prettified" message. Default: a no-op colorizer.
 *
 * @returns {undefined|string} If the message key is not found, or the message
 * key is not a string, then `undefined` will be returned. Otherwise, a string
 * that is the prettified message.
 */
function prettifyMessage$1 ({ log, messageFormat, messageKey = MESSAGE_KEY$1, colorizer = defaultColorizer, levelLabel = LEVEL_LABEL }) {
  if (messageFormat && typeof messageFormat === 'string') {
    const message = String(messageFormat).replace(/{([^{}]+)}/g, function (match, p1) {
      // return log level as string instead of int
      if (p1 === levelLabel && log[LEVEL_KEY]) {
        return LEVELS[log[LEVEL_KEY]]
      }
      // Parse nested key access, e.g. `{keyA.subKeyB}`.
      return p1.split('.').reduce(function (prev, curr) {
        if (prev && prev[curr]) {
          return prev[curr]
        }
        return ''
      }, log)
    });
    return colorizer.message(message)
  }
  if (messageFormat && typeof messageFormat === 'function') {
    const msg = messageFormat(log, messageKey, levelLabel);
    return colorizer.message(msg)
  }
  if (messageKey in log === false) return undefined
  if (typeof log[messageKey] !== 'string') return undefined
  return colorizer.message(log[messageKey])
}

/**
 * Prettifies metadata that is usually present in a Pino log line. It looks for
 * fields `name`, `pid`, `hostname`, and `caller` and returns a formatted string using
 * the fields it finds.
 *
 * @param {object} input
 * @param {object} input.log The log that may or may not contain metadata to
 * be prettified.
 *
 * @returns {undefined|string} If no metadata is found then `undefined` is
 * returned. Otherwise, a string of prettified metadata is returned.
 */
function prettifyMetadata$1 ({ log }) {
  let line = '';

  if (log.name || log.pid || log.hostname) {
    line += '(';

    if (log.name) {
      line += log.name;
    }

    if (log.name && log.pid) {
      line += '/' + log.pid;
    } else if (log.pid) {
      line += log.pid;
    }

    if (log.hostname) {
      // If `pid` and `name` were in the ignore keys list then we don't need
      // the leading space.
      line += `${line === '(' ? 'on' : ' on'} ${log.hostname}`;
    }

    line += ')';
  }

  if (log.caller) {
    line += `${line === '' ? '' : ' '}<${log.caller}>`;
  }

  if (line === '') {
    return undefined
  } else {
    return line
  }
}

/**
 * Prettifies a standard object. Special care is taken when processing the object
 * to handle child objects that are attached to keys known to contain error
 * objects.
 *
 * @param {object} input
 * @param {object} input.input The object to prettify.
 * @param {string} [input.ident] The identation sequence to use. Default: `'    '`.
 * @param {string} [input.eol] The EOL sequence to use. Default: `'\n'`.
 * @param {string[]} [input.skipKeys] A set of object keys to exclude from the
 * prettified result. Default: `[]`.
 * @param {Object<string, function>} [input.customPrettifiers] Dictionary of
 * custom prettifiers. Default: `{}`.
 * @param {string[]} [input.errorLikeKeys] A set of object keys that contain
 * error objects. Default: `ERROR_LIKE_KEYS` constant.
 * @param {boolean} [input.excludeLoggerKeys] Indicates if known logger specific
 * keys should be excluded from prettification. Default: `true`.
 * @param {boolean} [input.singleLine] Should non-error keys all be formatted
 * on a single line? This does NOT apply to errors, which will still be
 * multi-line. Default: `false`
 *
 * @returns {string} The prettified string. This can be as little as `''` if
 * there was nothing to prettify.
 */
function prettifyObject$1 ({
  input,
  ident = '    ',
  eol = '\n',
  skipKeys = [],
  customPrettifiers = {},
  errorLikeKeys = ERROR_LIKE_KEYS$1,
  excludeLoggerKeys = true,
  singleLine = false,
  colorizer = defaultColorizer
}) {
  const keysToIgnore = [].concat(skipKeys);

  if (excludeLoggerKeys === true) Array.prototype.push.apply(keysToIgnore, LOGGER_KEYS);

  let result = '';

  // Split object keys into two categories: error and non-error
  const { plain, errors } = Object.entries(input).reduce(({ plain, errors }, [k, v]) => {
    if (keysToIgnore.includes(k) === false) {
      // Pre-apply custom prettifiers, because all 3 cases below will need this
      const pretty = typeof customPrettifiers[k] === 'function'
        ? customPrettifiers[k](v, k, input)
        : v;
      if (errorLikeKeys.includes(k)) {
        errors[k] = pretty;
      } else {
        plain[k] = pretty;
      }
    }
    return { plain, errors }
  }, { plain: {}, errors: {} });

  if (singleLine) {
    // Stringify the entire object as a single JSON line
    if (Object.keys(plain).length > 0) {
      result += colorizer.greyMessage(stringifySafe$1(plain));
    }
    result += eol;
  } else {
    // Put each object entry on its own line
    Object.entries(plain).forEach(([keyName, keyValue]) => {
      // custom prettifiers are already applied above, so we can skip it now
      const lines = typeof customPrettifiers[keyName] === 'function'
        ? keyValue
        : stringifySafe$1(keyValue, null, 2);

      if (lines === undefined) return

      const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol });
      result += `${ident}${keyName}: ${joinedLines}${eol}`;
    });
  }

  // Errors
  Object.entries(errors).forEach(([keyName, keyValue]) => {
    // custom prettifiers are already applied above, so we can skip it now
    const lines = typeof customPrettifiers[keyName] === 'function'
      ? keyValue
      : stringifySafe$1(keyValue, null, 2);

    if (lines === undefined) return

    result += prettifyError({ keyName, lines, eol, ident });
  });

  return result
}

/**
 * Prettifies a timestamp if the given `log` has either `time`, `timestamp` or custom specified timestamp
 * property.
 *
 * @param {object} input
 * @param {object} input.log The log object with the timestamp to be prettified.
 * @param {string} [input.timestampKey='time'] The log property that should be used to resolve timestamp value
 * @param {boolean|string} [input.translateFormat=undefined] When `true` the
 * timestamp will be prettified into a string at UTC using the default
 * `DATE_FORMAT`. If a string, then `translateFormat` will be used as the format
 * string to determine the output; see the `formatTime` function for details.
 *
 * @returns {undefined|string} If a timestamp property cannot be found then
 * `undefined` is returned. Otherwise, the prettified time is returned as a
 * string.
 */
function prettifyTime$1 ({ log, timestampKey = TIMESTAMP_KEY$1, translateFormat = undefined }) {
  let time = null;

  if (timestampKey in log) {
    time = log[timestampKey];
  } else if ('timestamp' in log) {
    time = log.timestamp;
  }

  if (time === null) return undefined
  if (translateFormat) {
    return '[' + formatTime(time, translateFormat) + ']'
  }

  return `[${time}]`
}

/**
 * Prettifies an error string into a multi-line format.
 * @param {object} input
 * @param {string} input.keyName The key assigned to this error in the log object
 * @param {string} input.lines The STRINGIFIED error. If the error field has a
 *  custom prettifier, that should be pre-applied as well
 * @param {string} input.ident The indentation sequence to use
 * @param {string} input.eol The EOL sequence to use
 */
function prettifyError ({ keyName, lines, eol, ident }) {
  let result = '';
  const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol });
  const splitLines = `${ident}${keyName}: ${joinedLines}${eol}`.split(eol);

  for (let j = 0; j < splitLines.length; j += 1) {
    if (j !== 0) result += eol;

    const line = splitLines[j];
    if (/^\s*"stack"/.test(line)) {
      const matches = /^(\s*"stack":)\s*(".*"),?$/.exec(line);
      /* istanbul ignore else */
      if (matches && matches.length === 3) {
        const indentSize = /^\s*/.exec(line)[0].length + 4;
        const indentation = ' '.repeat(indentSize);
        const stackMessage = matches[2];
        result += matches[1] + eol + indentation + JSON.parse(stackMessage).replace(/\n/g, eol + indentation);
      }
    } else {
      result += line;
    }
  }

  return result
}

/**
 * Deletes a specified property from a log object if it exists.
 * This function mutates the passed in `log` object.
 *
 * @param {object} log The log object to be modified.
 * @param {string} property A string identifying the property to be deleted from
 * the log object. Accepts nested properties delimited by a `.`
 * e.g. `'prop1.prop2'`.
 */
function deleteLogProperty (log, property) {
  const props = property.split('.');
  const propToDelete = props.pop();

  props.forEach((prop) => {
    if (!Object.prototype.hasOwnProperty.call(log, prop)) {
      return
    }
    log = log[prop];
  });

  delete log[propToDelete];
}

/**
 * Filter a log object by removing any ignored keys.
 *
 * @param {object} log The log object to be modified.
 * @param {string} ignoreKeys An array of strings identifying the properties to be removed.
 *
 * @returns {object} A new `log` object instance that does not include the ignored keys.
 */
function filterLog$1 (log, ignoreKeys) {
  const logCopy = clone(log);
  ignoreKeys.forEach((ignoreKey) => {
    deleteLogProperty(logCopy, ignoreKey);
  });
  return logCopy
}

var utils$a = utils$c.exports;

var utils$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), utils$c.exports, {
    'default': utils$a,
    internals: internals
}));

var require$$4$l = /*@__PURE__*/getAugmentedNamespace(utils$b);

var lib$3 = {};

(function (exports) {


const internals = {
    suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
};


exports.parse = function (text, ...args) {

    // Normalize arguments

    const firstOptions = typeof args[0] === 'object' && args[0];
    const reviver = args.length > 1 || !firstOptions ? args[0] : undefined;
    const options = (args.length > 1 && args[1]) || firstOptions || {};

    // Parse normally, allowing exceptions

    const obj = JSON.parse(text, reviver);

    // options.protoAction: 'error' (default) / 'remove' / 'ignore'

    if (options.protoAction === 'ignore') {
        return obj;
    }

    // Ignore null and non-objects

    if (!obj ||
        typeof obj !== 'object') {

        return obj;
    }

    // Check original string for potential exploit

    if (!text.match(internals.suspectRx)) {
        return obj;
    }

    // Scan result for proto keys

    exports.scan(obj, options);

    return obj;
};


exports.scan = function (obj, options = {}) {

    let next = [obj];

    while (next.length) {
        const nodes = next;
        next = [];

        for (const node of nodes) {
            if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {      // Avoid calling node.hasOwnProperty directly
                if (options.protoAction !== 'remove') {
                    throw new SyntaxError('Object contains forbidden prototype property');
                }

                delete node.__proto__;
            }

            for (const key in node) {
                const value = node[key];
                if (value &&
                    typeof value === 'object') {

                    next.push(node[key]);
                }
            }
        }
    }
};


exports.safeParse = function (text, reviver) {

    try {
        return exports.parse(text, reviver);
    }
    catch (ignoreError) {
        return null;
    }
};
}(lib$3));

var lib$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), lib$3, {
    'default': lib$3
}));

var require$$5$i = /*@__PURE__*/getAugmentedNamespace(lib$2);

const chalk = require$$0$w;
const jmespath = require$$1$U;
const colors = require$$2$B;
const { ERROR_LIKE_KEYS, MESSAGE_KEY, TIMESTAMP_KEY } = require$$3$t;
const {
  isObject,
  prettifyErrorLog,
  prettifyLevel,
  prettifyMessage,
  prettifyMetadata,
  prettifyObject,
  prettifyTime,
  filterLog
} = require$$4$l;

const bourne = require$$5$i;
const jsonParser = input => {
  try {
    return { value: bourne.parse(input, { protoAction: 'remove' }) }
  } catch (err) {
    return { err }
  }
};

const defaultOptions$1 = {
  colorize: chalk.supportsColor,
  crlf: false,
  errorLikeObjectKeys: ERROR_LIKE_KEYS,
  errorProps: '',
  levelFirst: false,
  messageKey: MESSAGE_KEY,
  messageFormat: false,
  timestampKey: TIMESTAMP_KEY,
  translateTime: false,
  useMetadata: false,
  outputStream: browser$1$1.stdout,
  customPrettifiers: {},
  hideObject: false,
  singleLine: false
};

var pinoPretty = function prettyFactory (options) {
  const opts = Object.assign({}, defaultOptions$1, options);
  const EOL = opts.crlf ? '\r\n' : '\n';
  const IDENT = '    ';
  const messageKey = opts.messageKey;
  const levelKey = opts.levelKey;
  const levelLabel = opts.levelLabel;
  const messageFormat = opts.messageFormat;
  const timestampKey = opts.timestampKey;
  const errorLikeObjectKeys = opts.errorLikeObjectKeys;
  const errorProps = opts.errorProps.split(',');
  const customPrettifiers = opts.customPrettifiers;
  const ignoreKeys = opts.ignore ? new Set(opts.ignore.split(',')) : undefined;
  const hideObject = opts.hideObject;
  const singleLine = opts.singleLine;

  const colorizer = colors(opts.colorize);
  const search = opts.search;

  return pretty

  function pretty (inputData) {
    let log;
    if (!isObject(inputData)) {
      const parsed = jsonParser(inputData);
      if (parsed.err || !isObject(parsed.value)) {
        // pass through
        return inputData + EOL
      }
      log = parsed.value;
    } else {
      log = inputData;
    }

    if (search && !jmespath.search(log, search)) {
      return
    }

    const prettifiedMessage = prettifyMessage({ log, messageKey, colorizer, messageFormat, levelLabel });

    if (ignoreKeys) {
      log = filterLog(log, ignoreKeys);
    }

    const prettifiedLevel = prettifyLevel({ log, colorizer, levelKey });
    const prettifiedMetadata = prettifyMetadata({ log });
    const prettifiedTime = prettifyTime({ log, translateFormat: opts.translateTime, timestampKey });

    let line = '';
    if (opts.levelFirst && prettifiedLevel) {
      line = `${prettifiedLevel}`;
    }

    if (prettifiedTime && line === '') {
      line = `${prettifiedTime}`;
    } else if (prettifiedTime) {
      line = `${line} ${prettifiedTime}`;
    }

    if (!opts.levelFirst && prettifiedLevel) {
      if (line.length > 0) {
        line = `${line} ${prettifiedLevel}`;
      } else {
        line = prettifiedLevel;
      }
    }

    if (prettifiedMetadata) {
      if (line.length > 0) {
        line = `${line} ${prettifiedMetadata}:`;
      } else {
        line = prettifiedMetadata;
      }
    }

    if (line.endsWith(':') === false && line !== '') {
      line += ':';
    }

    if (prettifiedMessage) {
      if (line.length > 0) {
        line = `${line} ${prettifiedMessage}`;
      } else {
        line = prettifiedMessage;
      }
    }

    if (line.length > 0 && !singleLine) {
      line += EOL;
    }

    if (log.type === 'Error' && log.stack) {
      const prettifiedErrorLog = prettifyErrorLog({
        log,
        errorLikeKeys: errorLikeObjectKeys,
        errorProperties: errorProps,
        ident: IDENT,
        eol: EOL
      });
      line += prettifiedErrorLog;
    } else if (!hideObject) {
      const skipKeys = [messageKey, levelKey, timestampKey].filter(key => typeof log[key] === 'string' || typeof log[key] === 'number');
      const prettifiedObject = prettifyObject({
        input: log,
        skipKeys,
        customPrettifiers,
        errorLikeKeys: errorLikeObjectKeys,
        eol: EOL,
        ident: IDENT,
        singleLine,
        colorizer
      });

      // In single line mode, include a space only if prettified version isn't empty
      if (singleLine && !/^\s$/.test(prettifiedObject)) {
        line += ' ';
      }
      line += prettifiedObject;
    }

    return line
  }
};

var pinoPretty$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pinoPretty, {
    'default': pinoPretty
}));

var require$$5$h = /*@__PURE__*/getAugmentedNamespace(pinoPretty$1);

/* eslint no-prototype-builtins: 0 */

const format = require$$0$B;
const { mapHttpRequest, mapHttpResponse } = require$$1$Z;
const SonicBoom$1 = require$$1$X;
const stringifySafe = require$$3$v;
const {
  lsCacheSym: lsCacheSym$2,
  chindingsSym: chindingsSym$2,
  parsedChindingsSym: parsedChindingsSym$1,
  writeSym: writeSym$1,
  serializersSym: serializersSym$2,
  formatOptsSym: formatOptsSym$2,
  endSym: endSym$1,
  stringifiersSym: stringifiersSym$2,
  stringifySym: stringifySym$2,
  wildcardFirstSym,
  needsMetadataGsym: needsMetadataGsym$1,
  redactFmtSym: redactFmtSym$2,
  streamSym: streamSym$3,
  nestedKeySym: nestedKeySym$1,
  formattersSym: formattersSym$3,
  messageKeySym: messageKeySym$1
} = require$$5$j;

function noop$2 () {}

function genLog$1 (level, hook) {
  if (!hook) return LOG

  return function hookWrappedLog (...args) {
    hook.call(this, args, LOG, level);
  }

  function LOG (o, ...n) {
    if (typeof o === 'object') {
      let msg = o;
      if (o !== null) {
        if (o.method && o.headers && o.socket) {
          o = mapHttpRequest(o);
        } else if (typeof o.setHeader === 'function') {
          o = mapHttpResponse(o);
        }
      }
      if (this[nestedKeySym$1]) o = { [this[nestedKeySym$1]]: o };
      let formatParams;
      if (msg === null && n.length === 0) {
        formatParams = [null];
      } else {
        msg = n.shift();
        formatParams = n;
      }
      this[writeSym$1](o, format(msg, formatParams, this[formatOptsSym$2]), level);
    } else {
      this[writeSym$1](null, format(o, n, this[formatOptsSym$2]), level);
    }
  }
}

// magically escape strings for json
// relying on their charCodeAt
// everything below 32 needs JSON.stringify()
// 34 and 92 happens all the time, so we
// have a fast case for them
function asString (str) {
  let result = '';
  let last = 0;
  let found = false;
  let point = 255;
  const l = str.length;
  if (l > 100) {
    return JSON.stringify(str)
  }
  for (var i = 0; i < l && point >= 32; i++) {
    point = str.charCodeAt(i);
    if (point === 34 || point === 92) {
      result += str.slice(last, i) + '\\';
      last = i;
      found = true;
    }
  }
  if (!found) {
    result = str;
  } else {
    result += str.slice(last);
  }
  return point < 32 ? JSON.stringify(str) : '"' + result + '"'
}

function asJson$1 (obj, msg, num, time) {
  const stringify = this[stringifySym$2];
  const stringifiers = this[stringifiersSym$2];
  const end = this[endSym$1];
  const chindings = this[chindingsSym$2];
  const serializers = this[serializersSym$2];
  const formatters = this[formattersSym$3];
  const messageKey = this[messageKeySym$1];
  let data = this[lsCacheSym$2][num] + time;

  // we need the child bindings added to the output first so instance logged
  // objects can take precedence when JSON.parse-ing the resulting log line
  data = data + chindings;

  let value;
  const notHasOwnProperty = obj.hasOwnProperty === undefined;
  if (formatters.log) {
    obj = formatters.log(obj);
  }
  if (msg !== undefined) {
    obj[messageKey] = msg;
  }
  const wildcardStringifier = stringifiers[wildcardFirstSym];
  for (const key in obj) {
    value = obj[key];
    if ((notHasOwnProperty || obj.hasOwnProperty(key)) && value !== undefined) {
      value = serializers[key] ? serializers[key](value) : value;

      const stringifier = stringifiers[key] || wildcardStringifier;

      switch (typeof value) {
        case 'undefined':
        case 'function':
          continue
        case 'number':
          /* eslint no-fallthrough: "off" */
          if (Number.isFinite(value) === false) {
            value = null;
          }
        // this case explicitly falls through to the next one
        case 'boolean':
          if (stringifier) value = stringifier(value);
          break
        case 'string':
          value = (stringifier || asString)(value);
          break
        default:
          value = (stringifier || stringify)(value);
      }
      if (value === undefined) continue
      data += ',"' + key + '":' + value;
    }
  }

  return data + end
}

function asChindings$2 (instance, bindings) {
  let value;
  let data = instance[chindingsSym$2];
  const stringify = instance[stringifySym$2];
  const stringifiers = instance[stringifiersSym$2];
  const wildcardStringifier = stringifiers[wildcardFirstSym];
  const serializers = instance[serializersSym$2];
  const formatter = instance[formattersSym$3].bindings;
  bindings = formatter(bindings);

  for (const key in bindings) {
    value = bindings[key];
    const valid = key !== 'level' &&
      key !== 'serializers' &&
      key !== 'formatters' &&
      key !== 'customLevels' &&
      bindings.hasOwnProperty(key) &&
      value !== undefined;
    if (valid === true) {
      value = serializers[key] ? serializers[key](value) : value;
      value = (stringifiers[key] || wildcardStringifier || stringify)(value);
      if (value === undefined) continue
      data += ',"' + key + '":' + value;
    }
  }
  return data
}

function getPrettyStream (opts, prettifier, dest, instance) {
  if (prettifier && typeof prettifier === 'function') {
    prettifier = prettifier.bind(instance);
    return prettifierMetaWrapper(prettifier(opts), dest, opts)
  }
  try {
    const prettyFactory = require$$5$h.prettyFactory || require$$5$h;
    prettyFactory.asMetaWrapper = prettifierMetaWrapper;
    return prettifierMetaWrapper(prettyFactory(opts), dest, opts)
  } catch (e) {
    if (e.message.startsWith("Cannot find module 'pino-pretty'")) {
      throw Error('Missing `pino-pretty` module: `pino-pretty` must be installed separately')
    }    throw e
  }
}

function prettifierMetaWrapper (pretty, dest, opts) {
  opts = Object.assign({ suppressFlushSyncWarning: false }, opts);
  let warned = false;
  return {
    [needsMetadataGsym$1]: true,
    lastLevel: 0,
    lastMsg: null,
    lastObj: null,
    lastLogger: null,
    flushSync () {
      if (opts.suppressFlushSyncWarning || warned) {
        return
      }
      warned = true;
      setMetadataProps(dest, this);
      dest.write(pretty(Object.assign({
        level: 40, // warn
        msg: 'pino.final with prettyPrint does not support flushing',
        time: Date.now()
      }, this.chindings())));
    },
    chindings () {
      const lastLogger = this.lastLogger;
      let chindings = null;

      // protection against flushSync being called before logging
      // anything
      if (!lastLogger) {
        return null
      }

      if (lastLogger.hasOwnProperty(parsedChindingsSym$1)) {
        chindings = lastLogger[parsedChindingsSym$1];
      } else {
        chindings = JSON.parse('{' + lastLogger[chindingsSym$2].substr(1) + '}');
        lastLogger[parsedChindingsSym$1] = chindings;
      }

      return chindings
    },
    write (chunk) {
      const lastLogger = this.lastLogger;
      const chindings = this.chindings();

      let time = this.lastTime;

      if (time.match(/^\d+/)) {
        time = parseInt(time);
      } else {
        time = time.slice(1, -1);
      }

      const lastObj = this.lastObj;
      const lastMsg = this.lastMsg;
      const errorProps = null;

      const formatters = lastLogger[formattersSym$3];
      const formattedObj = formatters.log ? formatters.log(lastObj) : lastObj;

      const messageKey = lastLogger[messageKeySym$1];
      if (lastMsg && formattedObj && !formattedObj.hasOwnProperty(messageKey)) {
        formattedObj[messageKey] = lastMsg;
      }

      const obj = Object.assign({
        level: this.lastLevel,
        time
      }, formattedObj, errorProps);

      const serializers = lastLogger[serializersSym$2];
      const keys = Object.keys(serializers);

      for (var i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (obj[key] !== undefined) {
          obj[key] = serializers[key](obj[key]);
        }
      }

      for (const key in chindings) {
        if (!obj.hasOwnProperty(key)) {
          obj[key] = chindings[key];
        }
      }

      const stringifiers = lastLogger[stringifiersSym$2];
      const redact = stringifiers[redactFmtSym$2];

      const formatted = pretty(typeof redact === 'function' ? redact(obj) : obj);
      if (formatted === undefined) return

      setMetadataProps(dest, this);
      dest.write(formatted);
    }
  }
}

function hasBeenTampered (stream) {
  return stream.write !== stream.constructor.prototype.write
}

function buildSafeSonicBoom$1 (opts) {
  const stream = new SonicBoom$1(opts);
  stream.on('error', filterBrokenPipe);
  return stream

  function filterBrokenPipe (err) {
    // TODO verify on Windows
    if (err.code === 'EPIPE') {
      // If we get EPIPE, we should stop logging here
      // however we have no control to the consumer of
      // SonicBoom, so we just overwrite the write method
      stream.write = noop$2;
      stream.end = noop$2;
      stream.flushSync = noop$2;
      stream.destroy = noop$2;
      return
    }
    stream.removeListener('error', filterBrokenPipe);
    stream.emit('error', err);
  }
}

function createArgsNormalizer$1 (defaultOptions) {
  return function normalizeArgs (instance, opts = {}, stream) {
    // support stream as a string
    if (typeof opts === 'string') {
      stream = buildSafeSonicBoom$1({ dest: opts, sync: true });
      opts = {};
    } else if (typeof stream === 'string') {
      stream = buildSafeSonicBoom$1({ dest: stream, sync: true });
    } else if (opts instanceof SonicBoom$1 || opts.writable || opts._writableState) {
      stream = opts;
      opts = null;
    }
    opts = Object.assign({}, defaultOptions, opts);
    if ('extreme' in opts) {
      throw Error('The extreme option has been removed, use pino.destination({ sync: false }) instead')
    }
    if ('onTerminated' in opts) {
      throw Error('The onTerminated option has been removed, use pino.final instead')
    }
    if ('changeLevelName' in opts) {
      browser$1$1.emitWarning(
        'The changeLevelName option is deprecated and will be removed in v7. Use levelKey instead.',
        { code: 'changeLevelName_deprecation' }
      );
      opts.levelKey = opts.changeLevelName;
      delete opts.changeLevelName;
    }
    const { enabled, prettyPrint, prettifier, messageKey } = opts;
    if (enabled === false) opts.level = 'silent';
    stream = stream || browser$1$1.stdout;
    if (stream === browser$1$1.stdout && stream.fd >= 0 && !hasBeenTampered(stream)) {
      stream = buildSafeSonicBoom$1({ fd: stream.fd, sync: true });
    }
    if (prettyPrint) {
      const prettyOpts = Object.assign({ messageKey }, prettyPrint);
      stream = getPrettyStream(prettyOpts, prettifier, stream, instance);
    }
    return { opts, stream }
  }
}

function final$1 (logger, handler) {
  if (typeof logger === 'undefined' || typeof logger.child !== 'function') {
    throw Error('expected a pino logger instance')
  }
  const hasHandler = (typeof handler !== 'undefined');
  if (hasHandler && typeof handler !== 'function') {
    throw Error('if supplied, the handler parameter should be a function')
  }
  const stream = logger[streamSym$3];
  if (typeof stream.flushSync !== 'function') {
    throw Error('final requires a stream that has a flushSync method, such as pino.destination')
  }

  const finalLogger = new Proxy(logger, {
    get: (logger, key) => {
      if (key in logger.levels.values) {
        return (...args) => {
          logger[key](...args);
          stream.flushSync();
        }
      }
      return logger[key]
    }
  });

  if (!hasHandler) {
    return finalLogger
  }

  return (err = null, ...args) => {
    try {
      stream.flushSync();
    } catch (e) {
      // it's too late to wait for the stream to be ready
      // because this is a final tick scenario.
      // in practice there shouldn't be a situation where it isn't
      // however, swallow the error just in case (and for easier testing)
    }
    return handler(err, finalLogger, ...args)
  }
}

function stringify$2 (obj) {
  try {
    return JSON.stringify(obj)
  } catch (_) {
    return stringifySafe(obj)
  }
}

function buildFormatters$2 (level, bindings, log) {
  return {
    level,
    bindings,
    log
  }
}

function setMetadataProps (dest, that) {
  if (dest[needsMetadataGsym$1] === true) {
    dest.lastLevel = that.lastLevel;
    dest.lastMsg = that.lastMsg;
    dest.lastObj = that.lastObj;
    dest.lastTime = that.lastTime;
    dest.lastLogger = that.lastLogger;
  }
}

var tools = {
  noop: noop$2,
  buildSafeSonicBoom: buildSafeSonicBoom$1,
  getPrettyStream,
  asChindings: asChindings$2,
  asJson: asJson$1,
  genLog: genLog$1,
  createArgsNormalizer: createArgsNormalizer$1,
  final: final$1,
  stringify: stringify$2,
  buildFormatters: buildFormatters$2
};

var tools$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), tools, {
    'default': tools
}));

var require$$7$c = /*@__PURE__*/getAugmentedNamespace(tools$1);

/* eslint no-prototype-builtins: 0 */
const flatstr$1 = require$$2$E;
const {
  lsCacheSym: lsCacheSym$1,
  levelValSym: levelValSym$1,
  useOnlyCustomLevelsSym: useOnlyCustomLevelsSym$2,
  streamSym: streamSym$2,
  formattersSym: formattersSym$2,
  hooksSym: hooksSym$1
} = require$$5$j;
const { noop: noop$1, genLog } = require$$7$c;

const levels$1 = {
  trace: 10,
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  fatal: 60
};
const levelMethods = {
  fatal: (hook) => {
    const logFatal = genLog(levels$1.fatal, hook);
    return function (...args) {
      const stream = this[streamSym$2];
      logFatal.call(this, ...args);
      if (typeof stream.flushSync === 'function') {
        try {
          stream.flushSync();
        } catch (e) {
          // https://github.com/pinojs/pino/pull/740#discussion_r346788313
        }
      }
    }
  },
  error: (hook) => genLog(levels$1.error, hook),
  warn: (hook) => genLog(levels$1.warn, hook),
  info: (hook) => genLog(levels$1.info, hook),
  debug: (hook) => genLog(levels$1.debug, hook),
  trace: (hook) => genLog(levels$1.trace, hook)
};

const nums = Object.keys(levels$1).reduce((o, k) => {
  o[levels$1[k]] = k;
  return o
}, {});

const initialLsCache$1 = Object.keys(nums).reduce((o, k) => {
  o[k] = flatstr$1('{"level":' + Number(k));
  return o
}, {});

function genLsCache$2 (instance) {
  const formatter = instance[formattersSym$2].level;
  const { labels } = instance.levels;
  const cache = {};
  for (const label in labels) {
    const level = formatter(labels[label], Number(label));
    cache[label] = JSON.stringify(level).slice(0, -1);
  }
  instance[lsCacheSym$1] = cache;
  return instance
}

function isStandardLevel (level, useOnlyCustomLevels) {
  if (useOnlyCustomLevels) {
    return false
  }

  switch (level) {
    case 'fatal':
    case 'error':
    case 'warn':
    case 'info':
    case 'debug':
    case 'trace':
      return true
    default:
      return false
  }
}

function setLevel$1 (level) {
  const { labels, values } = this.levels;
  if (typeof level === 'number') {
    if (labels[level] === undefined) throw Error('unknown level value' + level)
    level = labels[level];
  }
  if (values[level] === undefined) throw Error('unknown level ' + level)
  const preLevelVal = this[levelValSym$1];
  const levelVal = this[levelValSym$1] = values[level];
  const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym$2];
  const hook = this[hooksSym$1].logMethod;

  for (const key in values) {
    if (levelVal > values[key]) {
      this[key] = noop$1;
      continue
    }
    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
  }

  this.emit(
    'level-change',
    level,
    levelVal,
    labels[preLevelVal],
    preLevelVal
  );
}

function getLevel$1 (level) {
  const { levels, levelVal } = this;
  // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)
  return (levels && levels.labels) ? levels.labels[levelVal] : ''
}

function isLevelEnabled$1 (logLevel) {
  const { values } = this.levels;
  const logLevelVal = values[logLevel];
  return logLevelVal !== undefined && (logLevelVal >= this[levelValSym$1])
}

function mappings$2 (customLevels = null, useOnlyCustomLevels = false) {
  const customNums = customLevels
    /* eslint-disable */
    ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k;
        return o
      }, {})
    : null;
    /* eslint-enable */

  const labels = Object.assign(
    Object.create(Object.prototype, { Infinity: { value: 'silent' } }),
    useOnlyCustomLevels ? null : nums,
    customNums
  );
  const values = Object.assign(
    Object.create(Object.prototype, { silent: { value: Infinity } }),
    useOnlyCustomLevels ? null : levels$1,
    customLevels
  );
  return { labels, values }
}

function assertDefaultLevelFound$1 (defaultLevel, customLevels, useOnlyCustomLevels) {
  if (typeof defaultLevel === 'number') {
    const values = [].concat(
      Object.keys(customLevels || {}).map(key => customLevels[key]),
      useOnlyCustomLevels ? [] : Object.keys(nums).map(level => +level),
      Infinity
    );
    if (!values.includes(defaultLevel)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`)
    }
    return
  }

  const labels = Object.assign(
    Object.create(Object.prototype, { silent: { value: Infinity } }),
    useOnlyCustomLevels ? null : levels$1,
    customLevels
  );
  if (!(defaultLevel in labels)) {
    throw Error(`default level:${defaultLevel} must be included in custom levels`)
  }
}

function assertNoLevelCollisions$1 (levels, customLevels) {
  const { labels, values } = levels;
  for (const k in customLevels) {
    if (k in values) {
      throw Error('levels cannot be overridden')
    }
    if (customLevels[k] in labels) {
      throw Error('pre-existing level values cannot be used for new levels')
    }
  }
}

var levels_1 = {
  initialLsCache: initialLsCache$1,
  genLsCache: genLsCache$2,
  levelMethods,
  getLevel: getLevel$1,
  setLevel: setLevel$1,
  isLevelEnabled: isLevelEnabled$1,
  mappings: mappings$2,
  assertNoLevelCollisions: assertNoLevelCollisions$1,
  assertDefaultLevelFound: assertDefaultLevelFound$1
};

var levels$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), levels_1, {
    'default': levels_1
}));

var require$$6$f = /*@__PURE__*/getAugmentedNamespace(levels$2);

var name$3 = "pino";
var version$6 = "6.14.0";
var description = "super fast, all natural json logger";
var main = "pino.js";
var browser$4 = "./browser.js";
var files = [
	"pino.js",
	"bin.js",
	"browser.js",
	"pretty.js",
	"usage.txt",
	"test",
	"docs",
	"example.js",
	"lib"
];
var scripts = {
	docs: "docsify serve",
	"browser-test": "airtap --local 8080 test/browser*test.js",
	lint: "eslint .",
	test: "npm run lint && tap --100 test/*test.js test/*/*test.js",
	"test-ci": "npm run lint && tap test/*test.js test/*/*test.js --coverage-report=lcovonly",
	"cov-ui": "tap --coverage-report=html test/*test.js test/*/*test.js",
	bench: "node benchmarks/utils/runbench all",
	"bench-basic": "node benchmarks/utils/runbench basic",
	"bench-object": "node benchmarks/utils/runbench object",
	"bench-deep-object": "node benchmarks/utils/runbench deep-object",
	"bench-multi-arg": "node benchmarks/utils/runbench multi-arg",
	"bench-longs-tring": "node benchmarks/utils/runbench long-string",
	"bench-child": "node benchmarks/utils/runbench child",
	"bench-child-child": "node benchmarks/utils/runbench child-child",
	"bench-child-creation": "node benchmarks/utils/runbench child-creation",
	"bench-formatters": "node benchmarks/utils/runbench formatters",
	"update-bench-doc": "node benchmarks/utils/generate-benchmark-doc > docs/benchmarks.md"
};
var bin = {
	pino: "./bin.js"
};
var precommit = "test";
var repository = {
	type: "git",
	url: "git+https://github.com/pinojs/pino.git"
};
var keywords = [
	"fast",
	"logger",
	"stream",
	"json"
];
var author = "Matteo Collina <hello@matteocollina.com>";
var contributors = [
	"David Mark Clements <huperekchuno@googlemail.com>",
	"James Sumners <james.sumners@gmail.com>",
	"Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)"
];
var license = "MIT";
var bugs = {
	url: "https://github.com/pinojs/pino/issues"
};
var homepage = "http://getpino.io";
var devDependencies = {
	airtap: "4.0.3",
	benchmark: "^2.1.4",
	bole: "^4.0.0",
	bunyan: "^1.8.14",
	"docsify-cli": "^4.4.1",
	eslint: "^7.17.0",
	"eslint-config-standard": "^16.0.2",
	"eslint-plugin-import": "^2.22.1",
	"eslint-plugin-node": "^11.1.0",
	"eslint-plugin-promise": "^5.1.0",
	execa: "^5.0.0",
	fastbench: "^1.0.1",
	"flush-write-stream": "^2.0.0",
	"import-fresh": "^3.2.1",
	log: "^6.0.0",
	loglevel: "^1.6.7",
	"pino-pretty": "^5.0.0",
	"pre-commit": "^1.2.2",
	proxyquire: "^2.1.3",
	pump: "^3.0.0",
	semver: "^7.0.0",
	split2: "^3.1.1",
	steed: "^1.1.3",
	"strip-ansi": "^6.0.0",
	tap: "^15.0.1",
	tape: "^5.0.0",
	through2: "^4.0.0",
	winston: "^3.3.3"
};
var dependencies = {
	"fast-redact": "^3.0.0",
	"fast-safe-stringify": "^2.0.8",
	"process-warning": "^1.0.0",
	flatstr: "^1.0.12",
	"pino-std-serializers": "^3.1.0",
	"quick-format-unescaped": "^4.0.3",
	"sonic-boom": "^1.0.2"
};
var require$$0$u = {
	name: name$3,
	version: version$6,
	description: description,
	main: main,
	browser: browser$4,
	files: files,
	scripts: scripts,
	bin: bin,
	precommit: precommit,
	repository: repository,
	keywords: keywords,
	author: author,
	contributors: contributors,
	license: license,
	bugs: bugs,
	homepage: homepage,
	devDependencies: devDependencies,
	dependencies: dependencies
};

const { version: version$5 } = require$$0$u;

var meta$2 = { version: version$5 };

var meta$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), meta$2, {
    'default': meta$2
}));

var require$$8$9 = /*@__PURE__*/getAugmentedNamespace(meta$3);

/* eslint no-prototype-builtins: 0 */

const { EventEmitter } = require$$1$19;
const SonicBoom = require$$1$X;
const flatstr = require$$2$E;
const warning = require$$3$w;
const {
  lsCacheSym,
  levelValSym,
  setLevelSym: setLevelSym$1,
  getLevelSym,
  chindingsSym: chindingsSym$1,
  parsedChindingsSym,
  mixinSym: mixinSym$1,
  asJsonSym,
  writeSym,
  mixinMergeStrategySym: mixinMergeStrategySym$1,
  timeSym: timeSym$1,
  timeSliceIndexSym: timeSliceIndexSym$1,
  streamSym: streamSym$1,
  serializersSym: serializersSym$1,
  formattersSym: formattersSym$1,
  useOnlyCustomLevelsSym: useOnlyCustomLevelsSym$1,
  needsMetadataGsym,
  redactFmtSym: redactFmtSym$1,
  stringifySym: stringifySym$1,
  formatOptsSym: formatOptsSym$1,
  stringifiersSym: stringifiersSym$1
} = require$$5$j;
const {
  getLevel,
  setLevel,
  isLevelEnabled,
  mappings: mappings$1,
  initialLsCache,
  genLsCache: genLsCache$1,
  assertNoLevelCollisions
} = require$$6$f;
const {
  asChindings: asChindings$1,
  asJson,
  buildFormatters: buildFormatters$1,
  stringify: stringify$1
} = require$$7$c;
const {
  version: version$4
} = require$$8$9;
const redaction$1 = require$$2$F;

// note: use of class is satirical
// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127
const constructor = class Pino {};
const prototype = {
  constructor,
  child,
  bindings,
  setBindings,
  flush,
  isLevelEnabled,
  version: version$4,
  get level () { return this[getLevelSym]() },
  set level (lvl) { this[setLevelSym$1](lvl); },
  get levelVal () { return this[levelValSym] },
  set levelVal (n) { throw Error('levelVal is read-only') },
  [lsCacheSym]: initialLsCache,
  [writeSym]: write$1,
  [asJsonSym]: asJson,
  [getLevelSym]: getLevel,
  [setLevelSym$1]: setLevel
};

Object.setPrototypeOf(prototype, EventEmitter.prototype);

// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing
var proto$1 = function () {
  return Object.create(prototype)
};

const resetChildingsFormatter = bindings => bindings;
function child (bindings, options) {
  if (!bindings) {
    throw Error('missing bindings for child Pino')
  }
  options = options || {}; // default options to empty object
  const serializers = this[serializersSym$1];
  const formatters = this[formattersSym$1];
  const instance = Object.create(this);

  if (bindings.hasOwnProperty('serializers') === true) {
    warning.emit('PINODEP004');
    options.serializers = bindings.serializers;
  }
  if (bindings.hasOwnProperty('formatters') === true) {
    warning.emit('PINODEP005');
    options.formatters = bindings.formatters;
  }
  if (bindings.hasOwnProperty('customLevels') === true) {
    warning.emit('PINODEP006');
    options.customLevels = bindings.customLevels;
  }
  if (bindings.hasOwnProperty('level') === true) {
    warning.emit('PINODEP007');
    options.level = bindings.level;
  }
  if (options.hasOwnProperty('serializers') === true) {
    instance[serializersSym$1] = Object.create(null);

    for (const k in serializers) {
      instance[serializersSym$1][k] = serializers[k];
    }
    const parentSymbols = Object.getOwnPropertySymbols(serializers);
    /* eslint no-var: off */
    for (var i = 0; i < parentSymbols.length; i++) {
      const ks = parentSymbols[i];
      instance[serializersSym$1][ks] = serializers[ks];
    }

    for (const bk in options.serializers) {
      instance[serializersSym$1][bk] = options.serializers[bk];
    }
    const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
    for (var bi = 0; bi < bindingsSymbols.length; bi++) {
      const bks = bindingsSymbols[bi];
      instance[serializersSym$1][bks] = options.serializers[bks];
    }
  } else instance[serializersSym$1] = serializers;
  if (options.hasOwnProperty('formatters')) {
    const { level, bindings: chindings, log } = options.formatters;
    instance[formattersSym$1] = buildFormatters$1(
      level || formatters.level,
      chindings || resetChildingsFormatter,
      log || formatters.log
    );
  } else {
    instance[formattersSym$1] = buildFormatters$1(
      formatters.level,
      resetChildingsFormatter,
      formatters.log
    );
  }
  if (options.hasOwnProperty('customLevels') === true) {
    assertNoLevelCollisions(this.levels, options.customLevels);
    instance.levels = mappings$1(options.customLevels, instance[useOnlyCustomLevelsSym$1]);
    genLsCache$1(instance);
  }

  // redact must place before asChindings and only replace if exist
  if ((typeof options.redact === 'object' && options.redact !== null) || Array.isArray(options.redact)) {
    instance.redact = options.redact; // replace redact directly
    const stringifiers = redaction$1(instance.redact, stringify$1);
    const formatOpts = { stringify: stringifiers[redactFmtSym$1] };
    instance[stringifySym$1] = stringify$1;
    instance[stringifiersSym$1] = stringifiers;
    instance[formatOptsSym$1] = formatOpts;
  }

  instance[chindingsSym$1] = asChindings$1(instance, bindings);
  const childLevel = options.level || this.level;
  instance[setLevelSym$1](childLevel);

  return instance
}

function bindings () {
  const chindings = this[chindingsSym$1];
  const chindingsJson = `{${chindings.substr(1)}}`; // at least contains ,"pid":7068,"hostname":"myMac"
  const bindingsFromJson = JSON.parse(chindingsJson);
  delete bindingsFromJson.pid;
  delete bindingsFromJson.hostname;
  return bindingsFromJson
}

function setBindings (newBindings) {
  const chindings = asChindings$1(this, newBindings);
  this[chindingsSym$1] = chindings;
  delete this[parsedChindingsSym];
}

/**
 * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.
 * Fields from `mergeObject` have higher priority in this strategy.
 *
 * @param {Object} mergeObject The object a user has supplied to the logging function.
 * @param {Object} mixinObject The result of the `mixin` method.
 * @return {Object}
 */
function defaultMixinMergeStrategy (mergeObject, mixinObject) {
  return Object.assign(mixinObject, mergeObject)
}

function write$1 (_obj, msg, num) {
  const t = this[timeSym$1]();
  const mixin = this[mixinSym$1];
  const mixinMergeStrategy = this[mixinMergeStrategySym$1] || defaultMixinMergeStrategy;
  const objError = _obj instanceof Error;
  let obj;

  if (_obj === undefined || _obj === null) {
    obj = mixin ? mixin({}) : {};
  } else {
    obj = mixinMergeStrategy(_obj, mixin ? mixin(_obj) : {});
    if (!msg && objError) {
      msg = _obj.message;
    }

    if (objError) {
      obj.stack = _obj.stack;
      if (!obj.type) {
        obj.type = 'Error';
      }
    }
  }

  const s = this[asJsonSym](obj, msg, num, t);

  const stream = this[streamSym$1];
  if (stream[needsMetadataGsym] === true) {
    stream.lastLevel = num;
    stream.lastObj = obj;
    stream.lastMsg = msg;
    stream.lastTime = t.slice(this[timeSliceIndexSym$1]);
    stream.lastLogger = this; // for child loggers
  }
  if (stream instanceof SonicBoom) stream.write(s);
  else stream.write(flatstr(s));
}

function flush () {
  const stream = this[streamSym$1];
  if ('flush' in stream) stream.flush();
}

var proto$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), proto$1, {
    'default': proto$1
}));

var require$$4$k = /*@__PURE__*/getAugmentedNamespace(proto$2);

/* eslint no-prototype-builtins: 0 */
const os = require$$0$12;
const stdSerializers = require$$1$Z;
const redaction = require$$2$F;
const time$3 = require$$3$x;
const proto = require$$4$k;
const symbols = require$$5$j;
const { assertDefaultLevelFound, mappings, genLsCache } = require$$6$f;
const {
  createArgsNormalizer,
  asChindings,
  final,
  stringify,
  buildSafeSonicBoom,
  buildFormatters,
  noop
} = require$$7$c;
const { version: version$3 } = require$$8$9;
const { mixinMergeStrategySym } = require$$5$j;
const {
  chindingsSym,
  redactFmtSym,
  serializersSym,
  timeSym,
  timeSliceIndexSym,
  streamSym,
  stringifySym,
  stringifiersSym,
  setLevelSym,
  endSym,
  formatOptsSym,
  messageKeySym,
  nestedKeySym,
  mixinSym,
  useOnlyCustomLevelsSym,
  formattersSym,
  hooksSym
} = symbols;
const { epochTime, nullTime } = time$3;
const { pid } = browser$1$1;
const hostname = os.hostname();
const defaultErrorSerializer = stdSerializers.err;
const defaultOptions = {
  level: 'info',
  messageKey: 'msg',
  nestedKey: null,
  enabled: true,
  prettyPrint: false,
  base: { pid, hostname },
  serializers: Object.assign(Object.create(null), {
    err: defaultErrorSerializer
  }),
  formatters: Object.assign(Object.create(null), {
    bindings (bindings) {
      return bindings
    },
    level (label, number) {
      return { level: number }
    }
  }),
  hooks: {
    logMethod: undefined
  },
  timestamp: epochTime,
  name: undefined,
  redact: null,
  customLevels: null,
  levelKey: undefined,
  useOnlyCustomLevels: false
};

const normalize = createArgsNormalizer(defaultOptions);

const serializers = Object.assign(Object.create(null), stdSerializers);

function pino (...args) {
  const instance = {};
  const { opts, stream } = normalize(instance, ...args);
  const {
    redact,
    crlf,
    serializers,
    timestamp,
    messageKey,
    nestedKey,
    base,
    name,
    level,
    customLevels,
    useLevelLabels,
    changeLevelName,
    levelKey,
    mixin,
    mixinMergeStrategy,
    useOnlyCustomLevels,
    formatters,
    hooks
  } = opts;

  const allFormatters = buildFormatters(
    formatters.level,
    formatters.bindings,
    formatters.log
  );

  if (useLevelLabels && !(changeLevelName || levelKey)) {
    browser$1$1.emitWarning('useLevelLabels is deprecated, use the formatters.level option instead', 'Warning', 'PINODEP001');
    allFormatters.level = labelsFormatter;
  } else if ((changeLevelName || levelKey) && !useLevelLabels) {
    browser$1$1.emitWarning('changeLevelName and levelKey are deprecated, use the formatters.level option instead', 'Warning', 'PINODEP002');
    allFormatters.level = levelNameFormatter(changeLevelName || levelKey);
  } else if ((changeLevelName || levelKey) && useLevelLabels) {
    browser$1$1.emitWarning('useLevelLabels is deprecated, use the formatters.level option instead', 'Warning', 'PINODEP001');
    browser$1$1.emitWarning('changeLevelName and levelKey are deprecated, use the formatters.level option instead', 'Warning', 'PINODEP002');
    allFormatters.level = levelNameLabelFormatter(changeLevelName || levelKey);
  }

  if (serializers[Symbol.for('pino.*')]) {
    browser$1$1.emitWarning('The pino.* serializer is deprecated, use the formatters.log options instead', 'Warning', 'PINODEP003');
    allFormatters.log = serializers[Symbol.for('pino.*')];
  }

  if (!allFormatters.bindings) {
    allFormatters.bindings = defaultOptions.formatters.bindings;
  }
  if (!allFormatters.level) {
    allFormatters.level = defaultOptions.formatters.level;
  }

  const stringifiers = redact ? redaction(redact, stringify) : {};
  const formatOpts = redact
    ? { stringify: stringifiers[redactFmtSym] }
    : { stringify };
  const end = '}' + (crlf ? '\r\n' : '\n');
  const coreChindings = asChindings.bind(null, {
    [chindingsSym]: '',
    [serializersSym]: serializers,
    [stringifiersSym]: stringifiers,
    [stringifySym]: stringify,
    [formattersSym]: allFormatters
  });

  let chindings = '';
  if (base !== null) {
    if (name === undefined) {
      chindings = coreChindings(base);
    } else {
      chindings = coreChindings(Object.assign({}, base, { name }));
    }
  }

  const time = (timestamp instanceof Function)
    ? timestamp
    : (timestamp ? epochTime : nullTime);
  const timeSliceIndex = time().indexOf(':') + 1;

  if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true')
  if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`)

  assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
  const levels = mappings(customLevels, useOnlyCustomLevels);

  Object.assign(instance, {
    levels,
    [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
    [streamSym]: stream,
    [timeSym]: time,
    [timeSliceIndexSym]: timeSliceIndex,
    [stringifySym]: stringify,
    [stringifiersSym]: stringifiers,
    [endSym]: end,
    [formatOptsSym]: formatOpts,
    [messageKeySym]: messageKey,
    [nestedKeySym]: nestedKey,
    [serializersSym]: serializers,
    [mixinSym]: mixin,
    [mixinMergeStrategySym]: mixinMergeStrategy,
    [chindingsSym]: chindings,
    [formattersSym]: allFormatters,
    [hooksSym]: hooks,
    silent: noop
  });

  Object.setPrototypeOf(instance, proto());

  genLsCache(instance);

  instance[setLevelSym](level);

  return instance
}

function labelsFormatter (label, number) {
  return { level: label }
}

function levelNameFormatter (name) {
  return function (label, number) {
    return { [name]: number }
  }
}

function levelNameLabelFormatter (name) {
  return function (label, number) {
    return { [name]: label }
  }
}

pino$2.exports = pino;

var extreme = pino$2.exports.extreme = (dest = browser$1$1.stdout.fd) => {
  browser$1$1.emitWarning(
    'The pino.extreme() option is deprecated and will be removed in v7. Use pino.destination({ sync: false }) instead.',
    { code: 'extreme_deprecation' }
  );
  return buildSafeSonicBoom({ dest, minLength: 4096, sync: false })
};

var destination = pino$2.exports.destination = (dest = browser$1$1.stdout.fd) => {
  if (typeof dest === 'object') {
    dest.dest = dest.dest || browser$1$1.stdout.fd;
    return buildSafeSonicBoom(dest)
  } else {
    return buildSafeSonicBoom({ dest, minLength: 0, sync: true })
  }
};

var final_1 = pino$2.exports.final = final;
var levels = pino$2.exports.levels = mappings();
var stdSerializers_1 = pino$2.exports.stdSerializers = serializers;
var stdTimeFunctions = pino$2.exports.stdTimeFunctions = Object.assign({}, time$3);
var symbols_1 = pino$2.exports.symbols = symbols;
var version_1 = pino$2.exports.version = version$3;

// Enables default and name export with TypeScript and Babel
pino$2.exports.default = pino;
var pino_2 = pino$2.exports.pino = pino;

var pino_1$3 = pino$2.exports;

var pino$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pino$2.exports, {
    'default': pino_1$3,
    extreme: extreme,
    destination: destination,
    final: final_1,
    levels: levels,
    stdSerializers: stdSerializers_1,
    stdTimeFunctions: stdTimeFunctions,
    symbols: symbols_1,
    version: version_1,
    pino: pino_2
}));

var require$$6$e = /*@__PURE__*/getAugmentedNamespace(pino$1);

var cjs$o = {};

var nodeJs$1 = {};

var cjs$n = {};

Object.defineProperty(cjs$n, "__esModule", { value: true });
function safeJsonParse$2(value) {
    if (typeof value !== 'string') {
        throw new Error(`Cannot safe json parse value of type ${typeof value}`);
    }
    try {
        return JSON.parse(value);
    }
    catch (_a) {
        return value;
    }
}
var safeJsonParse_1 = cjs$n.safeJsonParse = safeJsonParse$2;
function safeJsonStringify$2(value) {
    return typeof value === 'string'
        ? value
        : JSON.stringify(value, (key, value) => typeof value === 'undefined' ? null : value);
}
var safeJsonStringify_1 = cjs$n.safeJsonStringify = safeJsonStringify$2;

var cjs$m = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$n, {
    safeJsonParse: safeJsonParse_1,
    safeJsonStringify: safeJsonStringify_1,
    'default': cjs$n
}));

var require$$0$t = /*@__PURE__*/getAugmentedNamespace(cjs$m);

var db$1 = {};

Object.defineProperty(db$1, "__esModule", { value: true });
function importLokijs() {
    try {
        return require$$0$13;
    }
    catch (e) {
        throw new Error(`To use WalletConnect server side, you'll need to install the "lokijs" dependency. If you are seeing this error during a build / in an SSR environment, you can add "lokijs" as a devDependency to make this error go away.`);
    }
}
let Lokijs;
class Db {
    constructor(opts) {
        if (!Lokijs) {
            Lokijs = importLokijs();
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.db) === ":memory:") {
            this.database = new Lokijs(opts === null || opts === void 0 ? void 0 : opts.db, {});
        }
        else {
            this.database = new Lokijs(opts === null || opts === void 0 ? void 0 : opts.db, {
                autoload: true,
                autoloadCallback: opts.callback,
            });
        }
    }
    static create(opts) {
        const db = opts.db;
        if (db === ":memory:") {
            return new Db(opts);
        }
        if (!Db.instances[db]) {
            Db.instances[db] = new Db(opts);
        }
        return Db.instances[db];
    }
}
var _default$2 = db$1.default = Db;
Db.instances = {};

var db = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), db$1, {
    'default': _default$2
}));

var require$$2$A = /*@__PURE__*/getAugmentedNamespace(db);

Object.defineProperty(nodeJs$1, "__esModule", { value: true });
var KeyValueStorage_1 = nodeJs$1.KeyValueStorage = void 0;
const tslib_1$n = require$$0$G;
const safe_json_utils_1$1 = require$$0$t;
const db_1 = tslib_1$n.__importDefault(require$$2$A);
const DB_NAME = "walletconnect.db";
class KeyValueStorage {
    constructor(opts) {
        this.initialized = false;
        this.inMemory = false;
        this.databaseInitialize = (db) => {
            if (db) {
                this.db = db;
            }
            this.database = this.db.getCollection("entries");
            if (this.database === null) {
                this.database = this.db.addCollection("entries", { unique: ["id"] });
            }
            this.initialized = true;
        };
        if ((opts === null || opts === void 0 ? void 0 : opts.database) === ":memory:") {
            this.inMemory = true;
        }
        const instance = db_1.default.create({
            db: (opts === null || opts === void 0 ? void 0 : opts.database) || (opts === null || opts === void 0 ? void 0 : opts.table) || DB_NAME,
            callback: this.databaseInitialize,
        });
        this.db = instance.database;
        this.databaseInitialize(this.db);
    }
    getKeys() {
        return tslib_1$n.__awaiter(this, void 0, void 0, function* () {
            yield this.initilization();
            const keys = (yield this.database.find()).map((item) => item.id);
            return keys;
        });
    }
    getEntries() {
        return tslib_1$n.__awaiter(this, void 0, void 0, function* () {
            yield this.initilization();
            const entries = (yield this.database.find()).map((item) => [item.id, safe_json_utils_1$1.safeJsonParse(item.value)]);
            return entries;
        });
    }
    getItem(key) {
        return tslib_1$n.__awaiter(this, void 0, void 0, function* () {
            yield this.initilization();
            const item = this.database.findOne({ id: { $eq: key } });
            if (item === null) {
                return undefined;
            }
            return safe_json_utils_1$1.safeJsonParse(item.value);
        });
    }
    setItem(key, value) {
        return tslib_1$n.__awaiter(this, void 0, void 0, function* () {
            yield this.initilization();
            const item = this.database.findOne({ id: { $eq: key } });
            if (item) {
                item.value = safe_json_utils_1$1.safeJsonStringify(value);
                this.database.update(item);
            }
            else {
                this.database.insert({ id: key, value: safe_json_utils_1$1.safeJsonStringify(value) });
            }
            yield this.persist();
        });
    }
    removeItem(key) {
        return tslib_1$n.__awaiter(this, void 0, void 0, function* () {
            yield this.initilization();
            const item = this.database.findOne({ id: { $eq: key } });
            yield this.database.remove(item);
            yield this.persist();
        });
    }
    initilization() {
        return tslib_1$n.__awaiter(this, void 0, void 0, function* () {
            if (this.initialized) {
                return;
            }
            yield new Promise((resolve) => {
                const interval = setInterval(() => {
                    if (this.initialized) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 20);
            });
        });
    }
    persist() {
        return tslib_1$n.__awaiter(this, void 0, void 0, function* () {
            if (this.inMemory)
                return;
            this.db.saveDatabase();
        });
    }
}
KeyValueStorage_1 = nodeJs$1.KeyValueStorage = KeyValueStorage;
var _default$1 = nodeJs$1.default = KeyValueStorage;

var nodeJs = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), nodeJs$1, {
    get KeyValueStorage () { return KeyValueStorage_1; },
    'default': _default$1
}));

var require$$1$S = /*@__PURE__*/getAugmentedNamespace(nodeJs);

var shared$1 = {};

var types$5 = {};

Object.defineProperty(types$5, "__esModule", { value: true });
var IKeyValueStorage_1 = types$5.IKeyValueStorage = void 0;
class IKeyValueStorage {
}
IKeyValueStorage_1 = types$5.IKeyValueStorage = IKeyValueStorage;

var types$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), types$5, {
    get IKeyValueStorage () { return IKeyValueStorage_1; },
    'default': types$5
}));

var require$$1$R = /*@__PURE__*/getAugmentedNamespace(types$4);

var utils$9 = {};

Object.defineProperty(utils$9, "__esModule", { value: true });
var parseEntry_1 = utils$9.parseEntry = void 0;
const safe_json_utils_1 = require$$0$t;
function parseEntry(entry) {
    var _a;
    return [entry[0], safe_json_utils_1.safeJsonParse((_a = entry[1]) !== null && _a !== void 0 ? _a : "")];
}
parseEntry_1 = utils$9.parseEntry = parseEntry;

var utils$8 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), utils$9, {
    get parseEntry () { return parseEntry_1; },
    'default': utils$9
}));

var require$$2$z = /*@__PURE__*/getAugmentedNamespace(utils$8);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$R, exports);
tslib_1.__exportStar(require$$2$z, exports);

}(shared$1));

var index$m = /*@__PURE__*/getDefaultExportFromCjs(shared$1);

var shared = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), shared$1, {
    'default': index$m
}));

var require$$2$y = /*@__PURE__*/getAugmentedNamespace(shared);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
const node_js_1 = tslib_1.__importDefault(require$$1$S);
tslib_1.__exportStar(require$$1$S, exports);
tslib_1.__exportStar(require$$2$y, exports);
exports.default = node_js_1.default;

}(cjs$o));

var index$l = /*@__PURE__*/getDefaultExportFromCjs(cjs$o);

var cjs$l = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$o, {
    'default': index$l
}));

var require$$3$s = /*@__PURE__*/getAugmentedNamespace(cjs$l);

var cjs$k = {};

var heartbeat$5 = {};

var cjs$j = {};

var utils$7 = {};

var delay$2 = {};

Object.defineProperty(delay$2, "__esModule", { value: true });
var delay_2 = delay$2.delay = void 0;
function delay(timeout) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(true);
        }, timeout);
    });
}
delay_2 = delay$2.delay = delay;

var delay$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), delay$2, {
    get delay () { return delay_2; },
    'default': delay$2
}));

var require$$1$Q = /*@__PURE__*/getAugmentedNamespace(delay$1);

var convert$1 = {};

var constants$i = {};

var misc$6 = {};

Object.defineProperty(misc$6, "__esModule", { value: true });
var ONE_THOUSAND = misc$6.ONE_THOUSAND = ONE_HUNDRED = misc$6.ONE_HUNDRED = void 0;
var ONE_HUNDRED = misc$6.ONE_HUNDRED = 100;
ONE_THOUSAND = misc$6.ONE_THOUSAND = 1000;

var misc$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), misc$6, {
    get ONE_THOUSAND () { return ONE_THOUSAND; },
    get ONE_HUNDRED () { return ONE_HUNDRED; },
    'default': misc$6
}));

var require$$1$P = /*@__PURE__*/getAugmentedNamespace(misc$5);

var time$2 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
exports.ONE_SECOND = 1;
exports.FIVE_SECONDS = 5;
exports.TEN_SECONDS = 10;
exports.THIRTY_SECONDS = 30;
exports.SIXTY_SECONDS = 60;
exports.ONE_MINUTE = exports.SIXTY_SECONDS;
exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
exports.ONE_HOUR = exports.SIXTY_MINUTES;
exports.THREE_HOURS = exports.ONE_HOUR * 3;
exports.SIX_HOURS = exports.ONE_HOUR * 6;
exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
exports.THREE_DAYS = exports.ONE_DAY * 3;
exports.FIVE_DAYS = exports.ONE_DAY * 5;
exports.SEVEN_DAYS = exports.ONE_DAY * 7;
exports.THIRTY_DAYS = exports.ONE_DAY * 30;
exports.ONE_WEEK = exports.SEVEN_DAYS;
exports.TWO_WEEKS = exports.ONE_WEEK * 2;
exports.THREE_WEEKS = exports.ONE_WEEK * 3;
exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
exports.ONE_YEAR = exports.ONE_DAY * 365;

}(time$2));

var time = /*@__PURE__*/getDefaultExportFromCjs(time$2);

var time$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), time$2, {
    'default': time
}));

var require$$2$x = /*@__PURE__*/getAugmentedNamespace(time$1);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$P, exports);
tslib_1.__exportStar(require$$2$x, exports);

}(constants$i));

var index$k = /*@__PURE__*/getDefaultExportFromCjs(constants$i);

var constants$h = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constants$i, {
    'default': index$k
}));

var require$$4$j = /*@__PURE__*/getAugmentedNamespace(constants$h);

Object.defineProperty(convert$1, "__esModule", { value: true });
var fromMiliseconds_1 = convert$1.fromMiliseconds = toMiliseconds_1 = convert$1.toMiliseconds = void 0;
const constants_1$h = require$$4$j;
function toMiliseconds(seconds) {
    return seconds * constants_1$h.ONE_THOUSAND;
}
var toMiliseconds_1 = convert$1.toMiliseconds = toMiliseconds;
function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1$h.ONE_THOUSAND);
}
fromMiliseconds_1 = convert$1.fromMiliseconds = fromMiliseconds;

var convert = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), convert$1, {
    get fromMiliseconds () { return fromMiliseconds_1; },
    get toMiliseconds () { return toMiliseconds_1; },
    'default': convert$1
}));

var require$$2$w = /*@__PURE__*/getAugmentedNamespace(convert);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$Q, exports);
tslib_1.__exportStar(require$$2$w, exports);

}(utils$7));

var index$j = /*@__PURE__*/getDefaultExportFromCjs(utils$7);

var utils$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), utils$7, {
    'default': index$j
}));

var require$$1$O = /*@__PURE__*/getAugmentedNamespace(utils$6);

var watch$3 = {};

Object.defineProperty(watch$3, "__esModule", { value: true });
var Watch_1 = watch$3.Watch = void 0;
class Watch {
    constructor() {
        this.timestamps = new Map();
    }
    start(label) {
        if (this.timestamps.has(label)) {
            throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
    }
    stop(label) {
        const timestamp = this.get(label);
        if (typeof timestamp.elapsed !== "undefined") {
            throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, { started: timestamp.started, elapsed });
    }
    get(label) {
        const timestamp = this.timestamps.get(label);
        if (typeof timestamp === "undefined") {
            throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp;
    }
    elapsed(label) {
        const timestamp = this.get(label);
        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
    }
}
Watch_1 = watch$3.Watch = Watch;
var _default = watch$3.default = Watch;

var watch$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), watch$3, {
    get Watch () { return Watch_1; },
    'default': _default
}));

var require$$2$v = /*@__PURE__*/getAugmentedNamespace(watch$2);

var types$3 = {};

var watch$1 = {};

Object.defineProperty(watch$1, "__esModule", { value: true });
var IWatch_1 = watch$1.IWatch = void 0;
class IWatch {
}
IWatch_1 = watch$1.IWatch = IWatch;

var watch = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), watch$1, {
    get IWatch () { return IWatch_1; },
    'default': watch$1
}));

var require$$1$N = /*@__PURE__*/getAugmentedNamespace(watch);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$N, exports);

}(types$3));

var index$i = /*@__PURE__*/getDefaultExportFromCjs(types$3);

var types$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), types$3, {
    'default': index$i
}));

var require$$3$r = /*@__PURE__*/getAugmentedNamespace(types$2);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$O, exports);
tslib_1.__exportStar(require$$2$v, exports);
tslib_1.__exportStar(require$$3$r, exports);
tslib_1.__exportStar(require$$4$j, exports);

}(cjs$j));

var index$h = /*@__PURE__*/getDefaultExportFromCjs(cjs$j);

var cjs$i = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$j, {
    'default': index$h
}));

var require$$3$q = /*@__PURE__*/getAugmentedNamespace(cjs$i);

var types$1 = {};

var heartbeat$4 = {};

class IEvents$2 {
}

var esm$6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IEvents: IEvents$2
});

var require$$0$s = /*@__PURE__*/getAugmentedNamespace(esm$6);

Object.defineProperty(heartbeat$4, "__esModule", { value: true });
var IHeartBeat_1 = heartbeat$4.IHeartBeat = void 0;
const events_1$h = require$$0$s;
class IHeartBeat extends events_1$h.IEvents {
    constructor(opts) {
        super();
    }
}
IHeartBeat_1 = heartbeat$4.IHeartBeat = IHeartBeat;

var heartbeat$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), heartbeat$4, {
    get IHeartBeat () { return IHeartBeat_1; },
    'default': heartbeat$4
}));

var require$$1$M = /*@__PURE__*/getAugmentedNamespace(heartbeat$3);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$M, exports);

}(types$1));

var index$g = /*@__PURE__*/getDefaultExportFromCjs(types$1);

var types = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), types$1, {
    'default': index$g
}));

var require$$2$u = /*@__PURE__*/getAugmentedNamespace(types);

var constants$g = {};

var heartbeat$2 = {};

Object.defineProperty(heartbeat$2, "__esModule", { value: true });
var HEARTBEAT_EVENTS = heartbeat$2.HEARTBEAT_EVENTS = HEARTBEAT_INTERVAL = heartbeat$2.HEARTBEAT_INTERVAL = void 0;
const time_1$a = require$$3$q;
var HEARTBEAT_INTERVAL = heartbeat$2.HEARTBEAT_INTERVAL = time_1$a.FIVE_SECONDS;
HEARTBEAT_EVENTS = heartbeat$2.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse",
};

var heartbeat$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), heartbeat$2, {
    get HEARTBEAT_EVENTS () { return HEARTBEAT_EVENTS; },
    get HEARTBEAT_INTERVAL () { return HEARTBEAT_INTERVAL; },
    'default': heartbeat$2
}));

var require$$1$L = /*@__PURE__*/getAugmentedNamespace(heartbeat$1);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$L, exports);

}(constants$g));

var index$f = /*@__PURE__*/getDefaultExportFromCjs(constants$g);

var constants$f = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constants$g, {
    'default': index$f
}));

var require$$3$p = /*@__PURE__*/getAugmentedNamespace(constants$f);

Object.defineProperty(heartbeat$5, "__esModule", { value: true });
var HeartBeat_1 = heartbeat$5.HeartBeat = void 0;
const tslib_1$m = require$$0$G;
const events_1$g = require$$1$19;
const time_1$9 = require$$3$q;
const types_1$a = require$$2$u;
const constants_1$g = require$$3$p;
class HeartBeat extends types_1$a.IHeartBeat {
    constructor(opts) {
        super(opts);
        this.events = new events_1$g.EventEmitter();
        this.interval = constants_1$g.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1$g.HEARTBEAT_INTERVAL;
    }
    static init(opts) {
        return tslib_1$m.__awaiter(this, void 0, void 0, function* () {
            const heartbeat = new HeartBeat(opts);
            yield heartbeat.init();
            return heartbeat;
        });
    }
    init() {
        return tslib_1$m.__awaiter(this, void 0, void 0, function* () {
            yield this.initialize();
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    initialize() {
        return tslib_1$m.__awaiter(this, void 0, void 0, function* () {
            setInterval(() => this.pulse(), time_1$9.toMiliseconds(this.interval));
        });
    }
    pulse() {
        this.events.emit(constants_1$g.HEARTBEAT_EVENTS.pulse);
    }
}
HeartBeat_1 = heartbeat$5.HeartBeat = HeartBeat;

var heartbeat = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), heartbeat$5, {
    get HeartBeat () { return HeartBeat_1; },
    'default': heartbeat$5
}));

var require$$1$K = /*@__PURE__*/getAugmentedNamespace(heartbeat);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$K, exports);
tslib_1.__exportStar(require$$2$u, exports);
tslib_1.__exportStar(require$$3$p, exports);

}(cjs$k));

var index$e = /*@__PURE__*/getDefaultExportFromCjs(cjs$k);

var cjs$h = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$k, {
    'default': index$e
}));

var require$$1$J = /*@__PURE__*/getAugmentedNamespace(cjs$h);

var cjs$g = {};

var constants$e = {};

Object.defineProperty(constants$e, "__esModule", { value: true });
var PINO_CUSTOM_CONTEXT_KEY = constants$e.PINO_CUSTOM_CONTEXT_KEY = PINO_LOGGER_DEFAULTS = constants$e.PINO_LOGGER_DEFAULTS = void 0;
var PINO_LOGGER_DEFAULTS = constants$e.PINO_LOGGER_DEFAULTS = {
    level: "info",
};
PINO_CUSTOM_CONTEXT_KEY = constants$e.PINO_CUSTOM_CONTEXT_KEY = "custom_context";

var constants$d = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constants$e, {
    get PINO_CUSTOM_CONTEXT_KEY () { return PINO_CUSTOM_CONTEXT_KEY; },
    get PINO_LOGGER_DEFAULTS () { return PINO_LOGGER_DEFAULTS; },
    'default': constants$e
}));

var require$$1$I = /*@__PURE__*/getAugmentedNamespace(constants$d);

var utils$5 = {};

Object.defineProperty(utils$5, "__esModule", { value: true });
var generateChildLogger_1 = utils$5.generateChildLogger = formatChildLoggerContext_1 = utils$5.formatChildLoggerContext = getLoggerContext_1 = utils$5.getLoggerContext = setBrowserLoggerContext_1 = utils$5.setBrowserLoggerContext = getBrowserLoggerContext_1 = utils$5.getBrowserLoggerContext = getDefaultLoggerOptions_1 = utils$5.getDefaultLoggerOptions = void 0;
const constants_1$f = require$$1$I;
function getDefaultLoggerOptions(opts) {
    return Object.assign(Object.assign({}, opts), { level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_1$f.PINO_LOGGER_DEFAULTS.level });
}
var getDefaultLoggerOptions_1 = utils$5.getDefaultLoggerOptions = getDefaultLoggerOptions;
function getBrowserLoggerContext(logger, customContextKey = constants_1$f.PINO_CUSTOM_CONTEXT_KEY) {
    return logger[customContextKey] || "";
}
var getBrowserLoggerContext_1 = utils$5.getBrowserLoggerContext = getBrowserLoggerContext;
function setBrowserLoggerContext(logger, context, customContextKey = constants_1$f.PINO_CUSTOM_CONTEXT_KEY) {
    logger[customContextKey] = context;
    return logger;
}
var setBrowserLoggerContext_1 = utils$5.setBrowserLoggerContext = setBrowserLoggerContext;
function getLoggerContext(logger, customContextKey = constants_1$f.PINO_CUSTOM_CONTEXT_KEY) {
    let context = "";
    if (typeof logger.bindings === "undefined") {
        context = getBrowserLoggerContext(logger, customContextKey);
    }
    else {
        context = logger.bindings().context || "";
    }
    return context;
}
var getLoggerContext_1 = utils$5.getLoggerContext = getLoggerContext;
function formatChildLoggerContext(logger, childContext, customContextKey = constants_1$f.PINO_CUSTOM_CONTEXT_KEY) {
    const parentContext = getLoggerContext(logger, customContextKey);
    const context = parentContext.trim()
        ? `${parentContext}/${childContext}`
        : childContext;
    return context;
}
var formatChildLoggerContext_1 = utils$5.formatChildLoggerContext = formatChildLoggerContext;
function generateChildLogger(logger, childContext, customContextKey = constants_1$f.PINO_CUSTOM_CONTEXT_KEY) {
    const context = formatChildLoggerContext(logger, childContext, customContextKey);
    const child = logger.child({ context });
    return setBrowserLoggerContext(child, context, customContextKey);
}
generateChildLogger_1 = utils$5.generateChildLogger = generateChildLogger;

var utils$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), utils$5, {
    get generateChildLogger () { return generateChildLogger_1; },
    get formatChildLoggerContext () { return formatChildLoggerContext_1; },
    get getLoggerContext () { return getLoggerContext_1; },
    get setBrowserLoggerContext () { return setBrowserLoggerContext_1; },
    get getBrowserLoggerContext () { return getBrowserLoggerContext_1; },
    get getDefaultLoggerOptions () { return getDefaultLoggerOptions_1; },
    'default': utils$5
}));

var require$$2$t = /*@__PURE__*/getAugmentedNamespace(utils$4);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$I, exports);
tslib_1.__exportStar(require$$2$t, exports);

}(cjs$g));

var index$d = /*@__PURE__*/getDefaultExportFromCjs(cjs$g);

var cjs$f = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$g, {
    'default': index$d
}));

var require$$2$s = /*@__PURE__*/getAugmentedNamespace(cjs$f);

var cjs$e = {};

var core$8 = {};

var core$7 = {};

Object.defineProperty(core$7, "__esModule", { value: true });
var ICore_1 = core$7.ICore = void 0;
const events_1$f = require$$0$s;
class ICore extends events_1$f.IEvents {
    constructor(opts) {
        super();
        this.opts = opts;
        this.protocol = "wc";
        this.version = 2;
    }
}
ICore_1 = core$7.ICore = ICore;

var core$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), core$7, {
    get ICore () { return ICore_1; },
    'default': core$7
}));

var require$$1$H = /*@__PURE__*/getAugmentedNamespace(core$6);

var crypto$d = {};

Object.defineProperty(crypto$d, "__esModule", { value: true });
var ICrypto_1 = crypto$d.ICrypto = void 0;
class ICrypto {
    constructor(core, logger, keychain) {
        this.core = core;
        this.logger = logger;
    }
}
ICrypto_1 = crypto$d.ICrypto = ICrypto;

var crypto$c = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), crypto$d, {
    get ICrypto () { return ICrypto_1; },
    'default': crypto$d
}));

var require$$2$r = /*@__PURE__*/getAugmentedNamespace(crypto$c);

var history$5 = {};

Object.defineProperty(history$5, "__esModule", { value: true });
var IJsonRpcHistory_1 = history$5.IJsonRpcHistory = void 0;
const events_1$e = require$$0$s;
class IJsonRpcHistory extends events_1$e.IEvents {
    constructor(core, logger) {
        super();
        this.core = core;
        this.logger = logger;
        this.records = new Map();
    }
}
IJsonRpcHistory_1 = history$5.IJsonRpcHistory = IJsonRpcHistory;

var history$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), history$5, {
    get IJsonRpcHistory () { return IJsonRpcHistory_1; },
    'default': history$5
}));

var require$$3$o = /*@__PURE__*/getAugmentedNamespace(history$4);

var messages$5 = {};

Object.defineProperty(messages$5, "__esModule", { value: true });
var IMessageTracker_1 = messages$5.IMessageTracker = void 0;
class IMessageTracker {
    constructor(logger, core) {
        this.logger = logger;
        this.core = core;
    }
}
IMessageTracker_1 = messages$5.IMessageTracker = IMessageTracker;

var messages$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), messages$5, {
    get IMessageTracker () { return IMessageTracker_1; },
    'default': messages$5
}));

var require$$4$i = /*@__PURE__*/getAugmentedNamespace(messages$4);

var publisher$5 = {};

Object.defineProperty(publisher$5, "__esModule", { value: true });
var IPublisher_1 = publisher$5.IPublisher = void 0;
const events_1$d = require$$0$s;
class IPublisher extends events_1$d.IEvents {
    constructor(relayer, logger) {
        super();
        this.relayer = relayer;
        this.logger = logger;
    }
}
IPublisher_1 = publisher$5.IPublisher = IPublisher;

var publisher$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), publisher$5, {
    get IPublisher () { return IPublisher_1; },
    'default': publisher$5
}));

var require$$5$g = /*@__PURE__*/getAugmentedNamespace(publisher$4);

var relayer$5 = {};

Object.defineProperty(relayer$5, "__esModule", { value: true });
var IRelayer_1 = relayer$5.IRelayer = void 0;
const events_1$c = require$$0$s;
class IRelayer extends events_1$c.IEvents {
    constructor(opts) {
        super();
    }
}
IRelayer_1 = relayer$5.IRelayer = IRelayer;

var relayer$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), relayer$5, {
    get IRelayer () { return IRelayer_1; },
    'default': relayer$5
}));

var require$$6$d = /*@__PURE__*/getAugmentedNamespace(relayer$4);

var store$5 = {};

Object.defineProperty(store$5, "__esModule", { value: true });
var IStore_1 = store$5.IStore = void 0;
class IStore {
    constructor(core, logger, name, storagePrefix) {
        this.core = core;
        this.logger = logger;
        this.name = name;
    }
}
IStore_1 = store$5.IStore = IStore;

var store$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), store$5, {
    get IStore () { return IStore_1; },
    'default': store$5
}));

var require$$7$b = /*@__PURE__*/getAugmentedNamespace(store$4);

var subscriber$5 = {};

Object.defineProperty(subscriber$5, "__esModule", { value: true });
var ISubscriber_1 = subscriber$5.ISubscriber = ISubscriberTopicMap_1 = subscriber$5.ISubscriberTopicMap = void 0;
const events_1$b = require$$0$s;
class ISubscriberTopicMap {
    constructor() {
        this.map = new Map();
    }
}
var ISubscriberTopicMap_1 = subscriber$5.ISubscriberTopicMap = ISubscriberTopicMap;
class ISubscriber extends events_1$b.IEvents {
    constructor(relayer, logger) {
        super();
        this.relayer = relayer;
        this.logger = logger;
    }
}
ISubscriber_1 = subscriber$5.ISubscriber = ISubscriber;

var subscriber$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), subscriber$5, {
    get ISubscriber () { return ISubscriber_1; },
    get ISubscriberTopicMap () { return ISubscriberTopicMap_1; },
    'default': subscriber$5
}));

var require$$8$8 = /*@__PURE__*/getAugmentedNamespace(subscriber$4);

var keychain$5 = {};

Object.defineProperty(keychain$5, "__esModule", { value: true });
var IKeyChain_1 = keychain$5.IKeyChain = void 0;
class IKeyChain {
    constructor(core, logger) {
        this.core = core;
        this.logger = logger;
    }
}
IKeyChain_1 = keychain$5.IKeyChain = IKeyChain;

var keychain$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), keychain$5, {
    get IKeyChain () { return IKeyChain_1; },
    'default': keychain$5
}));

var require$$9$4 = /*@__PURE__*/getAugmentedNamespace(keychain$4);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$H, exports);
tslib_1.__exportStar(require$$2$r, exports);
tslib_1.__exportStar(require$$3$o, exports);
tslib_1.__exportStar(require$$4$i, exports);
tslib_1.__exportStar(require$$5$g, exports);
tslib_1.__exportStar(require$$6$d, exports);
tslib_1.__exportStar(require$$7$b, exports);
tslib_1.__exportStar(require$$8$8, exports);
tslib_1.__exportStar(require$$9$4, exports);

}(core$8));

var index$c = /*@__PURE__*/getDefaultExportFromCjs(core$8);

var core$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), core$8, {
    'default': index$c
}));

var require$$1$G = /*@__PURE__*/getAugmentedNamespace(core$5);

var signClient$1 = {};

var client$5 = {};

Object.defineProperty(client$5, "__esModule", { value: true });
var ISignClient_1 = client$5.ISignClient = ISignClientEvents_1 = client$5.ISignClientEvents = void 0;
const tslib_1$l = require$$0$G;
const events_1$a = tslib_1$l.__importDefault(require$$1$19);
class ISignClientEvents extends events_1$a.default {
    constructor() {
        super();
    }
}
var ISignClientEvents_1 = client$5.ISignClientEvents = ISignClientEvents;
class ISignClient {
    constructor(opts) {
        this.opts = opts;
        this.protocol = "wc";
        this.version = 2;
    }
}
ISignClient_1 = client$5.ISignClient = ISignClient;

var client$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), client$5, {
    get ISignClient () { return ISignClient_1; },
    get ISignClientEvents () { return ISignClientEvents_1; },
    'default': client$5
}));

var require$$1$F = /*@__PURE__*/getAugmentedNamespace(client$4);

var engine$5 = {};

Object.defineProperty(engine$5, "__esModule", { value: true });
var IEngine_1 = engine$5.IEngine = IEngineEvents_1 = engine$5.IEngineEvents = void 0;
const events_1$9 = require$$1$19;
class IEngineEvents extends events_1$9.EventEmitter {
    constructor() {
        super();
    }
}
var IEngineEvents_1 = engine$5.IEngineEvents = IEngineEvents;
class IEngine {
    constructor(client) {
        this.client = client;
    }
}
IEngine_1 = engine$5.IEngine = IEngine;

var engine$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), engine$5, {
    get IEngine () { return IEngine_1; },
    get IEngineEvents () { return IEngineEvents_1; },
    'default': engine$5
}));

var require$$2$q = /*@__PURE__*/getAugmentedNamespace(engine$4);

var expirer$5 = {};

Object.defineProperty(expirer$5, "__esModule", { value: true });
var IExpirer_1 = expirer$5.IExpirer = void 0;
const events_1$8 = require$$0$s;
class IExpirer extends events_1$8.IEvents {
    constructor(core, logger) {
        super();
        this.core = core;
        this.logger = logger;
    }
}
IExpirer_1 = expirer$5.IExpirer = IExpirer;

var expirer$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), expirer$5, {
    get IExpirer () { return IExpirer_1; },
    'default': expirer$5
}));

var require$$3$n = /*@__PURE__*/getAugmentedNamespace(expirer$4);

var jsonrpc$6 = {};

Object.defineProperty(jsonrpc$6, "__esModule", { value: true });

var jsonrpc$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), jsonrpc$6, {
    'default': jsonrpc$6
}));

var require$$4$h = /*@__PURE__*/getAugmentedNamespace(jsonrpc$5);

var pairing$5 = {};

Object.defineProperty(pairing$5, "__esModule", { value: true });

var pairing$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pairing$5, {
    'default': pairing$5
}));

var require$$5$f = /*@__PURE__*/getAugmentedNamespace(pairing$4);

var proposal$5 = {};

Object.defineProperty(proposal$5, "__esModule", { value: true });

var proposal$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), proposal$5, {
    'default': proposal$5
}));

var require$$6$c = /*@__PURE__*/getAugmentedNamespace(proposal$4);

var session$8 = {};

Object.defineProperty(session$8, "__esModule", { value: true });

var session$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), session$8, {
    'default': session$8
}));

var require$$7$a = /*@__PURE__*/getAugmentedNamespace(session$7);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$F, exports);
tslib_1.__exportStar(require$$2$q, exports);
tslib_1.__exportStar(require$$3$n, exports);
tslib_1.__exportStar(require$$4$h, exports);
tslib_1.__exportStar(require$$5$f, exports);
tslib_1.__exportStar(require$$6$c, exports);
tslib_1.__exportStar(require$$7$a, exports);

}(signClient$1));

var index$b = /*@__PURE__*/getDefaultExportFromCjs(signClient$1);

var signClient = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), signClient$1, {
    'default': index$b
}));

var require$$2$p = /*@__PURE__*/getAugmentedNamespace(signClient);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$G, exports);
tslib_1.__exportStar(require$$2$p, exports);

}(cjs$e));

var index$a = /*@__PURE__*/getDefaultExportFromCjs(cjs$e);

var cjs$d = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$e, {
    'default': index$a
}));

var require$$3$m = /*@__PURE__*/getAugmentedNamespace(cjs$d);

var cjs$c = {};

var caip$1 = {};

Object.defineProperty(caip$1, "__esModule", { value: true });
var getChainsFromRequiredNamespaces_1 = caip$1.getChainsFromRequiredNamespaces = getChainsFromNamespaces_1 = caip$1.getChainsFromNamespaces = getAccountsFromNamespaces_1 = caip$1.getAccountsFromNamespaces = getChainsFromAccounts_1 = caip$1.getChainsFromAccounts = getAddressesFromAccounts_1 = caip$1.getAddressesFromAccounts = formatAccountWithChain_1 = caip$1.formatAccountWithChain = getChainFromAccount_1 = caip$1.getChainFromAccount = getAddressFromAccount_1 = caip$1.getAddressFromAccount = getUniqueValues_1 = caip$1.getUniqueValues = formatAccountId_1 = caip$1.formatAccountId = parseAccountId_1 = caip$1.parseAccountId = formatChainId_1 = caip$1.formatChainId = parseChainId_1 = caip$1.parseChainId = void 0;
const CAIP_DELIMITER = ":";
function parseChainId(chain) {
    const [namespace, reference] = chain.split(CAIP_DELIMITER);
    return { namespace, reference };
}
var parseChainId_1 = caip$1.parseChainId = parseChainId;
function formatChainId(params) {
    const { namespace, reference } = params;
    return [namespace, reference].join(CAIP_DELIMITER);
}
var formatChainId_1 = caip$1.formatChainId = formatChainId;
function parseAccountId(account) {
    const [namespace, reference, address] = account.split(CAIP_DELIMITER);
    return { namespace, reference, address };
}
var parseAccountId_1 = caip$1.parseAccountId = parseAccountId;
function formatAccountId(params) {
    const { namespace, reference, address } = params;
    return [namespace, reference, address].join(CAIP_DELIMITER);
}
var formatAccountId_1 = caip$1.formatAccountId = formatAccountId;
function getUniqueValues(array, parser) {
    const unique = [];
    array.forEach(str => {
        const value = parser(str);
        if (!unique.includes(value))
            unique.push(value);
    });
    return unique;
}
var getUniqueValues_1 = caip$1.getUniqueValues = getUniqueValues;
function getAddressFromAccount(account) {
    const { address } = parseAccountId(account);
    return address;
}
var getAddressFromAccount_1 = caip$1.getAddressFromAccount = getAddressFromAccount;
function getChainFromAccount(account) {
    const { namespace, reference } = parseAccountId(account);
    const chain = formatChainId({ namespace, reference });
    return chain;
}
var getChainFromAccount_1 = caip$1.getChainFromAccount = getChainFromAccount;
function formatAccountWithChain(address, chain) {
    const { namespace, reference } = parseChainId(chain);
    const account = formatAccountId({ namespace, reference, address });
    return account;
}
var formatAccountWithChain_1 = caip$1.formatAccountWithChain = formatAccountWithChain;
function getAddressesFromAccounts(accounts) {
    return getUniqueValues(accounts, getAddressFromAccount);
}
var getAddressesFromAccounts_1 = caip$1.getAddressesFromAccounts = getAddressesFromAccounts;
function getChainsFromAccounts(accounts) {
    return getUniqueValues(accounts, getChainFromAccount);
}
var getChainsFromAccounts_1 = caip$1.getChainsFromAccounts = getChainsFromAccounts;
function getAccountsFromNamespaces(namespaces, keys = []) {
    const accounts = [];
    Object.keys(namespaces).forEach(key => {
        if (keys.length && !keys.includes(key))
            return;
        const ns = namespaces[key];
        accounts.push(...ns.accounts);
    });
    return accounts;
}
var getAccountsFromNamespaces_1 = caip$1.getAccountsFromNamespaces = getAccountsFromNamespaces;
function getChainsFromNamespaces(namespaces, keys = []) {
    const chains = [];
    Object.keys(namespaces).forEach(key => {
        if (keys.length && !keys.includes(key))
            return;
        const ns = namespaces[key];
        chains.push(...getChainsFromAccounts(ns.accounts));
    });
    return chains;
}
var getChainsFromNamespaces_1 = caip$1.getChainsFromNamespaces = getChainsFromNamespaces;
function getChainsFromRequiredNamespaces(requiredNamespaces, keys = []) {
    const chains = [];
    Object.keys(requiredNamespaces).forEach(key => {
        if (keys.length && !keys.includes(key))
            return;
        const ns = requiredNamespaces[key];
        chains.push(...ns.chains);
    });
    return chains;
}
getChainsFromRequiredNamespaces_1 = caip$1.getChainsFromRequiredNamespaces = getChainsFromRequiredNamespaces;

var caip = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), caip$1, {
    get getChainsFromRequiredNamespaces () { return getChainsFromRequiredNamespaces_1; },
    get getChainsFromNamespaces () { return getChainsFromNamespaces_1; },
    get getAccountsFromNamespaces () { return getAccountsFromNamespaces_1; },
    get getChainsFromAccounts () { return getChainsFromAccounts_1; },
    get getAddressesFromAccounts () { return getAddressesFromAccounts_1; },
    get formatAccountWithChain () { return formatAccountWithChain_1; },
    get getChainFromAccount () { return getChainFromAccount_1; },
    get getAddressFromAccount () { return getAddressFromAccount_1; },
    get getUniqueValues () { return getUniqueValues_1; },
    get formatAccountId () { return formatAccountId_1; },
    get parseAccountId () { return parseAccountId_1; },
    get formatChainId () { return formatChainId_1; },
    get parseChainId () { return parseChainId_1; },
    'default': caip$1
}));

var require$$1$E = /*@__PURE__*/getAugmentedNamespace(caip);

var crypto$b = {};

var chacha20poly1305$2 = {};

var chacha$1 = {};

var binary$1 = {};

var int$2 = {};

(function (exports) {
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package int provides helper functions for integerss.
 */
// Shim using 16-bit pieces.
function imulShim(a, b) {
    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;
    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;
    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
}
/** 32-bit integer multiplication.  */
// Use system Math.imul if available, otherwise use our shim.
exports.mul = Math.imul || imulShim;
/** 32-bit integer addition.  */
function add(a, b) {
    return (a + b) | 0;
}
exports.add = add;
/**  32-bit integer subtraction.  */
function sub(a, b) {
    return (a - b) | 0;
}
exports.sub = sub;
/** 32-bit integer left rotation */
function rotl(x, n) {
    return x << n | x >>> (32 - n);
}
exports.rotl = rotl;
/** 32-bit integer left rotation */
function rotr(x, n) {
    return x << (32 - n) | x >>> n;
}
exports.rotr = rotr;
function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
}
/**
 * Returns true if the argument is an integer number.
 *
 * In ES2015, Number.isInteger.
 */
exports.isInteger = Number.isInteger || isIntegerShim;
/**
 *  Math.pow(2, 53) - 1
 *
 *  In ES2015 Number.MAX_SAFE_INTEGER.
 */
exports.MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Returns true if the argument is a safe integer number
 * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
 *
 * In ES2015, Number.isSafeInteger.
 */
exports.isSafeInteger = function (n) {
    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
};

}(int$2));

var int = /*@__PURE__*/getDefaultExportFromCjs(int$2);

var int$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), int$2, {
    'default': int
}));

var require$$0$r = /*@__PURE__*/getAugmentedNamespace(int$1);

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(binary$1, "__esModule", { value: true });
/**
 * Package binary provides functions for encoding and decoding numbers in byte arrays.
 */
var int_1 = require$$0$r;
// TODO(dchest): add asserts for correct value ranges and array offsets.
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * signed 16-bit integer and returns it.
 */
function readInt16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;
}
var readInt16BE_1 = binary$1.readInt16BE = readInt16BE;
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;
}
var readUint16BE_1 = binary$1.readUint16BE = readUint16BE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * signed 16-bit integer and returns it.
 */
function readInt16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;
}
var readInt16LE_1 = binary$1.readInt16LE = readInt16LE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 1] << 8) | array[offset]) >>> 0;
}
var readUint16LE_1 = binary$1.readUint16LE = readUint16LE;
/**
 * Writes 2-byte big-endian representation of 16-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 8;
    out[offset + 1] = value >>> 0;
    return out;
}
var writeUint16BE_1 = binary$1.writeUint16BE = writeUint16BE;
var writeInt16BE = binary$1.writeInt16BE = writeUint16BE;
/**
 * Writes 2-byte little-endian representation of 16-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    return out;
}
var writeUint16LE_1 = binary$1.writeUint16LE = writeUint16LE;
var writeInt16LE = binary$1.writeInt16LE = writeUint16LE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * signed 32-bit integer and returns it.
 */
function readInt32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3];
}
var readInt32BE_1 = binary$1.readInt32BE = readInt32BE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3]) >>> 0;
}
var readUint32BE_1 = binary$1.readUint32BE = readUint32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * signed 32-bit integer and returns it.
 */
function readInt32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset];
}
var readInt32LE_1 = binary$1.readInt32LE = readInt32LE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset]) >>> 0;
}
var readUint32LE_1 = binary$1.readUint32LE = readUint32LE;
/**
 * Writes 4-byte big-endian representation of 32-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 24;
    out[offset + 1] = value >>> 16;
    out[offset + 2] = value >>> 8;
    out[offset + 3] = value >>> 0;
    return out;
}
var writeUint32BE_1 = binary$1.writeUint32BE = writeUint32BE;
var writeInt32BE = binary$1.writeInt32BE = writeUint32BE;
/**
 * Writes 4-byte little-endian representation of 32-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    out[offset + 2] = value >>> 16;
    out[offset + 3] = value >>> 24;
    return out;
}
var writeUint32LE_1 = binary$1.writeUint32LE = writeUint32LE;
var writeInt32LE = binary$1.writeInt32LE = writeUint32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readInt32BE(array, offset);
    var lo = readInt32BE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
var readInt64BE_1 = binary$1.readInt64BE = readInt64BE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readUint32BE(array, offset);
    var lo = readUint32BE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
var readUint64BE_1 = binary$1.readUint64BE = readUint64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readInt32LE(array, offset);
    var hi = readInt32LE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
var readInt64LE_1 = binary$1.readInt64LE = readInt64LE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readUint32LE(array, offset);
    var hi = readUint32LE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
var readUint64LE_1 = binary$1.readUint64LE = readUint64LE;
/**
 * Writes 8-byte big-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32BE(value / 0x100000000 >>> 0, out, offset);
    writeUint32BE(value >>> 0, out, offset + 4);
    return out;
}
var writeUint64BE_1 = binary$1.writeUint64BE = writeUint64BE;
var writeInt64BE = binary$1.writeInt64BE = writeUint64BE;
/**
 * Writes 8-byte little-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32LE(value >>> 0, out, offset);
    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
    return out;
}
var writeUint64LE_1 = binary$1.writeUint64LE = writeUint64LE;
var writeInt64LE = binary$1.writeInt64LE = writeUint64LE;
/**
 * Reads bytes from array starting at offset as big-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintBE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
var readUintBE_1 = binary$1.readUintBE = readUintBE;
/**
 * Reads bytes from array starting at offset as little-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintLE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
var readUintLE_1 = binary$1.readUintLE = readUintLE;
/**
 * Writes a big-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintBE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
    }
    var div = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
var writeUintBE_1 = binary$1.writeUintBE = writeUintBE;
/**
 * Writes a little-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintLE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
    }
    var div = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
var writeUintLE_1 = binary$1.writeUintLE = writeUintLE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset);
}
var readFloat32BE_1 = binary$1.readFloat32BE = readFloat32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset, true);
}
var readFloat32LE_1 = binary$1.readFloat32LE = readFloat32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset);
}
var readFloat64BE_1 = binary$1.readFloat64BE = readFloat64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset, true);
}
var readFloat64LE_1 = binary$1.readFloat64LE = readFloat64LE;
/**
 * Writes 4-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value);
    return out;
}
var writeFloat32BE_1 = binary$1.writeFloat32BE = writeFloat32BE;
/**
 * Writes 4-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value, true);
    return out;
}
var writeFloat32LE_1 = binary$1.writeFloat32LE = writeFloat32LE;
/**
 * Writes 8-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value);
    return out;
}
var writeFloat64BE_1 = binary$1.writeFloat64BE = writeFloat64BE;
/**
 * Writes 8-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value, true);
    return out;
}
var writeFloat64LE_1 = binary$1.writeFloat64LE = writeFloat64LE;

var binary = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), binary$1, {
    readInt16BE: readInt16BE_1,
    readUint16BE: readUint16BE_1,
    readInt16LE: readInt16LE_1,
    readUint16LE: readUint16LE_1,
    writeUint16BE: writeUint16BE_1,
    writeInt16BE: writeInt16BE,
    writeUint16LE: writeUint16LE_1,
    writeInt16LE: writeInt16LE,
    readInt32BE: readInt32BE_1,
    readUint32BE: readUint32BE_1,
    readInt32LE: readInt32LE_1,
    readUint32LE: readUint32LE_1,
    writeUint32BE: writeUint32BE_1,
    writeInt32BE: writeInt32BE,
    writeUint32LE: writeUint32LE_1,
    writeInt32LE: writeInt32LE,
    readInt64BE: readInt64BE_1,
    readUint64BE: readUint64BE_1,
    readInt64LE: readInt64LE_1,
    readUint64LE: readUint64LE_1,
    writeUint64BE: writeUint64BE_1,
    writeInt64BE: writeInt64BE,
    writeUint64LE: writeUint64LE_1,
    writeInt64LE: writeInt64LE,
    readUintBE: readUintBE_1,
    readUintLE: readUintLE_1,
    writeUintBE: writeUintBE_1,
    writeUintLE: writeUintLE_1,
    readFloat32BE: readFloat32BE_1,
    readFloat32LE: readFloat32LE_1,
    readFloat64BE: readFloat64BE_1,
    readFloat64LE: readFloat64LE_1,
    writeFloat32BE: writeFloat32BE_1,
    writeFloat32LE: writeFloat32LE_1,
    writeFloat64BE: writeFloat64BE_1,
    writeFloat64LE: writeFloat64LE_1,
    'default': binary$1
}));

var require$$0$q = /*@__PURE__*/getAugmentedNamespace(binary);

var wipe$2 = {};

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(wipe$2, "__esModule", { value: true });
/**
 * Sets all values in the given array to zero and returns it.
 *
 * The fact that it sets bytes to zero can be relied on.
 *
 * There is no guarantee that this function makes data disappear from memory,
 * as runtime implementation can, for example, have copying garbage collector
 * that will make copies of sensitive data before we wipe it. Or that an
 * operating system will write our data to swap or sleep image. Another thing
 * is that an optimizing compiler can remove calls to this function or make it
 * no-op. There's nothing we can do with it, so we just do our best and hope
 * that everything will be okay and good will triumph over evil.
 */
function wipe(array) {
    // Right now it's similar to array.fill(0). If it turns
    // out that runtimes optimize this call away, maybe
    // we can try something else.
    for (var i = 0; i < array.length; i++) {
        array[i] = 0;
    }
    return array;
}
var wipe_2 = wipe$2.wipe = wipe;

var wipe$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), wipe$2, {
    wipe: wipe_2,
    'default': wipe$2
}));

var require$$1$D = /*@__PURE__*/getAugmentedNamespace(wipe$1);

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(chacha$1, "__esModule", { value: true });
/**
 * Package chacha implements ChaCha stream cipher.
 */
var binary_1 = require$$0$q;
var wipe_1$3 = require$$1$D;
// Number of ChaCha rounds (ChaCha20).
var ROUNDS = 20;
// Applies the ChaCha core function to 16-byte input,
// 32-byte key key, and puts the result into 64-byte array out.
function core$4(out, input, key) {
    var j0 = 0x61707865; // "expa"  -- ChaCha's "sigma" constant
    var j1 = 0x3320646E; // "nd 3"     for 32-byte keys
    var j2 = 0x79622D32; // "2-by"
    var j3 = 0x6B206574; // "te k"
    var j4 = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
    var j5 = (key[7] << 24) | (key[6] << 16) | (key[5] << 8) | key[4];
    var j6 = (key[11] << 24) | (key[10] << 16) | (key[9] << 8) | key[8];
    var j7 = (key[15] << 24) | (key[14] << 16) | (key[13] << 8) | key[12];
    var j8 = (key[19] << 24) | (key[18] << 16) | (key[17] << 8) | key[16];
    var j9 = (key[23] << 24) | (key[22] << 16) | (key[21] << 8) | key[20];
    var j10 = (key[27] << 24) | (key[26] << 16) | (key[25] << 8) | key[24];
    var j11 = (key[31] << 24) | (key[30] << 16) | (key[29] << 8) | key[28];
    var j12 = (input[3] << 24) | (input[2] << 16) | (input[1] << 8) | input[0];
    var j13 = (input[7] << 24) | (input[6] << 16) | (input[5] << 8) | input[4];
    var j14 = (input[11] << 24) | (input[10] << 16) | (input[9] << 8) | input[8];
    var j15 = (input[15] << 24) | (input[14] << 16) | (input[13] << 8) | input[12];
    var x0 = j0;
    var x1 = j1;
    var x2 = j2;
    var x3 = j3;
    var x4 = j4;
    var x5 = j5;
    var x6 = j6;
    var x7 = j7;
    var x8 = j8;
    var x9 = j9;
    var x10 = j10;
    var x11 = j11;
    var x12 = j12;
    var x13 = j13;
    var x14 = j14;
    var x15 = j15;
    for (var i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> (32 - 16) | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> (32 - 12) | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> (32 - 16) | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> (32 - 12) | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> (32 - 16) | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> (32 - 12) | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> (32 - 16) | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> (32 - 12) | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> (32 - 8) | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> (32 - 7) | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> (32 - 8) | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> (32 - 7) | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> (32 - 8) | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> (32 - 7) | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> (32 - 8) | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> (32 - 7) | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> (32 - 16) | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> (32 - 12) | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> (32 - 16) | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> (32 - 12) | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> (32 - 16) | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> (32 - 12) | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> (32 - 16) | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> (32 - 12) | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> (32 - 8) | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> (32 - 7) | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> (32 - 8) | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> (32 - 7) | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> (32 - 8) | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> (32 - 7) | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> (32 - 8) | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> (32 - 7) | x5 << 7;
    }
    binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
    binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
    binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
    binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
    binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
    binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
    binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
    binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
    binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
    binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
    binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
    binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
    binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
    binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
    binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
    binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
/**
 * Encrypt src with ChaCha20 stream generated for the given 32-byte key and
 * 8-byte (as in original implementation) or 12-byte (as in RFC7539) nonce and
 * write the result into dst and return it.
 *
 * dst and src may be the same, but otherwise must not overlap.
 *
 * If nonce is 12 bytes, users should not encrypt more than 256 GiB with the
 * same key and nonce, otherwise the stream will repeat. The function will
 * throw error if counter overflows to prevent this.
 *
 * If nonce is 8 bytes, the output is practically unlimited (2^70 bytes, which
 * is more than a million petabytes). However, it is not recommended to
 * generate 8-byte nonces randomly, as the chance of collision is high.
 *
 * Never use the same key and nonce to encrypt more than one message.
 *
 * If nonceInplaceCounterLength is not 0, the nonce is assumed to be a 16-byte
 * array with stream counter in first nonceInplaceCounterLength bytes and nonce
 * in the last remaining bytes. The counter will be incremented inplace for
 * each ChaCha block. This is useful if you need to encrypt one stream of data
 * in chunks.
 */
function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    // We only support 256-bit keys.
    if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
    }
    if (dst.length < src.length) {
        throw new Error("ChaCha: destination is shorter than source");
    }
    var nc;
    var counterLength;
    if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
            throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        // First counterLength bytes of nc are counter, starting with zero.
        counterLength = nc.length - nonce.length;
        // Last bytes of nc after counterLength are nonce, set them.
        nc.set(nonce, counterLength);
    }
    else {
        if (nonce.length !== 16) {
            throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        // This will update passed nonce with counter inplace.
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
    }
    // Allocate temporary space for ChaCha block.
    var block = new Uint8Array(64);
    for (var i = 0; i < src.length; i += 64) {
        // Generate a block.
        core$4(block, nc, key);
        // XOR block bytes with src into dst.
        for (var j = i; j < i + 64 && j < src.length; j++) {
            dst[j] = src[j] ^ block[j - i];
        }
        // Increment counter.
        incrementCounter(nc, 0, counterLength);
    }
    // Cleanup temporary space.
    wipe_1$3.wipe(block);
    if (nonceInplaceCounterLength === 0) {
        // Cleanup counter.
        wipe_1$3.wipe(nc);
    }
    return dst;
}
var streamXOR_1 = chacha$1.streamXOR = streamXOR;
/**
 * Generate ChaCha20 stream for the given 32-byte key and 8-byte or 12-byte
 * nonce and write it into dst and return it.
 *
 * Never use the same key and nonce to generate more than one stream.
 *
 * If nonceInplaceCounterLength is not 0, it behaves the same with respect to
 * the nonce as described in the streamXOR documentation.
 *
 * stream is like streamXOR with all-zero src.
 */
function stream(key, nonce, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    wipe_1$3.wipe(dst);
    return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
var stream_1 = chacha$1.stream = stream;
function incrementCounter(counter, pos, len) {
    var carry = 1;
    while (len--) {
        carry = carry + (counter[pos] & 0xff) | 0;
        counter[pos] = carry & 0xff;
        carry >>>= 8;
        pos++;
    }
    if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
    }
}

var chacha = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), chacha$1, {
    streamXOR: streamXOR_1,
    stream: stream_1,
    'default': chacha$1
}));

var require$$0$p = /*@__PURE__*/getAugmentedNamespace(chacha);

var poly1305$2 = {};

var constantTime$1 = {};

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(constantTime$1, "__esModule", { value: true });
/**
 * Package constant-time provides functions for performing algorithmically constant-time operations.
 */
/**
 * NOTE! Due to the inability to guarantee real constant time evaluation of
 * anything in JavaScript VM, this is module is the best effort.
 */
/**
 * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.
 *
 * Supports only 32-bit integers, so resultIfOne or resultIfZero are not
 * integers, they'll be converted to them with bitwise operations.
 */
function select(subject, resultIfOne, resultIfZero) {
    return (~(subject - 1) & resultIfOne) | ((subject - 1) & resultIfZero);
}
var select_1 = constantTime$1.select = select;
/**
 * Returns 1 if a <= b, or 0 if not.
 * Arguments must be positive 32-bit integers less than or equal to 2^31 - 1.
 */
function lessOrEqual(a, b) {
    return (((a | 0) - (b | 0) - 1) >>> 31) & 1;
}
var lessOrEqual_1 = constantTime$1.lessOrEqual = lessOrEqual;
/**
 * Returns 1 if a and b are of equal length and their contents
 * are equal, or 0 otherwise.
 *
 * Note that unlike in equal(), zero-length inputs are considered
 * the same, so this function will return 1.
 */
function compare(a, b) {
    if (a.length !== b.length) {
        return 0;
    }
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    return (1 & ((result - 1) >>> 8));
}
var compare_1 = constantTime$1.compare = compare;
/**
 * Returns true if a and b are of equal non-zero length,
 * and their contents are equal, or false otherwise.
 *
 * Note that unlike in compare() zero-length inputs are considered
 * _not_ equal, so this function will return false.
 */
function equal$1(a, b) {
    if (a.length === 0 || b.length === 0) {
        return false;
    }
    return compare(a, b) !== 0;
}
var equal_1 = constantTime$1.equal = equal$1;

var constantTime = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constantTime$1, {
    select: select_1,
    lessOrEqual: lessOrEqual_1,
    compare: compare_1,
    equal: equal_1,
    'default': constantTime$1
}));

var require$$1$C = /*@__PURE__*/getAugmentedNamespace(constantTime);

(function (exports) {
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package poly1305 implements Poly1305 one-time message authentication algorithm.
 */
var constant_time_1 = require$$1$C;
var wipe_1 = require$$1$D;
exports.DIGEST_LENGTH = 16;
// Port of Andrew Moon's Poly1305-donna-16. Public domain.
// https://github.com/floodyberry/poly1305-donna
/**
 * Poly1305 computes 16-byte authenticator of message using
 * a one-time 32-byte key.
 *
 * Important: key should be used for only one message,
 * it should never repeat.
 */
var Poly1305 = /** @class */ (function () {
    function Poly1305(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = (t0) & 0x1fff;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
        this._r[5] = ((t4 >>> 1)) & 0x1ffe;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
        this._r[9] = ((t7 >>> 5)) & 0x007f;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
    }
    Poly1305.prototype._blocks = function (m, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
            var t0 = m[mpos + 0] | m[mpos + 1] << 8;
            h0 += (t0) & 0x1fff;
            var t1 = m[mpos + 2] | m[mpos + 3] << 8;
            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
            var t2 = m[mpos + 4] | m[mpos + 5] << 8;
            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff;
            var t3 = m[mpos + 6] | m[mpos + 7] << 8;
            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
            var t4 = m[mpos + 8] | m[mpos + 9] << 8;
            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff;
            h5 += ((t4 >>> 1)) & 0x1fff;
            var t5 = m[mpos + 10] | m[mpos + 11] << 8;
            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
            var t6 = m[mpos + 12] | m[mpos + 13] << 8;
            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff;
            var t7 = m[mpos + 14] | m[mpos + 15] << 8;
            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
            h9 += ((t7 >>> 5)) | hibit;
            var c = 0;
            var d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = (d0 >>> 13);
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += (d0 >>> 13);
            d0 &= 0x1fff;
            var d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = (d1 >>> 13);
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += (d1 >>> 13);
            d1 &= 0x1fff;
            var d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = (d2 >>> 13);
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += (d2 >>> 13);
            d2 &= 0x1fff;
            var d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = (d3 >>> 13);
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += (d3 >>> 13);
            d3 &= 0x1fff;
            var d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = (d4 >>> 13);
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += (d4 >>> 13);
            d4 &= 0x1fff;
            var d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = (d5 >>> 13);
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += (d5 >>> 13);
            d5 &= 0x1fff;
            var d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = (d6 >>> 13);
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += (d6 >>> 13);
            d6 &= 0x1fff;
            var d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = (d7 >>> 13);
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += (d7 >>> 13);
            d7 &= 0x1fff;
            var d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = (d8 >>> 13);
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += (d8 >>> 13);
            d8 &= 0x1fff;
            var d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = (d9 >>> 13);
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += (d9 >>> 13);
            d9 &= 0x1fff;
            c = (((c << 2) + c)) | 0;
            c = (c + d0) | 0;
            d0 = c & 0x1fff;
            c = (c >>> 13);
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
    };
    Poly1305.prototype.finish = function (mac, macpos) {
        if (macpos === void 0) { macpos = 0; }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
            i = this._leftover;
            this._buffer[i++] = 1;
            for (; i < 16; i++) {
                this._buffer[i] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        for (i = 2; i < 10; i++) {
            this._h[i] += c;
            c = this._h[i] >>> 13;
            this._h[i] &= 0x1fff;
        }
        this._h[0] += (c * 5);
        c = this._h[0] >>> 13;
        this._h[0] &= 0x1fff;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for (i = 1; i < 10; i++) {
            g[i] = this._h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= (1 << 13);
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
            g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
            this._h[i] = (this._h[i] & mask) | g[i];
        }
        this._h[0] = ((this._h[0]) | (this._h[1] << 13)) & 0xffff;
        this._h[1] = ((this._h[1] >>> 3) | (this._h[2] << 10)) & 0xffff;
        this._h[2] = ((this._h[2] >>> 6) | (this._h[3] << 7)) & 0xffff;
        this._h[3] = ((this._h[3] >>> 9) | (this._h[4] << 4)) & 0xffff;
        this._h[4] = ((this._h[4] >>> 12) | (this._h[5] << 1) | (this._h[6] << 14)) & 0xffff;
        this._h[5] = ((this._h[6] >>> 2) | (this._h[7] << 11)) & 0xffff;
        this._h[6] = ((this._h[7] >>> 5) | (this._h[8] << 8)) & 0xffff;
        this._h[7] = ((this._h[8] >>> 8) | (this._h[9] << 5)) & 0xffff;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 0xffff;
        for (i = 1; i < 8; i++) {
            f = (((this._h[i] + this._pad[i]) | 0) + (f >>> 16)) | 0;
            this._h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
    };
    Poly1305.prototype.update = function (m) {
        var mpos = 0;
        var bytes = m.length;
        var want;
        if (this._leftover) {
            want = (16 - this._leftover);
            if (want > bytes) {
                want = bytes;
            }
            for (var i = 0; i < want; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
                return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - (bytes % 16);
            this._blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for (var i = 0; i < bytes; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            this._leftover += bytes;
        }
        return this;
    };
    Poly1305.prototype.digest = function () {
        // TODO(dchest): it behaves differently than other hashes/HMAC,
        // because it throws when finished — others just return saved result.
        if (this._finished) {
            throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
    };
    Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true; // mark as finished even if not
        return this;
    };
    return Poly1305;
}());
exports.Poly1305 = Poly1305;
/**
 * Returns 16-byte authenticator of data using a one-time 32-byte key.
 *
 * Important: key should be used for only one message, it should never repeat.
 */
function oneTimeAuth(key, data) {
    var h = new Poly1305(key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.oneTimeAuth = oneTimeAuth;
/**
 * Returns true if two authenticators are 16-byte long and equal.
 * Uses contant-time comparison to avoid leaking timing information.
 */
function equal(a, b) {
    if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
        return false;
    }
    return constant_time_1.equal(a, b);
}
exports.equal = equal;

}(poly1305$2));

var poly1305 = /*@__PURE__*/getDefaultExportFromCjs(poly1305$2);

var poly1305$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), poly1305$2, {
    'default': poly1305
}));

var require$$1$B = /*@__PURE__*/getAugmentedNamespace(poly1305$1);

(function (exports) {
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var chacha_1 = require$$0$p;
var poly1305_1 = require$$1$B;
var wipe_1 = require$$1$D;
var binary_1 = require$$0$q;
var constant_time_1 = require$$1$C;
exports.KEY_LENGTH = 32;
exports.NONCE_LENGTH = 12;
exports.TAG_LENGTH = 16;
var ZEROS = new Uint8Array(16);
/**
 * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.
 *
 * Defined in RFC7539.
 */
var ChaCha20Poly1305 = /** @class */ (function () {
    /**
     * Creates a new instance with the given 32-byte key.
     */
    function ChaCha20Poly1305(key) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key.length !== exports.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        // Copy key.
        this._key = new Uint8Array(key);
    }
    /**
     * Encrypts and authenticates plaintext, authenticates associated data,
     * and returns sealed ciphertext, which includes authentication tag.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If dst is given (it must be the size of plaintext + the size of tag
     * length) the result will be put into it. Dst and plaintext must not
     * overlap.
     */
    ChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        // We pass full counter, which has 12-byte nonce and 4-byte block counter,
        // and it will get incremented after generating the block, which is
        // exactly what we need: we only use the first 32 bytes of 64-byte
        // ChaCha block and discard the next 32 bytes.
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        // Allocate space for sealed ciphertext.
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        }
        else {
            result = new Uint8Array(resultLength);
        }
        // Encrypt plaintext.
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        // Authenticate.
        // XXX: can "simplify" here: pass full result (which is already padded
        // due to zeroes prepared for tag), and ciphertext length instead of
        // subarray of result.
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        // Cleanup.
        wipe_1.wipe(counter);
        return result;
    };
    /**
     * Authenticates sealed ciphertext (which includes authentication tag) and
     * associated data, decrypts ciphertext and returns decrypted plaintext.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If authentication fails, it returns null.
     *
     * If dst is given (it must be of ciphertext length minus tag length),
     * the result will be put into it. Dst and plaintext must not overlap.
     */
    ChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Sealed ciphertext should at least contain tag.
        if (sealed.length < this.tagLength) {
            // TODO(dchest): should we throw here instead?
            return null;
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        // Authenticate.
        // XXX: can simplify and avoid allocation: since authenticate()
        // already allocates tag (from Poly1305.digest(), it can return)
        // it instead of copying to calculatedTag. But then in seal()
        // we'll need to copy it.
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        // Constant-time compare tags and return null if they differ.
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
        }
        // Allocate space for decrypted plaintext.
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        }
        else {
            result = new Uint8Array(resultLength);
        }
        // Decrypt.
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        // Cleanup.
        wipe_1.wipe(counter);
        return result;
    };
    ChaCha20Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._key);
        return this;
    };
    ChaCha20Poly1305.prototype._authenticate = function (tagOut, authKey, ciphertext, associatedData) {
        // Initialize Poly1305 with authKey.
        var h = new poly1305_1.Poly1305(authKey);
        // Authenticate padded associated data.
        if (associatedData) {
            h.update(associatedData);
            if (associatedData.length % 16 > 0) {
                h.update(ZEROS.subarray(associatedData.length % 16));
            }
        }
        // Authenticate padded ciphertext.
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
            h.update(ZEROS.subarray(ciphertext.length % 16));
        }
        // Authenticate length of associated data.
        // XXX: can avoid allocation here?
        var length = new Uint8Array(8);
        if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length);
        }
        h.update(length);
        // Authenticate length of ciphertext.
        binary_1.writeUint64LE(ciphertext.length, length);
        h.update(length);
        // Get tag and copy it into tagOut.
        var tag = h.digest();
        for (var i = 0; i < tag.length; i++) {
            tagOut[i] = tag[i];
        }
        // Cleanup.
        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length);
    };
    return ChaCha20Poly1305;
}());
exports.ChaCha20Poly1305 = ChaCha20Poly1305;

}(chacha20poly1305$2));

var chacha20poly1305 = /*@__PURE__*/getDefaultExportFromCjs(chacha20poly1305$2);

var chacha20poly1305$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), chacha20poly1305$2, {
    'default': chacha20poly1305
}));

var require$$1$A = /*@__PURE__*/getAugmentedNamespace(chacha20poly1305$1);

var hkdf$1 = {};

var hmac$2 = {};

var hash$1 = {};

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(hash$1, "__esModule", { value: true });
function isSerializableHash(h) {
    return (typeof h.saveState !== "undefined" &&
        typeof h.restoreState !== "undefined" &&
        typeof h.cleanSavedState !== "undefined");
}
var isSerializableHash_1 = hash$1.isSerializableHash = isSerializableHash;

var hash = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), hash$1, {
    isSerializableHash: isSerializableHash_1,
    'default': hash$1
}));

var require$$0$o = /*@__PURE__*/getAugmentedNamespace(hash);

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(hmac$2, "__esModule", { value: true });
/**
 * Package hmac implements HMAC algorithm.
 */
var hash_1 = require$$0$o;
var constant_time_1 = require$$1$C;
var wipe_1$2 = require$$1$D;
/**
 *  HMAC implements hash-based message authentication algorithm.
 */
var HMAC = /** @class */ (function () {
    /**
     * Constructs a new HMAC with the given Hash and secret key.
     */
    function HMAC(hash, key) {
        this._finished = false; // true if HMAC was finalized
        // Initialize inner and outer hashes.
        this._inner = new hash();
        this._outer = new hash();
        // Set block and digest sizes for this HMAC
        // instance to values from the hash.
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        // Pad temporary stores a key (or its hash) padded with zeroes.
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
            // If key is bigger than hash block size, it must be
            // hashed and this hash is used as a key instead.
            this._inner.update(key).finish(pad).clean();
        }
        else {
            // Otherwise, copy the key into pad.
            pad.set(key);
        }
        // Now two different keys are derived from padded key
        // by xoring a different byte value to each.
        // To make inner hash key, xor byte 0x36 into pad.
        for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36;
        }
        // Update inner hash with the result.
        this._inner.update(pad);
        // To make outer hash key, xor byte 0x5c into pad.
        // But since we already xored 0x36 there, we must
        // first undo this by xoring it again.
        for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36 ^ 0x5c;
        }
        // Update outer hash with the result.
        this._outer.update(pad);
        // Save states of both hashes, so that we can quickly restore
        // them later in reset() without the need to remember the actual
        // key and perform this initialization again.
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
        }
        // Clean pad.
        wipe_1$2.wipe(pad);
    }
    /**
     * Returns HMAC state to the state initialized with key
     * to make it possible to run HMAC over the other data with the same
     * key without creating a new instance.
     */
    HMAC.prototype.reset = function () {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        // Restore keyed states of inner and outer hashes.
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    };
    /**
     * Cleans HMAC state.
     */
    HMAC.prototype.clean = function () {
        if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
    };
    /**
     * Updates state with provided data.
     */
    HMAC.prototype.update = function (data) {
        this._inner.update(data);
        return this;
    };
    /**
     * Finalizes HMAC and puts the result in out.
     */
    HMAC.prototype.finish = function (out) {
        if (this._finished) {
            // If HMAC was finalized, outer hash is also finalized,
            // so it produces the same digest it produced when it
            // was finalized.
            this._outer.finish(out);
            return this;
        }
        // Finalize inner hash and store the result temporarily.
        this._inner.finish(out);
        // Update outer hash with digest of inner hash and and finalize it.
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
    };
    /**
     * Returns the computed message authentication code.
     */
    HMAC.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Saves HMAC state.
     * This function is needed for PBKDF2 optimization.
     */
    HMAC.prototype.saveState = function () {
        if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
    };
    HMAC.prototype.restoreState = function (savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    };
    HMAC.prototype.cleanSavedState = function (savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
    };
    return HMAC;
}());
var HMAC_1 = hmac$2.HMAC = HMAC;
/**
 * Returns HMAC using the given hash constructor for the key over data.
 */
function hmac(hash, key, data) {
    var h = new HMAC(hash, key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
var hmac_2 = hmac$2.hmac = hmac;
/**
 * Returns true if two HMAC digests are equal.
 * Uses constant-time comparison to avoid leaking timing information.
 *
 * Example:
 *
 *    const receivedDigest = ...
 *    const realDigest = hmac(SHA256, key, data);
 *    if (!equal(receivedDigest, realDigest)) {
 *        throw new Error("Authentication error");
 *    }
 */
var equal = hmac$2.equal = constant_time_1.equal;

var hmac$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), hmac$2, {
    HMAC: HMAC_1,
    hmac: hmac_2,
    equal: equal,
    'default': hmac$2
}));

var require$$0$n = /*@__PURE__*/getAugmentedNamespace(hmac$1);

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(hkdf$1, "__esModule", { value: true });
var hmac_1 = require$$0$n;
var wipe_1$1 = require$$1$D;
/**
 * HMAC-based Extract-and-Expand Key Derivation Function.
 *
 * Implements HKDF from RFC5869.
 *
 * Expands the given master key with salt and info into
 * a limited stream of key material.
 */
var HKDF = /** @class */ (function () {
    /**
     * Create a new HKDF instance for the given hash function
     * with the master key, optional salt, and info.
     *
     * - Master key is a high-entropy secret key (not a password).
     * - Salt is a non-secret random value.
     * - Info is application- and/or context-specific information.
     */
    function HKDF(hash, key, salt, info) {
        if (salt === void 0) { salt = new Uint8Array(0); }
        this._counter = new Uint8Array(1); // starts with zero
        this._hash = hash;
        this._info = info;
        // HKDF-Extract uses salt as HMAC key, and key as data.
        var okm = hmac_1.hmac(this._hash, salt, key);
        // Initialize HMAC for expanding with extracted key.
        this._hmac = new hmac_1.HMAC(hash, okm);
        // Allocate buffer.
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
    }
    // Fill buffer with new block of HKDF-Extract output.
    HKDF.prototype._fillBuffer = function () {
        // Increment counter.
        this._counter[0]++;
        var ctr = this._counter[0];
        // Check if counter overflowed.
        if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
        }
        // Prepare HMAC instance for new data with old key.
        this._hmac.reset();
        // Hash in previous output if it was generated
        // (i.e. counter is greater than 1).
        if (ctr > 1) {
            this._hmac.update(this._buffer);
        }
        // Hash in info if it exists.
        if (this._info) {
            this._hmac.update(this._info);
        }
        // Hash in the counter.
        this._hmac.update(this._counter);
        // Output result to buffer and clean HMAC instance.
        this._hmac.finish(this._buffer);
        // Reset buffer position.
        this._bufpos = 0;
    };
    /**
     * Expand returns next key material of the given length.
     *
     * It throws if expansion limit is reached (which is
     * 254 digests of the underlying HMAC function).
     */
    HKDF.prototype.expand = function (length) {
        var out = new Uint8Array(length);
        for (var i = 0; i < out.length; i++) {
            if (this._bufpos === this._buffer.length) {
                this._fillBuffer();
            }
            out[i] = this._buffer[this._bufpos++];
        }
        return out;
    };
    HKDF.prototype.clean = function () {
        this._hmac.clean();
        wipe_1$1.wipe(this._buffer);
        wipe_1$1.wipe(this._counter);
        this._bufpos = 0;
    };
    return HKDF;
}());
var HKDF_1 = hkdf$1.HKDF = HKDF;

var hkdf = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), hkdf$1, {
    HKDF: HKDF_1,
    'default': hkdf$1
}));

var require$$2$o = /*@__PURE__*/getAugmentedNamespace(hkdf);

var random$2 = {};

var system$1 = {};

var browser$3 = {};

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(browser$3, "__esModule", { value: true });
var BrowserRandomSource_1 = browser$3.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
    constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== 'undefined'
            ? (self.crypto || self.msCrypto) // IE11 has msCrypto
            : null;
        if (browserCrypto && browserCrypto.getRandomValues !== undefined) {
            this._crypto = browserCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length);
        for (let i = 0; i < out.length; i += QUOTA) {
            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
    }
}
BrowserRandomSource_1 = browser$3.BrowserRandomSource = BrowserRandomSource;

var browser$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), browser$3, {
    get BrowserRandomSource () { return BrowserRandomSource_1; },
    'default': browser$3
}));

var require$$0$m = /*@__PURE__*/getAugmentedNamespace(browser$2);

var node$1 = {};

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(node$1, "__esModule", { value: true });
var NodeRandomSource_1 = node$1.NodeRandomSource = void 0;
const wipe_1 = require$$1$D;
class NodeRandomSource {
    constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof commonjsRequire !== "undefined") {
            const nodeCrypto = nodeCrypto__default;
            if (nodeCrypto && nodeCrypto.randomBytes) {
                this._crypto = nodeCrypto;
                this.isAvailable = true;
                this.isInstantiated = true;
            }
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Node.js random byte generator is not available.");
        }
        // Get random bytes (result is Buffer).
        let buffer = this._crypto.randomBytes(length);
        // Make sure we got the length that we requested.
        if (buffer.length !== length) {
            throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        // Allocate output array.
        const out = new Uint8Array(length);
        // Copy bytes from buffer to output.
        for (let i = 0; i < out.length; i++) {
            out[i] = buffer[i];
        }
        // Cleanup.
        (0, wipe_1.wipe)(buffer);
        return out;
    }
}
NodeRandomSource_1 = node$1.NodeRandomSource = NodeRandomSource;

var node = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), node$1, {
    get NodeRandomSource () { return NodeRandomSource_1; },
    'default': node$1
}));

var require$$1$z = /*@__PURE__*/getAugmentedNamespace(node);

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(system$1, "__esModule", { value: true });
var SystemRandomSource_1 = system$1.SystemRandomSource = void 0;
const browser_1 = require$$0$m;
const node_1 = require$$1$z;
class SystemRandomSource {
    constructor() {
        this.isAvailable = false;
        this.name = "";
        // Try browser.
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Browser";
            return;
        }
        // If no browser source, try Node.
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Node";
            return;
        }
        // No sources, we're out of options.
    }
    randomBytes(length) {
        if (!this.isAvailable) {
            throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length);
    }
}
SystemRandomSource_1 = system$1.SystemRandomSource = SystemRandomSource;

var system = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), system$1, {
    get SystemRandomSource () { return SystemRandomSource_1; },
    'default': system$1
}));

var require$$0$l = /*@__PURE__*/getAugmentedNamespace(system);

(function (exports) {
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
const system_1 = require$$0$l;
const binary_1 = require$$0$q;
const wipe_1 = require$$1$D;
exports.defaultRandomSource = new system_1.SystemRandomSource();
function randomBytes(length, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length);
}
exports.randomBytes = randomBytes;
/**
 * Returns a uniformly random unsigned 32-bit integer.
 */
function randomUint32(prng = exports.defaultRandomSource) {
    // Generate 4-byte random buffer.
    const buf = randomBytes(4, prng);
    // Convert bytes from buffer into a 32-bit integer.
    // It's not important which byte order to use, since
    // the result is random.
    const result = (0, binary_1.readUint32LE)(buf);
    // Clean the buffer.
    (0, wipe_1.wipe)(buf);
    return result;
}
exports.randomUint32 = randomUint32;
/** 62 alphanumeric characters for default charset of randomString() */
const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
/**
 * Returns a uniform random string of the given length
 * with characters from the given charset.
 *
 * Charset must not have more than 256 characters.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
        throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
        throw new Error("randomString charset is too long");
    }
    let out = '';
    const charsLen = charset.length;
    const maxByte = 256 - (256 % charsLen);
    while (length > 0) {
        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
        for (let i = 0; i < buf.length && length > 0; i++) {
            const randomByte = buf[i];
            if (randomByte < maxByte) {
                out += charset.charAt(randomByte % charsLen);
                length--;
            }
        }
        (0, wipe_1.wipe)(buf);
    }
    return out;
}
exports.randomString = randomString;
/**
 * Returns uniform random string containing at least the given
 * number of bits of entropy.
 *
 * For example, randomStringForEntropy(128) will return a 22-character
 * alphanumeric string, while randomStringForEntropy(128, "0123456789")
 * will return a 39-character numeric string, both will contain at
 * least 128 bits of entropy.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length, charset, prng);
}
exports.randomStringForEntropy = randomStringForEntropy;

}(random$2));

var random = /*@__PURE__*/getDefaultExportFromCjs(random$2);

var random$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), random$2, {
    'default': random
}));

var require$$3$l = /*@__PURE__*/getAugmentedNamespace(random$1);

var sha256$3 = {};

(function (exports) {
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var binary_1 = require$$0$q;
var wipe_1 = require$$1$D;
exports.DIGEST_LENGTH = 32;
exports.BLOCK_SIZE = 64;
/**
 * SHA2-256 cryptographic hash algorithm.
 */
var SHA256 = /** @class */ (function () {
    function SHA256() {
        /** Length of hash output */
        this.digestLength = exports.DIGEST_LENGTH;
        /** Block size */
        this.blockSize = exports.BLOCK_SIZE;
        // Note: Int32Array is used instead of Uint32Array for performance reasons.
        this._state = new Int32Array(8); // hash state
        this._temp = new Int32Array(64); // temporary state
        this._buffer = new Uint8Array(128); // buffer for data to hash
        this._bufferLength = 0; // number of bytes in buffer
        this._bytesHashed = 0; // number of total bytes hashed
        this._finished = false; // indicates whether the hash was finalized
        this.reset();
    }
    SHA256.prototype._initState = function () {
        this._state[0] = 0x6a09e667;
        this._state[1] = 0xbb67ae85;
        this._state[2] = 0x3c6ef372;
        this._state[3] = 0xa54ff53a;
        this._state[4] = 0x510e527f;
        this._state[5] = 0x9b05688c;
        this._state[6] = 0x1f83d9ab;
        this._state[7] = 0x5be0cd19;
    };
    /**
     * Resets hash state making it possible
     * to re-use this instance to hash other data.
     */
    SHA256.prototype.reset = function () {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
    };
    /**
     * Cleans internal buffers and resets hash state.
     */
    SHA256.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
    };
    /**
     * Updates hash state with the given data.
     *
     * Throws error when trying to update already finalized hash:
     * instance must be reset to update it again.
     */
    SHA256.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) { dataLength = data.length; }
        if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
                this._buffer[this._bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
                hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
            }
        }
        if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    };
    /**
     * Finalizes hash state and puts hash into out.
     * If hash was already finalized, puts the same value.
     */
    SHA256.prototype.finish = function (out) {
        if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = (bytesHashed / 0x20000000) | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;
            this._buffer[left] = 0x80;
            for (var i = left + 1; i < padLength - 8; i++) {
                this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
            binary_1.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
    };
    /**
     * Returns the final hash digest.
     */
    SHA256.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization.
     * Returns hash state to be used with restoreState().
     * Only chain value is saved, not buffers or other
     * state variables.
     */
    SHA256.prototype.saveState = function () {
        if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
        }
        return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
        };
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization.
     * Restores state saved by saveState() and sets bytesHashed
     * to the given value.
     */
    SHA256.prototype.restoreState = function (savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
    };
    /**
     * Cleans state returned by saveState().
     */
    SHA256.prototype.cleanSavedState = function (savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
    };
    return SHA256;
}());
exports.SHA256 = SHA256;
// Constants
var K = new Int32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
function hashBlocks(w, v, p, pos, len) {
    while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i = 0; i < 16; i++) {
            var j = pos + i * 4;
            w[i] = binary_1.readUint32BE(p, j);
        }
        for (var i = 16; i < 64; i++) {
            var u = w[i - 2];
            var t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);
            u = w[i - 15];
            var t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (var i = 0; i < 64; i++) {
            var t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^
                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +
                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;
            var t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^
                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;
            h = g;
            g = f;
            f = e;
            e = (d + t1) | 0;
            d = c;
            c = b;
            b = a;
            a = (t1 + t2) | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
    }
    return pos;
}
function hash(data) {
    var h = new SHA256();
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hash = hash;

}(sha256$3));

var sha256$1 = /*@__PURE__*/getDefaultExportFromCjs(sha256$3);

var sha256$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), sha256$3, {
    'default': sha256$1
}));

var require$$4$g = /*@__PURE__*/getAugmentedNamespace(sha256$2);

var x25519$2 = {};

(function (exports) {
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
/**
 * Package x25519 implements X25519 key agreement.
 */
const random_1 = require$$3$l;
const wipe_1 = require$$1$D;
exports.PUBLIC_KEY_LENGTH = 32;
exports.SECRET_KEY_LENGTH = 32;
exports.SHARED_KEY_LENGTH = 32;
// Returns new zero-filled 16-element GF (Float64Array).
// If passed an array of numbers, prefills the returned
// array with them.
//
// We use Float64Array, because we need 48-bit numbers
// for this implementation.
function gf(init) {
    const r = new Float64Array(16);
    if (init) {
        for (let i = 0; i < init.length; i++) {
            r[i] = init[i];
        }
    }
    return r;
}
// Base point.
const _9 = new Uint8Array(32);
_9[0] = 9;
const _121665 = gf([0xdb41, 1]);
function car25519(o) {
    let c = 1;
    for (let i = 0; i < 16; i++) {
        let v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    const c = ~(b - 1);
    for (let i = 0; i < 16; i++) {
        const t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    const m = gf();
    const t = gf();
    for (let i = 0; i < 16; i++) {
        t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (let i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        const b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for (let i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function unpack25519(o, n) {
    for (let i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 0x7fff;
}
function add(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
    }
}
function sub(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
    }
}
function mul(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function square(o, a) {
    mul(o, a, a);
}
function inv25519(o, inp) {
    const c = gf();
    for (let i = 0; i < 16; i++) {
        c[i] = inp[i];
    }
    for (let i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
            mul(c, c, inp);
        }
    }
    for (let i = 0; i < 16; i++) {
        o[i] = c[i];
    }
}
function scalarMult(n, p) {
    const z = new Uint8Array(32);
    const x = new Float64Array(80);
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for (let i = 0; i < 31; i++) {
        z[i] = n[i];
    }
    z[31] = (n[31] & 127) | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for (let i = 0; i < 16; i++) {
        b[i] = x[i];
    }
    a[0] = d[0] = 1;
    for (let i = 254; i >= 0; --i) {
        const r = (z[i >>> 3] >>> (i & 7)) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for (let i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
    }
    const x32 = x.subarray(32);
    const x16 = x.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    const q = new Uint8Array(32);
    pack25519(q, x16);
    return q;
}
exports.scalarMult = scalarMult;
function scalarMultBase(n) {
    return scalarMult(n, _9);
}
exports.scalarMultBase = scalarMultBase;
function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed);
    const publicKey = scalarMultBase(secretKey);
    return {
        publicKey,
        secretKey
    };
}
exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_1.wipe)(seed);
    return result;
}
exports.generateKeyPair = generateKeyPair;
/**
 * Returns a shared key between our secret key and a peer's public key.
 *
 * Throws an error if the given keys are of wrong length.
 *
 * If rejectZero is true throws if the calculated shared key is all-zero.
 * From RFC 7748:
 *
 * > Protocol designers using Diffie-Hellman over the curves defined in
 * > this document must not assume "contributory behavior".  Specially,
 * > contributory behavior means that both parties' private keys
 * > contribute to the resulting shared key.  Since curve25519 and
 * > curve448 have cofactors of 8 and 4 (respectively), an input point of
 * > small order will eliminate any contribution from the other party's
 * > private key.  This situation can be detected by checking for the all-
 * > zero output, which implementations MAY do, as specified in Section 6.
 * > However, a large number of existing implementations do not do this.
 *
 * IMPORTANT: the returned key is a raw result of scalar multiplication.
 * To use it as a key material, hash it with a cryptographic hash function.
 */
function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
        let zeros = 0;
        for (let i = 0; i < result.length; i++) {
            zeros |= result[i];
        }
        if (zeros === 0) {
            throw new Error("X25519: invalid shared key");
        }
    }
    return result;
}
exports.sharedKey = sharedKey;

}(x25519$2));

var x25519 = /*@__PURE__*/getDefaultExportFromCjs(x25519$2);

var x25519$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), x25519$2, {
    'default': x25519
}));

var require$$5$e = /*@__PURE__*/getAugmentedNamespace(x25519$1);

var concat$2 = {};

var alloc$5 = {};

var asUint8array$4 = {};

Object.defineProperty(asUint8array$4, '__esModule', { value: true });

function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

var asUint8Array_1 = asUint8array$4.asUint8Array = asUint8Array;

var asUint8array$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), asUint8array$4, {
    asUint8Array: asUint8Array_1,
    'default': asUint8array$4
}));

var require$$1$y = /*@__PURE__*/getAugmentedNamespace(asUint8array$3);

Object.defineProperty(alloc$5, '__esModule', { value: true });

var asUint8array$2 = require$$1$y;

function alloc$3(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
    return asUint8array$2.asUint8Array(globalThis.Buffer.alloc(size));
  }
  return new Uint8Array(size);
}
function allocUnsafe$2(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8array$2.asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

var alloc_2 = alloc$5.alloc = alloc$3;
var allocUnsafe_1 = alloc$5.allocUnsafe = allocUnsafe$2;

var alloc$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), alloc$5, {
    alloc: alloc_2,
    allocUnsafe: allocUnsafe_1,
    'default': alloc$5
}));

var require$$1$x = /*@__PURE__*/getAugmentedNamespace(alloc$4);

Object.defineProperty(concat$2, '__esModule', { value: true });

var alloc$2 = require$$1$x;
var asUint8array$1 = require$$1$y;

function concat(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = alloc$2.allocUnsafe(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8array$1.asUint8Array(output);
}

var concat_2 = concat$2.concat = concat;

var concat$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), concat$2, {
    concat: concat_2,
    'default': concat$2
}));

var require$$6$b = /*@__PURE__*/getAugmentedNamespace(concat$1);

var fromString$4 = {};

var basics$2 = {};

var identity$7 = {};

var base$c = {};

function base$b(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array);
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }
    if (source.length === 0) {
      return '';
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === ' ') {
      return;
    }
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      psz++;
    }
    if (source[psz] === ' ') {
      return;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${ name } character`);
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}
var src$1 = base$b;
var _brrp__multiformats_scope_baseX = src$1;

var baseX$2 = _brrp__multiformats_scope_baseX;

var baseX$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), baseX$2, {
    'default': baseX$2
}));

var require$$0$k = /*@__PURE__*/getAugmentedNamespace(baseX$3);

var bytes$a = {};

Object.defineProperty(bytes$a, '__esModule', { value: true });

const empty = new Uint8Array(0);
const toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');
const fromHex = hex => {
  const hexes = hex.match(/../g);
  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;
};
const equals$1 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce = o => {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error('Unknown type, must be binary type');
};
const isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
const fromString$3 = str => new TextEncoder().encode(str);
const toString$8 = b => new TextDecoder().decode(b);

var coerce_1 = bytes$a.coerce = coerce;
var empty_1 = bytes$a.empty = empty;
var equals_1$1 = bytes$a.equals = equals$1;
var fromHex_1 = bytes$a.fromHex = fromHex;
var fromString_1 = bytes$a.fromString = fromString$3;
var isBinary_1 = bytes$a.isBinary = isBinary;
var toHex_1 = bytes$a.toHex = toHex;
var toString_1 = bytes$a.toString = toString$8;

var bytes$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bytes$a, {
    coerce: coerce_1,
    empty: empty_1,
    equals: equals_1$1,
    fromHex: fromHex_1,
    fromString: fromString_1,
    isBinary: isBinary_1,
    toHex: toHex_1,
    toString: toString_1,
    'default': bytes$a
}));

var require$$18 = /*@__PURE__*/getAugmentedNamespace(bytes$9);

Object.defineProperty(base$c, '__esModule', { value: true });

var baseX$1 = require$$0$k;
var bytes$8 = require$$18;

class Encoder {
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${ this.prefix }${ this.baseEncode(bytes) }`;
    } else {
      throw Error('Unknown type, must be binary type');
    }
  }
}
class Decoder {
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === undefined) {
      throw new Error('Invalid prefix character');
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === 'string') {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error('Can only multibase decode strings');
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);
    }
  }
}
const or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$2 = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);
const baseX = ({prefix, name, alphabet}) => {
  const {encode, decode} = baseX$1(alphabet, name);
  return from$2({
    prefix,
    name,
    encode,
    decode: text => bytes$8.coerce(decode(text))
  });
};
const decode$7 = (string, alphabet, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }
  let end = string.length;
  while (string[end - 1] === '=') {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string[i]];
    if (value === undefined) {
      throw new SyntaxError(`Non-${ name } character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError('Unexpected end of data');
  }
  return out;
};
const encode$5 = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '=';
  const mask = (1 << bitsPerChar) - 1;
  let out = '';
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += '=';
    }
  }
  return out;
};
const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {
  return from$2({
    prefix,
    name,
    encode(input) {
      return encode$5(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode$7(input, alphabet, bitsPerChar, name);
    }
  });
};

var Codec_1 = base$c.Codec = Codec;
var baseX_1 = base$c.baseX = baseX;
var from_1$1 = base$c.from = from$2;
var or_1 = base$c.or = or;
var rfc4648_1 = base$c.rfc4648 = rfc4648;

var base$a = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base$c, {
    Codec: Codec_1,
    baseX: baseX_1,
    from: from_1$1,
    or: or_1,
    rfc4648: rfc4648_1,
    'default': base$c
}));

var require$$0$j = /*@__PURE__*/getAugmentedNamespace(base$a);

Object.defineProperty(identity$7, '__esModule', { value: true });

var base$9 = require$$0$j;
var bytes$7 = require$$18;

const identity$5 = base$9.from({
  prefix: '\0',
  name: 'identity',
  encode: buf => bytes$7.toString(buf),
  decode: str => bytes$7.fromString(str)
});

var identity_2$1 = identity$7.identity = identity$5;

var identity$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), identity$7, {
    identity: identity_2$1,
    'default': identity$7
}));

var require$$0$i = /*@__PURE__*/getAugmentedNamespace(identity$6);

var base2$3 = {};

Object.defineProperty(base2$3, '__esModule', { value: true });

var base$8 = require$$0$j;

const base2$1 = base$8.rfc4648({
  prefix: '0',
  name: 'base2',
  alphabet: '01',
  bitsPerChar: 1
});

var base2_2 = base2$3.base2 = base2$1;

var base2$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base2$3, {
    base2: base2_2,
    'default': base2$3
}));

var require$$1$w = /*@__PURE__*/getAugmentedNamespace(base2$2);

var base8$3 = {};

Object.defineProperty(base8$3, '__esModule', { value: true });

var base$7 = require$$0$j;

const base8$1 = base$7.rfc4648({
  prefix: '7',
  name: 'base8',
  alphabet: '01234567',
  bitsPerChar: 3
});

var base8_2 = base8$3.base8 = base8$1;

var base8$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base8$3, {
    base8: base8_2,
    'default': base8$3
}));

var require$$2$n = /*@__PURE__*/getAugmentedNamespace(base8$2);

var base10$3 = {};

Object.defineProperty(base10$3, '__esModule', { value: true });

var base$6 = require$$0$j;

const base10$1 = base$6.baseX({
  prefix: '9',
  name: 'base10',
  alphabet: '0123456789'
});

var base10_2 = base10$3.base10 = base10$1;

var base10$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base10$3, {
    base10: base10_2,
    'default': base10$3
}));

var require$$3$k = /*@__PURE__*/getAugmentedNamespace(base10$2);

var base16$3 = {};

Object.defineProperty(base16$3, '__esModule', { value: true });

var base$5 = require$$0$j;

const base16$1 = base$5.rfc4648({
  prefix: 'f',
  name: 'base16',
  alphabet: '0123456789abcdef',
  bitsPerChar: 4
});
const base16upper = base$5.rfc4648({
  prefix: 'F',
  name: 'base16upper',
  alphabet: '0123456789ABCDEF',
  bitsPerChar: 4
});

var base16_2 = base16$3.base16 = base16$1;
var base16upper_1 = base16$3.base16upper = base16upper;

var base16$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base16$3, {
    base16: base16_2,
    base16upper: base16upper_1,
    'default': base16$3
}));

var require$$4$f = /*@__PURE__*/getAugmentedNamespace(base16$2);

var base32$4 = {};

Object.defineProperty(base32$4, '__esModule', { value: true });

var base$4 = require$$0$j;

const base32$2 = base$4.rfc4648({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
});
const base32upper = base$4.rfc4648({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
});
const base32pad = base$4.rfc4648({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
});
const base32padupper = base$4.rfc4648({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
});
const base32hex = base$4.rfc4648({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
});
const base32hexupper = base$4.rfc4648({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
});
const base32hexpad = base$4.rfc4648({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
});
const base32hexpadupper = base$4.rfc4648({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
});
const base32z = base$4.rfc4648({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
});

var base32_2 = base32$4.base32 = base32$2;
var base32hex_1 = base32$4.base32hex = base32hex;
var base32hexpad_1 = base32$4.base32hexpad = base32hexpad;
var base32hexpadupper_1 = base32$4.base32hexpadupper = base32hexpadupper;
var base32hexupper_1 = base32$4.base32hexupper = base32hexupper;
var base32pad_1 = base32$4.base32pad = base32pad;
var base32padupper_1 = base32$4.base32padupper = base32padupper;
var base32upper_1 = base32$4.base32upper = base32upper;
var base32z_1 = base32$4.base32z = base32z;

var base32$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base32$4, {
    base32: base32_2,
    base32hex: base32hex_1,
    base32hexpad: base32hexpad_1,
    base32hexpadupper: base32hexpadupper_1,
    base32hexupper: base32hexupper_1,
    base32pad: base32pad_1,
    base32padupper: base32padupper_1,
    base32upper: base32upper_1,
    base32z: base32z_1,
    'default': base32$4
}));

var require$$5$d = /*@__PURE__*/getAugmentedNamespace(base32$3);

var base36$3 = {};

Object.defineProperty(base36$3, '__esModule', { value: true });

var base$3 = require$$0$j;

const base36$1 = base$3.baseX({
  prefix: 'k',
  name: 'base36',
  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = base$3.baseX({
  prefix: 'K',
  name: 'base36upper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});

var base36_2 = base36$3.base36 = base36$1;
var base36upper_1 = base36$3.base36upper = base36upper;

var base36$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base36$3, {
    base36: base36_2,
    base36upper: base36upper_1,
    'default': base36$3
}));

var require$$6$a = /*@__PURE__*/getAugmentedNamespace(base36$2);

var base58$3 = {};

Object.defineProperty(base58$3, '__esModule', { value: true });

var base$2 = require$$0$j;

const base58btc = base$2.baseX({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = base$2.baseX({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});

var base58btc_1 = base58$3.base58btc = base58btc;
var base58flickr_1 = base58$3.base58flickr = base58flickr;

var base58$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base58$3, {
    base58btc: base58btc_1,
    base58flickr: base58flickr_1,
    'default': base58$3
}));

var require$$7$9 = /*@__PURE__*/getAugmentedNamespace(base58$2);

var base64$3 = {};

Object.defineProperty(base64$3, '__esModule', { value: true });

var base$1 = require$$0$j;

const base64$1 = base$1.rfc4648({
  prefix: 'm',
  name: 'base64',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  bitsPerChar: 6
});
const base64pad = base$1.rfc4648({
  prefix: 'M',
  name: 'base64pad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  bitsPerChar: 6
});
const base64url = base$1.rfc4648({
  prefix: 'u',
  name: 'base64url',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  bitsPerChar: 6
});
const base64urlpad = base$1.rfc4648({
  prefix: 'U',
  name: 'base64urlpad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
  bitsPerChar: 6
});

var base64_2 = base64$3.base64 = base64$1;
var base64pad_1 = base64$3.base64pad = base64pad;
var base64url_1 = base64$3.base64url = base64url;
var base64urlpad_1 = base64$3.base64urlpad = base64urlpad;

var base64$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base64$3, {
    base64: base64_2,
    base64pad: base64pad_1,
    base64url: base64url_1,
    base64urlpad: base64urlpad_1,
    'default': base64$3
}));

var require$$8$7 = /*@__PURE__*/getAugmentedNamespace(base64$2);

var base256emoji$3 = {};

Object.defineProperty(base256emoji$3, '__esModule', { value: true });

var base = require$$0$j;

const alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42');
const alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode$4(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, '');
}
function decode$6(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === undefined) {
      throw new Error(`Non-base256emoji character: ${ char }`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji$1 = base.from({
  prefix: '\uD83D\uDE80',
  name: 'base256emoji',
  encode: encode$4,
  decode: decode$6
});

var base256emoji_2 = base256emoji$3.base256emoji = base256emoji$1;

var base256emoji$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), base256emoji$3, {
    base256emoji: base256emoji_2,
    'default': base256emoji$3
}));

var require$$9$3 = /*@__PURE__*/getAugmentedNamespace(base256emoji$2);

var sha2$2 = {};

var hasher$4 = {};

var digest$6 = {};

var varint$7 = {};

var encode_1$2 = encode$3;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode$3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$3.bytes = offset - oldOffset + 1;
  return out;
}
var decode$5 = read$1;
var MSB$1 = 128, REST$1 = 127;
function read$1(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read$1.bytes = 0;
      throw new RangeError('Could not decode varint');
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read$1.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function (value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint$5 = {
  encode: encode_1$2,
  decode: decode$5,
  encodingLength: length
};
var _brrp_varint = varint$5;
var varint$1$2 = _brrp_varint;

var varint_1$1 = varint$1$2;

var varint$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), varint_1$1, {
    'default': varint_1$1
}));

var require$$0$h = /*@__PURE__*/getAugmentedNamespace(varint$6);

Object.defineProperty(varint$7, '__esModule', { value: true });

var varint$1$1 = require$$0$h;

const decode$4 = (data, offset = 0) => {
  const code = varint$1$1.decode(data, offset);
  return [
    code,
    varint$1$1.decode.bytes
  ];
};
const encodeTo = (int, target, offset = 0) => {
  varint$1$1.encode(int, target, offset);
  return target;
};
const encodingLength = int => {
  return varint$1$1.encodingLength(int);
};

var decode_1$3 = varint$7.decode = decode$4;
var encodeTo_1 = varint$7.encodeTo = encodeTo;
var encodingLength_1 = varint$7.encodingLength = encodingLength;

var varint$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), varint$7, {
    decode: decode_1$3,
    encodeTo: encodeTo_1,
    encodingLength: encodingLength_1,
    'default': varint$7
}));

var require$$17 = /*@__PURE__*/getAugmentedNamespace(varint$4);

Object.defineProperty(digest$6, '__esModule', { value: true });

var bytes$6 = require$$18;
var varint$3 = require$$17;

const create$3 = (code, digest) => {
  const size = digest.byteLength;
  const sizeOffset = varint$3.encodingLength(code);
  const digestOffset = sizeOffset + varint$3.encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  varint$3.encodeTo(code, bytes, 0);
  varint$3.encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
};
const decode$3 = multihash => {
  const bytes$1 = bytes$6.coerce(multihash);
  const [code, sizeOffset] = varint$3.decode(bytes$1);
  const [size, digestOffset] = varint$3.decode(bytes$1.subarray(sizeOffset));
  const digest = bytes$1.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error('Incorrect length');
  }
  return new Digest(code, size, digest, bytes$1);
};
const equals = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && bytes$6.equals(a.bytes, b.bytes);
  }
};
class Digest {
  constructor(code, size, digest, bytes) {
    this.code = code;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
}

var Digest_1 = digest$6.Digest = Digest;
var create_1 = digest$6.create = create$3;
var decode_1$2 = digest$6.decode = decode$3;
var equals_1 = digest$6.equals = equals;

var digest$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), digest$6, {
    Digest: Digest_1,
    create: create_1,
    decode: decode_1$2,
    equals: equals_1,
    'default': digest$6
}));

var require$$16 = /*@__PURE__*/getAugmentedNamespace(digest$5);

Object.defineProperty(hasher$4, '__esModule', { value: true });

var digest$4 = require$$16;

const from$1 = ({name, code, encode}) => new Hasher(name, code, encode);
class Hasher {
  constructor(name, code, encode) {
    this.name = name;
    this.code = code;
    this.encode = encode;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? digest$4.create(this.code, result) : result.then(digest$1 => digest$4.create(this.code, digest$1));
    } else {
      throw Error('Unknown type, must be binary type');
    }
  }
}

var Hasher_1 = hasher$4.Hasher = Hasher;
var from_1 = hasher$4.from = from$1;

var hasher$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), hasher$4, {
    Hasher: Hasher_1,
    from: from_1,
    'default': hasher$4
}));

var require$$15 = /*@__PURE__*/getAugmentedNamespace(hasher$3);

Object.defineProperty(sha2$2, '__esModule', { value: true });

var crypto$a = nodeCrypto__default;
var hasher$2 = require$$15;
var bytes$5 = require$$18;

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto$a);

const sha256 = hasher$2.from({
  name: 'sha2-256',
  code: 18,
  encode: input => bytes$5.coerce(crypto__default["default"].createHash('sha256').update(input).digest())
});
const sha512 = hasher$2.from({
  name: 'sha2-512',
  code: 19,
  encode: input => bytes$5.coerce(crypto__default["default"].createHash('sha512').update(input).digest())
});

var sha256_1 = sha2$2.sha256 = sha256;
var sha512_1 = sha2$2.sha512 = sha512;

var sha2$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), sha2$2, {
    sha256: sha256_1,
    sha512: sha512_1,
    'default': sha2$2
}));

var require$$10$3 = /*@__PURE__*/getAugmentedNamespace(sha2$1);

var identity$4 = {};

Object.defineProperty(identity$4, '__esModule', { value: true });

var bytes$4 = require$$18;
var digest$1$1 = require$$16;

const code$2 = 0;
const name$2 = 'identity';
const encode$2 = bytes$4.coerce;
const digest$3 = input => digest$1$1.create(code$2, encode$2(input));
const identity$2 = {
  code: code$2,
  name: name$2,
  encode: encode$2,
  digest: digest$3
};

var identity_2 = identity$4.identity = identity$2;

var identity$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), identity$4, {
    identity: identity_2,
    'default': identity$4
}));

var require$$11$3 = /*@__PURE__*/getAugmentedNamespace(identity$3);

var raw$2 = {};

Object.defineProperty(raw$2, '__esModule', { value: true });

var bytes$3 = require$$18;

const name$1 = 'raw';
const code$1 = 85;
const encode$1 = node => bytes$3.coerce(node);
const decode$2 = data => bytes$3.coerce(data);

var code_1$1 = raw$2.code = code$1;
var decode_1$1 = raw$2.decode = decode$2;
var encode_1$1 = raw$2.encode = encode$1;
var name_1$1 = raw$2.name = name$1;

var raw$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), raw$2, {
    code: code_1$1,
    decode: decode_1$1,
    encode: encode_1$1,
    name: name_1$1,
    'default': raw$2
}));

var require$$12$3 = /*@__PURE__*/getAugmentedNamespace(raw$1);

var json$4 = {};

Object.defineProperty(json$4, '__esModule', { value: true });

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = 'json';
const code = 512;
const encode = node => textEncoder.encode(JSON.stringify(node));
const decode$1 = data => JSON.parse(textDecoder.decode(data));

var code_1 = json$4.code = code;
var decode_1 = json$4.decode = decode$1;
var encode_1 = json$4.encode = encode;
var name_1 = json$4.name = name;

var json$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), json$4, {
    code: code_1,
    decode: decode_1,
    encode: encode_1,
    name: name_1,
    'default': json$4
}));

var require$$13$2 = /*@__PURE__*/getAugmentedNamespace(json$3);

var src = {};

var cid$3 = {};

Object.defineProperty(cid$3, '__esModule', { value: true });

var varint$2 = require$$17;
var digest$2 = require$$16;
var base58$1 = require$$7$9;
var base32$1 = require$$5$d;
var bytes$2 = require$$18;

class CID$1 {
  constructor(version, code, multihash, bytes) {
    this.code = code;
    this.version = version;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
    case 0: {
        return this;
      }
    default: {
        const {code, multihash} = this;
        if (code !== DAG_PB_CODE) {
          throw new Error('Cannot convert a non dag-pb CID to CIDv0');
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
        }
        return CID$1.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
    case 0: {
        const {code, digest: digest$1} = this.multihash;
        const multihash = digest$2.create(code, digest$1);
        return CID$1.createV1(this.code, multihash);
      }
    case 1: {
        return this;
      }
    default: {
        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && digest$2.equals(this.multihash, other.multihash);
  }
  toString(base) {
    const {bytes, version, _baseCache} = this;
    switch (version) {
    case 0:
      return toStringV0(bytes, _baseCache, base || base58$1.base58btc.encoder);
    default:
      return toStringV1(bytes, _baseCache, base || base32$1.base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return 'CID';
  }
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return 'CID(' + this.toString() + ')';
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error('Deprecated, use .toString()');
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$1) {
      return value;
    } else if (value != null && value.asCID === value) {
      const {version, code, multihash, bytes} = value;
      return new CID$1(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const {version, multihash, code} = value;
      const digest$1 = digest$2.decode(multihash);
      return CID$1.create(version, code, digest$1);
    } else {
      return null;
    }
  }
  static create(version, code, digest) {
    if (typeof code !== 'number') {
      throw new Error('String codecs are no longer supported');
    }
    switch (version) {
    case 0: {
        if (code !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);
        } else {
          return new CID$1(version, code, digest, digest.bytes);
        }
      }
    case 1: {
        const bytes = encodeCID(version, code, digest.bytes);
        return new CID$1(version, code, digest, bytes);
      }
    default: {
        throw new Error('Invalid version');
      }
    }
  }
  static createV0(digest) {
    return CID$1.create(0, DAG_PB_CODE, digest);
  }
  static createV1(code, digest) {
    return CID$1.create(1, code, digest);
  }
  static decode(bytes) {
    const [cid, remainder] = CID$1.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error('Incorrect length');
    }
    return cid;
  }
  static decodeFirst(bytes$1) {
    const specs = CID$1.inspectBytes(bytes$1);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = bytes$2.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error('Incorrect length');
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest$1 = new digest$2.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$1.createV0(digest$1) : CID$1.createV1(specs.codec, digest$1);
    return [
      cid,
      bytes$1.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length] = varint$2.decode(initialBytes.subarray(offset));
      offset += length;
      return i;
    };
    let version = next();
    let codec = DAG_PB_CODE;
    if (version === 18) {
      version = 0;
      offset = 0;
    } else if (version === 1) {
      codec = next();
    }
    if (version !== 0 && version !== 1) {
      throw new RangeError(`Invalid CID version ${ version }`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base) {
    const [prefix, bytes] = parseCIDtoBytes(source, base);
    const cid = CID$1.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes = (source, base) => {
  switch (source[0]) {
  case 'Q': {
      const decoder = base || base58$1.base58btc;
      return [
        base58$1.base58btc.prefix,
        decoder.decode(`${ base58$1.base58btc.prefix }${ source }`)
      ];
    }
  case base58$1.base58btc.prefix: {
      const decoder = base || base58$1.base58btc;
      return [
        base58$1.base58btc.prefix,
        decoder.decode(source)
      ];
    }
  case base32$1.base32.prefix: {
      const decoder = base || base32$1.base32;
      return [
        base32$1.base32.prefix,
        decoder.decode(source)
      ];
    }
  default: {
      if (base == null) {
        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
      }
      return [
        source[0],
        base.decode(source)
      ];
    }
  }
};
const toStringV0 = (bytes, cache, base) => {
  const {prefix} = base;
  if (prefix !== base58$1.base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid = base.encode(bytes).slice(1);
    cache.set(prefix, cid);
    return cid;
  } else {
    return cid;
  }
};
const toStringV1 = (bytes, cache, base) => {
  const {prefix} = base;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid = base.encode(bytes);
    cache.set(prefix, cid);
    return cid;
  } else {
    return cid;
  }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version, code, multihash) => {
  const codeOffset = varint$2.encodingLength(version);
  const hashOffset = codeOffset + varint$2.encodingLength(code);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  varint$2.encodeTo(version, bytes, 0);
  varint$2.encodeTo(code, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
const cidSymbol = Symbol.for('@ipld/js-cid/CID');
const readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$2 = '0.0.0-dev';
const deprecate = (range, message) => {
  if (range.test(version$2)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

var CID_1 = cid$3.CID = CID$1;

var cid$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cid$3, {
    CID: CID_1,
    'default': cid$3
}));

var require$$14$1 = /*@__PURE__*/getAugmentedNamespace(cid$2);

Object.defineProperty(src, '__esModule', { value: true });

var cid$1 = require$$14$1;
var varint$1 = require$$17;
var bytes$1 = require$$18;
var hasher$1 = require$$15;
var digest$1 = require$$16;



src.CID = cid$1.CID;
src.varint = varint$1;
src.bytes = bytes$1;
src.hasher = hasher$1;
src.digest = digest$1;

Object.defineProperty(basics$2, '__esModule', { value: true });

var identity = require$$0$i;
var base2 = require$$1$w;
var base8 = require$$2$n;
var base10 = require$$3$k;
var base16 = require$$4$f;
var base32 = require$$5$d;
var base36 = require$$6$a;
var base58 = require$$7$9;
var base64 = require$$8$7;
var base256emoji = require$$9$3;
var sha2 = require$$10$3;
var identity$1 = require$$11$3;
var raw = require$$12$3;
var json$2 = require$$13$2;

var cid = require$$14$1;
var hasher = require$$15;
var digest = require$$16;
var varint = require$$17;
var bytes = require$$18;

const bases$4 = {
  ...identity,
  ...base2,
  ...base8,
  ...base10,
  ...base16,
  ...base32,
  ...base36,
  ...base58,
  ...base64,
  ...base256emoji
};
const hashes = {
  ...sha2,
  ...identity$1
};
const codecs = {
  raw,
  json: json$2
};

var CID = basics$2.CID = cid.CID;
var hasher_1 = basics$2.hasher = hasher;
var digest_1 = basics$2.digest = digest;
var varint_1 = basics$2.varint = varint;
var bytes_1 = basics$2.bytes = bytes;
var bases_1 = basics$2.bases = bases$4;
var codecs_1 = basics$2.codecs = codecs;
var hashes_1 = basics$2.hashes = hashes;

var basics$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), basics$2, {
    CID: CID,
    hasher: hasher_1,
    digest: digest_1,
    varint: varint_1,
    bytes: bytes_1,
    bases: bases_1,
    codecs: codecs_1,
    hashes: hashes_1,
    'default': basics$2
}));

var require$$0$g = /*@__PURE__*/getAugmentedNamespace(basics$1);

var basics = require$$0$g;
var alloc$1 = require$$1$x;

function createCodec(name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: { decode }
  };
}
const string = createCodec('utf8', 'u', buf => {
  const decoder = new TextDecoder('utf8');
  return 'u' + decoder.decode(buf);
}, str => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', buf => {
  let string = 'a';
  for (let i = 0; i < buf.length; i++) {
    string += String.fromCharCode(buf[i]);
  }
  return string;
}, str => {
  str = str.substring(1);
  const buf = alloc$1.allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
const BASES = {
  utf8: string,
  'utf-8': string,
  hex: basics.bases.base16,
  latin1: ascii,
  ascii: ascii,
  binary: ascii,
  ...basics.bases
};

var bases$2 = BASES;

var bases$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bases$2, {
    'default': bases$2
}));

var require$$0$f = /*@__PURE__*/getAugmentedNamespace(bases$3);

Object.defineProperty(fromString$4, '__esModule', { value: true });

var bases$1 = require$$0$f;
var asUint8array = require$$1$y;

function fromString$1(string, encoding = 'utf8') {
  const base = bases$1[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${ encoding }"`);
  }
  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8array.asUint8Array(globalThis.Buffer.from(string, 'utf-8'));
  }
  return base.decoder.decode(`${ base.prefix }${ string }`);
}

var fromString_2 = fromString$4.fromString = fromString$1;

var fromString$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), fromString$4, {
    fromString: fromString_2,
    'default': fromString$4
}));

var require$$7$8 = /*@__PURE__*/getAugmentedNamespace(fromString$2);

var toString$7 = {};

Object.defineProperty(toString$7, '__esModule', { value: true });

var bases = require$$0$f;

function toString$5(array, encoding = 'utf8') {
  const base = bases[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${ encoding }"`);
  }
  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
  }
  return base.encoder.encode(array).substring(1);
}

var toString_2 = toString$7.toString = toString$5;

var toString$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), toString$7, {
    toString: toString_2,
    'default': toString$7
}));

var require$$8$6 = /*@__PURE__*/getAugmentedNamespace(toString$6);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserialize = exports.serialize = exports.decrypt = exports.encrypt = exports.hashMessage = exports.hashKey = exports.deriveSymmetricKey = exports.deriveSharedKey = exports.generateRandomBytes32 = exports.generateKeyPair = exports.UTF8 = exports.BASE64 = exports.BASE16 = void 0;
const tslib_1 = require$$0$G;
const chacha20poly1305_1 = require$$1$A;
const hkdf_1 = require$$2$o;
const random_1 = require$$3$l;
const sha256_1 = require$$4$g;
const x25519 = tslib_1.__importStar(require$$5$e);
const concat_1 = require$$6$b;
const from_string_1 = require$$7$8;
const to_string_1 = require$$8$6;
exports.BASE16 = "base16";
exports.BASE64 = "base64pad";
exports.UTF8 = "utf8";
const ZERO_INDEX = 0;
const IV_LENGTH = 12;
const KEY_LENGTH = 32;
function generateKeyPair() {
    const keyPair = x25519.generateKeyPair();
    return {
        privateKey: to_string_1.toString(keyPair.secretKey, exports.BASE16),
        publicKey: to_string_1.toString(keyPair.publicKey, exports.BASE16),
    };
}
exports.generateKeyPair = generateKeyPair;
function generateRandomBytes32() {
    const random = random_1.randomBytes(KEY_LENGTH);
    return to_string_1.toString(random, exports.BASE16);
}
exports.generateRandomBytes32 = generateRandomBytes32;
function deriveSharedKey(privateKeyA, publicKeyB) {
    const sharedKey = x25519.sharedKey(from_string_1.fromString(privateKeyA, exports.BASE16), from_string_1.fromString(publicKeyB, exports.BASE16));
    return to_string_1.toString(sharedKey, exports.BASE16);
}
exports.deriveSharedKey = deriveSharedKey;
function deriveSymmetricKey(sharedKey) {
    const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, from_string_1.fromString(sharedKey, exports.BASE16));
    const symKey = hkdf.expand(KEY_LENGTH);
    return to_string_1.toString(symKey, exports.BASE16);
}
exports.deriveSymmetricKey = deriveSymmetricKey;
function hashKey(key) {
    const result = sha256_1.hash(from_string_1.fromString(key, exports.BASE16));
    return to_string_1.toString(result, exports.BASE16);
}
exports.hashKey = hashKey;
function hashMessage(message) {
    const result = sha256_1.hash(from_string_1.fromString(message, exports.UTF8));
    return to_string_1.toString(result, exports.BASE16);
}
exports.hashMessage = hashMessage;
function encrypt(params) {
    const iv = typeof params.iv !== "undefined" ? from_string_1.fromString(params.iv, exports.BASE16) : random_1.randomBytes(IV_LENGTH);
    const box = new chacha20poly1305_1.ChaCha20Poly1305(from_string_1.fromString(params.symKey, exports.BASE16));
    const sealed = box.seal(iv, from_string_1.fromString(params.message, exports.UTF8));
    return serialize({ sealed, iv });
}
exports.encrypt = encrypt;
function decrypt(params) {
    const box = new chacha20poly1305_1.ChaCha20Poly1305(from_string_1.fromString(params.symKey, exports.BASE16));
    const { sealed, iv } = deserialize(params.encoded);
    const message = box.open(iv, sealed);
    if (message === null)
        throw new Error("Failed to decrypt");
    return to_string_1.toString(message, exports.UTF8);
}
exports.decrypt = decrypt;
function serialize(params) {
    return to_string_1.toString(concat_1.concat([params.iv, params.sealed]), exports.BASE64);
}
exports.serialize = serialize;
function deserialize(encoded) {
    const array = from_string_1.fromString(encoded, exports.BASE64);
    const iv = array.slice(ZERO_INDEX, IV_LENGTH);
    const sealed = array.slice(IV_LENGTH);
    return { sealed, iv };
}
exports.deserialize = deserialize;

}(crypto$b));

var crypto$8 = /*@__PURE__*/getDefaultExportFromCjs(crypto$b);

var crypto$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), crypto$b, {
    'default': crypto$8
}));

var require$$2$m = /*@__PURE__*/getAugmentedNamespace(crypto$9);

var error$2 = {};

var misc$4 = {};

var cjs$b = {};

Object.defineProperty(cjs$b, "__esModule", { value: true });
var getLocalStorage_1 = cjs$b.getLocalStorage = getLocalStorageOrThrow_1 = cjs$b.getLocalStorageOrThrow = getCrypto_1 = cjs$b.getCrypto = getCryptoOrThrow_1 = cjs$b.getCryptoOrThrow = getLocation_1 = cjs$b.getLocation = getLocationOrThrow_1 = cjs$b.getLocationOrThrow = getNavigator_1 = cjs$b.getNavigator = getNavigatorOrThrow_1 = cjs$b.getNavigatorOrThrow = getDocument_1 = cjs$b.getDocument = getDocumentOrThrow_1 = cjs$b.getDocumentOrThrow = getFromWindowOrThrow_1 = cjs$b.getFromWindowOrThrow = getFromWindow_1 = cjs$b.getFromWindow = void 0;
function getFromWindow$1(name) {
    let res = undefined;
    if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
    }
    return res;
}
var getFromWindow_1 = cjs$b.getFromWindow = getFromWindow$1;
function getFromWindowOrThrow$1(name) {
    const res = getFromWindow$1(name);
    if (!res) {
        throw new Error(`${name} is not defined in Window`);
    }
    return res;
}
var getFromWindowOrThrow_1 = cjs$b.getFromWindowOrThrow = getFromWindowOrThrow$1;
function getDocumentOrThrow$1() {
    return getFromWindowOrThrow$1("document");
}
var getDocumentOrThrow_1 = cjs$b.getDocumentOrThrow = getDocumentOrThrow$1;
function getDocument$1() {
    return getFromWindow$1("document");
}
var getDocument_1 = cjs$b.getDocument = getDocument$1;
function getNavigatorOrThrow$1() {
    return getFromWindowOrThrow$1("navigator");
}
var getNavigatorOrThrow_1 = cjs$b.getNavigatorOrThrow = getNavigatorOrThrow$1;
function getNavigator$1() {
    return getFromWindow$1("navigator");
}
var getNavigator_1 = cjs$b.getNavigator = getNavigator$1;
function getLocationOrThrow$1() {
    return getFromWindowOrThrow$1("location");
}
var getLocationOrThrow_1 = cjs$b.getLocationOrThrow = getLocationOrThrow$1;
function getLocation$1() {
    return getFromWindow$1("location");
}
var getLocation_1 = cjs$b.getLocation = getLocation$1;
function getCryptoOrThrow$1() {
    return getFromWindowOrThrow$1("crypto");
}
var getCryptoOrThrow_1 = cjs$b.getCryptoOrThrow = getCryptoOrThrow$1;
function getCrypto$1() {
    return getFromWindow$1("crypto");
}
var getCrypto_1 = cjs$b.getCrypto = getCrypto$1;
function getLocalStorageOrThrow$1() {
    return getFromWindowOrThrow$1("localStorage");
}
var getLocalStorageOrThrow_1 = cjs$b.getLocalStorageOrThrow = getLocalStorageOrThrow$1;
function getLocalStorage$1() {
    return getFromWindow$1("localStorage");
}
getLocalStorage_1 = cjs$b.getLocalStorage = getLocalStorage$1;

var cjs$a = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$b, {
    get getLocalStorage () { return getLocalStorage_1; },
    get getLocalStorageOrThrow () { return getLocalStorageOrThrow_1; },
    get getCrypto () { return getCrypto_1; },
    get getCryptoOrThrow () { return getCryptoOrThrow_1; },
    get getLocation () { return getLocation_1; },
    get getLocationOrThrow () { return getLocationOrThrow_1; },
    get getNavigator () { return getNavigator_1; },
    get getNavigatorOrThrow () { return getNavigatorOrThrow_1; },
    get getDocument () { return getDocument_1; },
    get getDocumentOrThrow () { return getDocumentOrThrow_1; },
    get getFromWindowOrThrow () { return getFromWindowOrThrow_1; },
    get getFromWindow () { return getFromWindow_1; },
    'default': cjs$b
}));

var require$$1$v = /*@__PURE__*/getAugmentedNamespace(cjs$a);

var cjs$9 = {};

Object.defineProperty(cjs$9, "__esModule", { value: true });
var getWindowMetadata_1 = cjs$9.getWindowMetadata = void 0;
const window_getters_1 = require$$1$v;
function getWindowMetadata() {
    let doc;
    let loc;
    try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
    }
    catch (e) {
        return null;
    }
    function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons = [];
        for (let i = 0; i < links.length; i++) {
            const link = links[i];
            const rel = link.getAttribute("rel");
            if (rel) {
                if (rel.toLowerCase().indexOf("icon") > -1) {
                    const href = link.getAttribute("href");
                    if (href) {
                        if (href.toLowerCase().indexOf("https:") === -1 &&
                            href.toLowerCase().indexOf("http:") === -1 &&
                            href.indexOf("//") !== 0) {
                            let absoluteHref = loc.protocol + "//" + loc.host;
                            if (href.indexOf("/") === 0) {
                                absoluteHref += href;
                            }
                            else {
                                const path = loc.pathname.split("/");
                                path.pop();
                                const finalPath = path.join("/");
                                absoluteHref += finalPath + "/" + href;
                            }
                            icons.push(absoluteHref);
                        }
                        else if (href.indexOf("//") === 0) {
                            const absoluteUrl = loc.protocol + href;
                            icons.push(absoluteUrl);
                        }
                        else {
                            icons.push(href);
                        }
                    }
                }
            }
        }
        return icons;
    }
    function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i = 0; i < metaTags.length; i++) {
            const tag = metaTags[i];
            const attributes = ["itemprop", "property", "name"]
                .map((target) => tag.getAttribute(target))
                .filter((attr) => {
                if (attr) {
                    return args.includes(attr);
                }
                return false;
            });
            if (attributes.length && attributes) {
                const content = tag.getAttribute("content");
                if (content) {
                    return content;
                }
            }
        }
        return "";
    }
    function getName() {
        let name = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name) {
            name = doc.title;
        }
        return name;
    }
    function getDescription() {
        const description = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description;
    }
    const name = getName();
    const description = getDescription();
    const url = loc.origin;
    const icons = getIcons();
    const meta = {
        description,
        url,
        icons,
        name,
    };
    return meta;
}
getWindowMetadata_1 = cjs$9.getWindowMetadata = getWindowMetadata;

var cjs$8 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$9, {
    get getWindowMetadata () { return getWindowMetadata_1; },
    'default': cjs$9
}));

var require$$1$u = /*@__PURE__*/getAugmentedNamespace(cjs$8);

var queryString$1 = {};

var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

var strictUriEncode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), strictUriEncode, {
    'default': strictUriEncode
}));

var require$$0$e = /*@__PURE__*/getAugmentedNamespace(strictUriEncode$1);

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return [decodeURIComponent(components.join(''))];
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher) || [];

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher) || [];
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

var decodeUriComponent = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};

var decodeUriComponent$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), decodeUriComponent, {
    'default': decodeUriComponent
}));

var require$$1$t = /*@__PURE__*/getAugmentedNamespace(decodeUriComponent$1);

var splitOnFirst = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};

var splitOnFirst$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), splitOnFirst, {
    'default': splitOnFirst
}));

var require$$2$l = /*@__PURE__*/getAugmentedNamespace(splitOnFirst$1);

var filterObj = function (obj, predicate) {
	var ret = {};
	var keys = Object.keys(obj);
	var isArr = Array.isArray(predicate);

	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var val = obj[key];

		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
			ret[key] = val;
		}
	}

	return ret;
};

var filterObj$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), filterObj, {
    'default': filterObj
}));

var require$$3$j = /*@__PURE__*/getAugmentedNamespace(filterObj$1);

(function (exports) {
const strictUriEncode = require$$0$e;
const decodeComponent = require$$1$t;
const splitOnFirst = require$$2$l;
const filterObject = require$$3$j;

const isNullOrUndefined = value => value === null || value === undefined;

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
			return key => (result, value) => {
				if (value === null || value === undefined || value.length === 0) {
					return result;
				}

				if (result.length === 0) {
					return [[encode(key, options), '=', encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
				value = isEncodedArray ? decode(value, options) : value;
				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(query, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof query !== 'string') {
		return ret;
	}

	query = query.trim().replace(/^[?#&]/, '');

	if (!query) {
		return ret;
	}

	for (const param of query.split('&')) {
		if (param === '') {
			continue;
		}

		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (url, options) => {
	options = Object.assign({
		decode: true
	}, options);

	const [url_, hash] = splitOnFirst(url, '#');

	return Object.assign(
		{
			url: url_.split('?')[0] || '',
			query: parse(extract(url), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = (object, options) => {
	options = Object.assign({
		encode: true,
		strict: true
	}, options);

	const url = removeHash(object.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(object.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	const query = Object.assign(parsedQueryFromUrl, object.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	let hash = getHash(object.url);
	if (object.fragmentIdentifier) {
		hash = `#${encode(object.fragmentIdentifier, options)}`;
	}

	return `${url}${queryString}${hash}`;
};

exports.pick = (input, filter, options) => {
	options = Object.assign({
		parseFragmentIdentifier: true
	}, options);

	const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
	return exports.stringifyUrl({
		url,
		query: filterObject(query, filter),
		fragmentIdentifier
	}, options);
};

exports.exclude = (input, filter, options) => {
	const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

	return exports.pick(input, exclusionFilter, options);
};
}(queryString$1));

var queryString = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), queryString$1, {
    'default': queryString$1
}));

var require$$1$s = /*@__PURE__*/getAugmentedNamespace(queryString);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.engineEvent = exports.formatIdTarget = exports.formatTopicTarget = exports.formatExpirerTarget = exports.createDelayedPromise = exports.isExpired = exports.calcExpiry = exports.capitalize = exports.capitalizeWord = exports.enumify = exports.mapEntries = exports.objToMap = exports.mapToObj = exports.getLastItems = exports.hasOverlap = exports.formatMessageContext = exports.parseContextNames = exports.assertType = exports.formatRelayRpcUrl = exports.getRelayClientMetadata = exports.getAppMetadata = exports.appendToQueryString = exports.getEnvironment = exports.isBrowser = exports.isReactNative = exports.isNode = exports.ONE_THOUSAND = exports.DEFAULT_DEPTH = exports.SLASH = exports.COLON = exports.EMPTY_SPACE = exports.ENV_MAP = exports.REACT_NATIVE_PRODUCT = void 0;
const tslib_1 = require$$0$G;
const time_1 = require$$3$q;
const window_getters_1 = require$$1$v;
const window_metadata_1 = require$$1$u;
const qs = tslib_1.__importStar(require$$1$s);
exports.REACT_NATIVE_PRODUCT = "ReactNative";
exports.ENV_MAP = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown",
};
exports.EMPTY_SPACE = " ";
exports.COLON = ":";
exports.SLASH = "/";
exports.DEFAULT_DEPTH = 2;
exports.ONE_THOUSAND = 1000;
function isNode() {
    return (typeof browser$1$1 !== "undefined" &&
        typeof browser$1$1.versions !== "undefined" &&
        typeof browser$1$1.versions.node !== "undefined");
}
exports.isNode = isNode;
function isReactNative() {
    return !window_getters_1.getDocument() && !!window_getters_1.getNavigator() && navigator.product === exports.REACT_NATIVE_PRODUCT;
}
exports.isReactNative = isReactNative;
function isBrowser() {
    return !isNode() && !!window_getters_1.getNavigator();
}
exports.isBrowser = isBrowser;
function getEnvironment() {
    if (isReactNative())
        return exports.ENV_MAP.reactNative;
    if (isNode())
        return exports.ENV_MAP.node;
    if (isBrowser())
        return exports.ENV_MAP.browser;
    return exports.ENV_MAP.unknown;
}
exports.getEnvironment = getEnvironment;
function appendToQueryString(queryString, newQueryParams) {
    let queryParams = qs.parse(queryString);
    queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
    queryString = qs.stringify(queryParams);
    return queryString;
}
exports.appendToQueryString = appendToQueryString;
function getAppMetadata() {
    return (window_metadata_1.getWindowMetadata() || {
        name: "",
        description: "",
        url: "",
        icons: [""],
    });
}
exports.getAppMetadata = getAppMetadata;
function getRelayClientMetadata(protocol, version) {
    var _a;
    const env = getEnvironment();
    const metadata = { protocol, version, env };
    if (env === "browser") {
        metadata.host = ((_a = window_getters_1.getLocation()) === null || _a === void 0 ? void 0 : _a.host) || "";
    }
    return metadata;
}
exports.getRelayClientMetadata = getRelayClientMetadata;
function formatRelayRpcUrl(protocol, version, url, projectId) {
    const splitUrl = url.split("?");
    const metadata = getRelayClientMetadata(protocol, version);
    const params = projectId ? Object.assign(Object.assign({}, metadata), { projectId }) : metadata;
    const queryString = appendToQueryString(splitUrl[1] || "", params);
    return splitUrl[0] + "?" + queryString;
}
exports.formatRelayRpcUrl = formatRelayRpcUrl;
function assertType(obj, key, type) {
    if (!obj[key] || typeof obj[key] !== type) {
        throw new Error(`Missing or invalid "${key}" param`);
    }
}
exports.assertType = assertType;
function parseContextNames(context, depth = exports.DEFAULT_DEPTH) {
    return getLastItems(context.split(exports.SLASH), depth);
}
exports.parseContextNames = parseContextNames;
function formatMessageContext(context) {
    return parseContextNames(context).join(exports.EMPTY_SPACE);
}
exports.formatMessageContext = formatMessageContext;
function hasOverlap(a, b) {
    const matches = a.filter(x => b.includes(x));
    return matches.length === a.length;
}
exports.hasOverlap = hasOverlap;
function getLastItems(arr, depth = exports.DEFAULT_DEPTH) {
    return arr.slice(Math.max(arr.length - depth, 0));
}
exports.getLastItems = getLastItems;
function mapToObj(map) {
    return Object.fromEntries(map.entries());
}
exports.mapToObj = mapToObj;
function objToMap(obj) {
    return new Map(Object.entries(obj));
}
exports.objToMap = objToMap;
function mapEntries(obj, cb) {
    const res = {};
    Object.keys(obj).forEach(key => {
        res[key] = cb(obj[key]);
    });
    return res;
}
exports.mapEntries = mapEntries;
exports.enumify = (x) => x;
function capitalizeWord(word) {
    return word.trim().replace(/^\w/, c => c.toUpperCase());
}
exports.capitalizeWord = capitalizeWord;
function capitalize(str) {
    return str
        .split(exports.EMPTY_SPACE)
        .map(w => capitalizeWord(w))
        .join(exports.EMPTY_SPACE);
}
exports.capitalize = capitalize;
function calcExpiry(ttl, now) {
    return time_1.fromMiliseconds((now || Date.now()) + time_1.toMiliseconds(ttl));
}
exports.calcExpiry = calcExpiry;
function isExpired(expiry) {
    return time_1.fromMiliseconds(Date.now()) >= time_1.toMiliseconds(expiry);
}
exports.isExpired = isExpired;
function createDelayedPromise() {
    const timeout = time_1.toMiliseconds(time_1.FIVE_MINUTES);
    let cacheResolve;
    let cacheReject;
    let cacheTimeout;
    const done = () => new Promise((promiseResolve, promiseReject) => {
        cacheTimeout = setTimeout(promiseReject, timeout);
        cacheResolve = promiseResolve;
        cacheReject = promiseReject;
    });
    const resolve = (value) => {
        if (cacheTimeout && cacheResolve) {
            clearTimeout(cacheTimeout);
            cacheResolve(value);
        }
    };
    const reject = (value) => {
        if (cacheTimeout && cacheReject) {
            clearTimeout(cacheTimeout);
            cacheReject(value);
        }
    };
    return {
        resolve,
        reject,
        done,
    };
}
exports.createDelayedPromise = createDelayedPromise;
function formatExpirerTarget(type, value) {
    if (type.toLowerCase() === "topic") {
        if (typeof value !== "string")
            throw new Error(`Value must be "string" for expirer target type: topic`);
        return `topic:${value}`;
    }
    else if (type.toLowerCase() === "id") {
        if (typeof value !== "number")
            throw new Error(`Value must be "number" for expirer target type: id`);
        return `id:${value}`;
    }
    throw new Error(`Unknown expirer target type: ${type}`);
}
exports.formatExpirerTarget = formatExpirerTarget;
function formatTopicTarget(topic) {
    return formatExpirerTarget("topic", topic);
}
exports.formatTopicTarget = formatTopicTarget;
function formatIdTarget(id) {
    return formatExpirerTarget("id", id);
}
exports.formatIdTarget = formatIdTarget;
function engineEvent(event, id) {
    return `${event}${id ? `:${id}` : ""}`;
}
exports.engineEvent = engineEvent;

}(misc$4));

var misc$2 = /*@__PURE__*/getDefaultExportFromCjs(misc$4);

var misc$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), misc$4, {
    'default': misc$2
}));

var require$$4$e = /*@__PURE__*/getAugmentedNamespace(misc$3);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERROR = exports.ERROR_TYPE = void 0;
const time_1 = require$$3$q;
const misc_1 = require$$4$e;
exports.ERROR_TYPE = misc_1.enumify({
    GENERIC: "GENERIC",
    MISSING_OR_INVALID: "MISSING_OR_INVALID",
    MISSING_RESPONSE: "MISSING_RESPONSE",
    MISSING_DECRYPT_PARAMS: "MISSING_DECRYPT_PARAMS",
    INVALID_UPDATE_REQUEST: "INVALID_UPDATE_REQUEST",
    INVALID_UPGRADE_REQUEST: "INVALID_UPGRADE_REQUEST",
    INVALID_EXTEND_REQUEST: "INVALID_EXTEND_REQUEST",
    INVALID_STORAGE_KEY_NAME: "INVALID_STORAGE_KEY_NAME",
    RECORD_ALREADY_EXISTS: "RECORD_ALREADY_EXISTS",
    RESTORE_WILL_OVERRIDE: "RESTORE_WILL_OVERRIDE",
    NO_MATCHING_ID: "NO_MATCHING_ID",
    NO_MATCHING_TOPIC: "NO_MATCHING_TOPIC",
    NO_MATCHING_RESPONSE: "NO_MATCHING_RESPONSE",
    NO_MATCHING_KEY: "NO_MATCHING_KEY",
    UNKNOWN_JSONRPC_METHOD: "UNKNOWN_JSONRPC_METHOD",
    MISMATCHED_TOPIC: "MISMATCHED_TOPIC",
    MISMATCHED_ACCOUNTS: "MISMATCHED_ACCOUNTS",
    SETTLED: "SETTLED",
    NOT_APPROVED: "NOT_APPROVED",
    PROPOSAL_RESPONDED: "PROPOSAL_RESPONDED",
    RESPONSE_ACKNOWLEDGED: "RESPONSE_ACKNOWLEDGED",
    EXPIRED: "EXPIRED",
    DELETED: "DELETED",
    RESUBSCRIBED: "RESUBSCRIBED",
    NOT_INITIALIZED: "NOT_INITIALIZED",
    SETTLE_TIMEOUT: "SETTLE_TIMEOUT",
    JSONRPC_REQUEST_TIMEOUT: "JSONRPC_REQUEST_TIMEOUT",
    UNAUTHORIZED_TARGET_CHAIN: "UNAUTHORIZED_TARGET_CHAIN",
    UNAUTHORIZED_JSON_RPC_METHOD: "UNAUTHORIZED_JSON_RPC_METHOD",
    UNAUTHORIZED_NOTIFICATION_TYPE: "UNAUTHORIZED_NOTIFICATION_TYPE",
    UNAUTHORIZED_UPDATE_REQUEST: "UNAUTHORIZED_UPDATE_REQUEST",
    UNAUTHORIZED_UPGRADE_REQUEST: "UNAUTHORIZED_UPGRADE_REQUEST",
    UNAUTHORIZED_EXTEND_REQUEST: "UNAUTHORIZED_EXTEND_REQUEST",
    UNAUTHORIZED_MATCHING_CONTROLLER: "UNAUTHORIZED_MATCHING_CONTROLLER",
    UNAUTHORIZED_METHOD: "UNAUTHORIZED_METHOD",
    JSONRPC_REQUEST_METHOD_REJECTED: "JSONRPC_REQUEST_METHOD_REJECTED",
    JSONRPC_REQUEST_METHOD_UNAUTHORIZED: "JSONRPC_REQUEST_METHOD_UNAUTHORIZED",
    JSONRPC_REQUEST_METHOD_UNSUPPORTED: "JSONRPC_REQUEST_METHOD_UNSUPPORTED",
    DISCONNECTED_ALL_CHAINS: "DISCONNECTED_ALL_CHAINS",
    DISCONNECTED_TARGET_CHAIN: "DISCONNECTED_TARGET_CHAIN",
    DISAPPROVED_CHAINS: "DISAPPROVED_CHAINS",
    DISAPPROVED_JSONRPC: "DISAPPROVED_JSONRPC",
    DISAPPROVED_NOTIFICATION: "DISAPPROVED_NOTIFICATION",
    UNSUPPORTED_CHAINS: "UNSUPPORTED_CHAINS",
    UNSUPPORTED_JSONRPC: "UNSUPPORTED_JSONRPC",
    UNSUPPORTED_NOTIFICATION: "UNSUPPORTED_NOTIFICATION",
    UNSUPPORTED_SIGNAL: "UNSUPPORTED_SIGNAL",
    USER_DISCONNECTED: "USER_DISCONNECTED",
    UNKNOWN: "UNKNOWN",
});
const defaultParams = {
    topic: "undefined",
    message: "Something went wrong",
    name: "parameter",
    context: "session",
    blockchain: "Ethereum",
};
exports.ERROR = {
    [exports.ERROR_TYPE.GENERIC]: {
        type: exports.ERROR_TYPE.GENERIC,
        code: 0,
        stringify: (params) => (params === null || params === void 0 ? void 0 : params.message) || defaultParams.message,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.GENERIC].code,
            message: exports.ERROR[exports.ERROR_TYPE.GENERIC].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.MISSING_OR_INVALID]: {
        type: exports.ERROR_TYPE.MISSING_OR_INVALID,
        code: 1000,
        stringify: (params) => `Missing or invalid ${(params === null || params === void 0 ? void 0 : params.name) || defaultParams.name}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.MISSING_OR_INVALID].code,
            message: exports.ERROR[exports.ERROR_TYPE.MISSING_OR_INVALID].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.MISSING_RESPONSE]: {
        type: exports.ERROR_TYPE.MISSING_RESPONSE,
        code: 1001,
        stringify: (params) => `Response is required for approved ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} proposals`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.MISSING_RESPONSE].code,
            message: exports.ERROR[exports.ERROR_TYPE.MISSING_RESPONSE].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.MISSING_DECRYPT_PARAMS]: {
        type: exports.ERROR_TYPE.MISSING_DECRYPT_PARAMS,
        code: 1002,
        stringify: (params) => `Decrypt params required for ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.MISSING_DECRYPT_PARAMS].code,
            message: exports.ERROR[exports.ERROR_TYPE.MISSING_DECRYPT_PARAMS].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.INVALID_UPDATE_REQUEST]: {
        type: exports.ERROR_TYPE.INVALID_UPDATE_REQUEST,
        code: 1003,
        stringify: (params) => `Invalid ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} update request`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.INVALID_UPDATE_REQUEST].code,
            message: exports.ERROR[exports.ERROR_TYPE.INVALID_UPDATE_REQUEST].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.INVALID_UPGRADE_REQUEST]: {
        type: exports.ERROR_TYPE.INVALID_UPGRADE_REQUEST,
        code: 1004,
        stringify: (params) => `Invalid ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} upgrade request`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.INVALID_UPGRADE_REQUEST].code,
            message: exports.ERROR[exports.ERROR_TYPE.INVALID_UPGRADE_REQUEST].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.INVALID_EXTEND_REQUEST]: {
        type: exports.ERROR_TYPE.INVALID_EXTEND_REQUEST,
        code: 1005,
        stringify: (params) => `Invalid ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} extend request`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.INVALID_EXTEND_REQUEST].code,
            message: exports.ERROR[exports.ERROR_TYPE.INVALID_EXTEND_REQUEST].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.INVALID_STORAGE_KEY_NAME]: {
        type: exports.ERROR_TYPE.INVALID_STORAGE_KEY_NAME,
        code: 1020,
        stringify: (params) => `Invalid storage key name: ${(params === null || params === void 0 ? void 0 : params.name) || defaultParams.name}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.INVALID_STORAGE_KEY_NAME].code,
            message: exports.ERROR[exports.ERROR_TYPE.INVALID_STORAGE_KEY_NAME].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.RECORD_ALREADY_EXISTS]: {
        type: exports.ERROR_TYPE.RECORD_ALREADY_EXISTS,
        code: 1100,
        stringify: (params) => `Record already exists for ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} matching id: ${params === null || params === void 0 ? void 0 : params.id}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.RECORD_ALREADY_EXISTS].code,
            message: exports.ERROR[exports.ERROR_TYPE.RECORD_ALREADY_EXISTS].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.RESTORE_WILL_OVERRIDE]: {
        type: exports.ERROR_TYPE.RESTORE_WILL_OVERRIDE,
        code: 1200,
        stringify: (params) => `Restore will override already set ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.RESTORE_WILL_OVERRIDE].code,
            message: exports.ERROR[exports.ERROR_TYPE.RESTORE_WILL_OVERRIDE].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.NO_MATCHING_ID]: {
        type: exports.ERROR_TYPE.NO_MATCHING_ID,
        code: 1300,
        stringify: (params) => `No matching ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} with id: ${params === null || params === void 0 ? void 0 : params.id}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.NO_MATCHING_ID].code,
            message: exports.ERROR[exports.ERROR_TYPE.NO_MATCHING_ID].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.NO_MATCHING_TOPIC]: {
        type: exports.ERROR_TYPE.NO_MATCHING_TOPIC,
        code: 1301,
        stringify: (params) => `No matching ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} with topic: ${params === null || params === void 0 ? void 0 : params.topic}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.NO_MATCHING_TOPIC].code,
            message: exports.ERROR[exports.ERROR_TYPE.NO_MATCHING_TOPIC].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.NO_MATCHING_RESPONSE]: {
        type: exports.ERROR_TYPE.NO_MATCHING_RESPONSE,
        code: 1302,
        stringify: (params) => `No response found in pending ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} proposal`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.NO_MATCHING_RESPONSE].code,
            message: exports.ERROR[exports.ERROR_TYPE.NO_MATCHING_RESPONSE].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.NO_MATCHING_KEY]: {
        type: exports.ERROR_TYPE.NO_MATCHING_KEY,
        code: 1303,
        stringify: (params) => `No matching key with tag: ${params === null || params === void 0 ? void 0 : params.tag}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.NO_MATCHING_KEY].code,
            message: exports.ERROR[exports.ERROR_TYPE.NO_MATCHING_KEY].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNKNOWN_JSONRPC_METHOD]: {
        type: exports.ERROR_TYPE.UNKNOWN_JSONRPC_METHOD,
        code: 1400,
        stringify: (params) => `Unknown JSON-RPC Method Requested: ${params === null || params === void 0 ? void 0 : params.method}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNKNOWN_JSONRPC_METHOD].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNKNOWN_JSONRPC_METHOD].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.MISMATCHED_TOPIC]: {
        type: exports.ERROR_TYPE.MISMATCHED_TOPIC,
        code: 1500,
        stringify: (params) => `Mismatched topic for ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} with id: ${params === null || params === void 0 ? void 0 : params.id}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.MISMATCHED_TOPIC].code,
            message: exports.ERROR[exports.ERROR_TYPE.MISMATCHED_TOPIC].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.MISMATCHED_ACCOUNTS]: {
        type: exports.ERROR_TYPE.MISMATCHED_ACCOUNTS,
        code: 1501,
        stringify: (params) => `Invalid accounts with mismatched chains: ${params === null || params === void 0 ? void 0 : params.mismatched.toString()}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.MISMATCHED_ACCOUNTS].code,
            message: exports.ERROR[exports.ERROR_TYPE.MISMATCHED_ACCOUNTS].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.SETTLED]: {
        type: exports.ERROR_TYPE.SETTLED,
        code: 1600,
        stringify: (params) => `${misc_1.capitalize((params === null || params === void 0 ? void 0 : params.context) || defaultParams.context)} settled`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.SETTLED].code,
            message: exports.ERROR[exports.ERROR_TYPE.SETTLED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.NOT_APPROVED]: {
        type: exports.ERROR_TYPE.NOT_APPROVED,
        code: 1601,
        stringify: (params) => `${misc_1.capitalize((params === null || params === void 0 ? void 0 : params.context) || defaultParams.context)} not approved`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.NOT_APPROVED].code,
            message: exports.ERROR[exports.ERROR_TYPE.NOT_APPROVED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.PROPOSAL_RESPONDED]: {
        type: exports.ERROR_TYPE.PROPOSAL_RESPONDED,
        code: 1602,
        stringify: (params) => `${misc_1.capitalize((params === null || params === void 0 ? void 0 : params.context) || defaultParams.context)} proposal responded`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.PROPOSAL_RESPONDED].code,
            message: exports.ERROR[exports.ERROR_TYPE.PROPOSAL_RESPONDED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.RESPONSE_ACKNOWLEDGED]: {
        type: exports.ERROR_TYPE.RESPONSE_ACKNOWLEDGED,
        code: 1603,
        stringify: (params) => `${misc_1.capitalize((params === null || params === void 0 ? void 0 : params.context) || defaultParams.context)} response acknowledge`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.RESPONSE_ACKNOWLEDGED].code,
            message: exports.ERROR[exports.ERROR_TYPE.RESPONSE_ACKNOWLEDGED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.EXPIRED]: {
        type: exports.ERROR_TYPE.EXPIRED,
        code: 1604,
        stringify: (params) => `${misc_1.capitalize((params === null || params === void 0 ? void 0 : params.context) || defaultParams.context)} expired`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.EXPIRED].code,
            message: exports.ERROR[exports.ERROR_TYPE.EXPIRED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.DELETED]: {
        type: exports.ERROR_TYPE.DELETED,
        code: 1605,
        stringify: (params) => `${misc_1.capitalize((params === null || params === void 0 ? void 0 : params.context) || defaultParams.context)} deleted`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.DELETED].code,
            message: exports.ERROR[exports.ERROR_TYPE.DELETED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.RESUBSCRIBED]: {
        type: exports.ERROR_TYPE.RESUBSCRIBED,
        code: 1606,
        stringify: (params) => `Subscription resubscribed with topic: ${params.topic || defaultParams.topic}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.RESUBSCRIBED].code,
            message: exports.ERROR[exports.ERROR_TYPE.RESUBSCRIBED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.NOT_INITIALIZED]: {
        type: exports.ERROR_TYPE.NOT_INITIALIZED,
        code: 1607,
        stringify: (params) => `${params ? `: ${params === null || params === void 0 ? void 0 : params.toString()}` : ""} was not initialized`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.NOT_INITIALIZED].code,
            message: exports.ERROR[exports.ERROR_TYPE.NOT_INITIALIZED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.SETTLE_TIMEOUT]: {
        type: exports.ERROR_TYPE.SETTLE_TIMEOUT,
        code: 2000,
        stringify: (params) => `${misc_1.capitalize((params === null || params === void 0 ? void 0 : params.context) || defaultParams.context)} failed to settle after ${time_1.fromMiliseconds(params === null || params === void 0 ? void 0 : params.timeout)} seconds`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.SETTLE_TIMEOUT].code,
            message: exports.ERROR[exports.ERROR_TYPE.SETTLE_TIMEOUT].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.JSONRPC_REQUEST_TIMEOUT]: {
        type: exports.ERROR_TYPE.JSONRPC_REQUEST_TIMEOUT,
        code: 2001,
        stringify: (params) => `JSON-RPC Request timeout after ${time_1.fromMiliseconds(params === null || params === void 0 ? void 0 : params.timeout)} seconds: ${params === null || params === void 0 ? void 0 : params.method}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.JSONRPC_REQUEST_TIMEOUT].code,
            message: exports.ERROR[exports.ERROR_TYPE.JSONRPC_REQUEST_TIMEOUT].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNAUTHORIZED_TARGET_CHAIN]: {
        type: exports.ERROR_TYPE.UNAUTHORIZED_TARGET_CHAIN,
        code: 3000,
        stringify: (params) => `Unauthorized Target ChainId Requested: ${params === null || params === void 0 ? void 0 : params.chainId}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_TARGET_CHAIN].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_TARGET_CHAIN].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNAUTHORIZED_JSON_RPC_METHOD]: {
        type: exports.ERROR_TYPE.UNAUTHORIZED_JSON_RPC_METHOD,
        code: 3001,
        stringify: (params) => `Unauthorized JSON-RPC Method Requested: ${params === null || params === void 0 ? void 0 : params.method}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_JSON_RPC_METHOD].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_JSON_RPC_METHOD].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNAUTHORIZED_NOTIFICATION_TYPE]: {
        type: exports.ERROR_TYPE.UNAUTHORIZED_NOTIFICATION_TYPE,
        code: 3002,
        stringify: (params) => `Unauthorized Notification Type Requested: ${params === null || params === void 0 ? void 0 : params.type}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_NOTIFICATION_TYPE].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_NOTIFICATION_TYPE].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNAUTHORIZED_UPDATE_REQUEST]: {
        type: exports.ERROR_TYPE.UNAUTHORIZED_UPDATE_REQUEST,
        code: 3003,
        stringify: (params) => `Unauthorized ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} update request`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_UPDATE_REQUEST].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_UPDATE_REQUEST].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNAUTHORIZED_UPGRADE_REQUEST]: {
        type: exports.ERROR_TYPE.UNAUTHORIZED_UPGRADE_REQUEST,
        code: 3004,
        stringify: (params) => `Unauthorized ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} upgrade request`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_UPGRADE_REQUEST].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_UPGRADE_REQUEST].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNAUTHORIZED_EXTEND_REQUEST]: {
        type: exports.ERROR_TYPE.UNAUTHORIZED_EXTEND_REQUEST,
        code: 3005,
        stringify: (params) => `Unauthorized ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} extend request`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_EXTEND_REQUEST].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_EXTEND_REQUEST].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNAUTHORIZED_MATCHING_CONTROLLER]: {
        type: exports.ERROR_TYPE.UNAUTHORIZED_MATCHING_CONTROLLER,
        code: 3100,
        stringify: (params) => { var _a, _b; return `Unauthorized: method ${(_b = (_a = params === null || params === void 0 ? void 0 : params.request) === null || _a === void 0 ? void 0 : _a.method) !== null && _b !== void 0 ? _b : "unknown"} not allowed`; },
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_MATCHING_CONTROLLER].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_MATCHING_CONTROLLER].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNAUTHORIZED_METHOD]: {
        type: exports.ERROR_TYPE.UNAUTHORIZED_METHOD,
        code: 3100,
        stringify: (params) => `Unauthorized: peer is also ${(params === null || params === void 0 ? void 0 : params.controller) ? "" : "not "}controller`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_METHOD].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNAUTHORIZED_METHOD].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_REJECTED]: {
        type: exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_REJECTED,
        code: 4001,
        stringify: () => "User rejected the request.",
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_REJECTED].code,
            message: exports.ERROR[exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_REJECTED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_UNAUTHORIZED]: {
        type: exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_UNAUTHORIZED,
        code: 4100,
        stringify: () => "The requested account and/or method has not been authorized by the user.",
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_UNAUTHORIZED].code,
            message: exports.ERROR[exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_UNAUTHORIZED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_UNSUPPORTED]: {
        type: exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_UNSUPPORTED,
        code: 4200,
        stringify: (params) => `The requested method is not supported by this ${(params === null || params === void 0 ? void 0 : params.blockhain) ||
            defaultParams.blockchain} provider.`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_UNSUPPORTED].code,
            message: exports.ERROR[exports.ERROR_TYPE.JSONRPC_REQUEST_METHOD_UNSUPPORTED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.DISCONNECTED_ALL_CHAINS]: {
        type: exports.ERROR_TYPE.DISCONNECTED_ALL_CHAINS,
        code: 4900,
        stringify: () => "The provider is disconnected from all chains.",
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.DISCONNECTED_ALL_CHAINS].code,
            message: exports.ERROR[exports.ERROR_TYPE.DISCONNECTED_ALL_CHAINS].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.DISCONNECTED_TARGET_CHAIN]: {
        type: exports.ERROR_TYPE.DISCONNECTED_TARGET_CHAIN,
        code: 4901,
        stringify: () => "The provider is disconnected from the specified chain.",
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.DISCONNECTED_TARGET_CHAIN].code,
            message: exports.ERROR[exports.ERROR_TYPE.DISCONNECTED_TARGET_CHAIN].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.DISAPPROVED_CHAINS]: {
        type: exports.ERROR_TYPE.DISAPPROVED_CHAINS,
        code: 5000,
        stringify: () => `User disapproved requested chains`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.DISAPPROVED_CHAINS].code,
            message: exports.ERROR[exports.ERROR_TYPE.DISAPPROVED_CHAINS].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.DISAPPROVED_JSONRPC]: {
        type: exports.ERROR_TYPE.DISAPPROVED_JSONRPC,
        code: 5001,
        stringify: () => `User disapproved requested json-rpc methods`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.DISAPPROVED_JSONRPC].code,
            message: exports.ERROR[exports.ERROR_TYPE.DISAPPROVED_JSONRPC].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.DISAPPROVED_NOTIFICATION]: {
        type: exports.ERROR_TYPE.DISAPPROVED_NOTIFICATION,
        code: 5002,
        stringify: () => `User disapproved requested notification types`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.DISAPPROVED_NOTIFICATION].code,
            message: exports.ERROR[exports.ERROR_TYPE.DISAPPROVED_NOTIFICATION].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNSUPPORTED_CHAINS]: {
        type: exports.ERROR_TYPE.UNSUPPORTED_CHAINS,
        code: 5100,
        stringify: (params) => `Requested chains are not supported: ${params === null || params === void 0 ? void 0 : params.chains.toString()}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNSUPPORTED_CHAINS].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNSUPPORTED_CHAINS].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNSUPPORTED_JSONRPC]: {
        type: exports.ERROR_TYPE.UNSUPPORTED_JSONRPC,
        code: 5101,
        stringify: (params) => `Requested json-rpc methods are not supported: ${params === null || params === void 0 ? void 0 : params.methods.toString()}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNSUPPORTED_JSONRPC].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNSUPPORTED_JSONRPC].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNSUPPORTED_NOTIFICATION]: {
        type: exports.ERROR_TYPE.UNSUPPORTED_NOTIFICATION,
        code: 5102,
        stringify: (params) => `Requested notification types are not supported: ${params === null || params === void 0 ? void 0 : params.types.toString()}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNSUPPORTED_NOTIFICATION].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNSUPPORTED_NOTIFICATION].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNSUPPORTED_SIGNAL]: {
        type: exports.ERROR_TYPE.UNSUPPORTED_SIGNAL,
        code: 5103,
        stringify: (params) => `Proposed ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context} signal is unsupported`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNSUPPORTED_SIGNAL].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNSUPPORTED_SIGNAL].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.USER_DISCONNECTED]: {
        type: exports.ERROR_TYPE.USER_DISCONNECTED,
        code: 5900,
        stringify: (params) => `User disconnected ${(params === null || params === void 0 ? void 0 : params.context) || defaultParams.context}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.USER_DISCONNECTED].code,
            message: exports.ERROR[exports.ERROR_TYPE.USER_DISCONNECTED].stringify(params),
        }),
    },
    [exports.ERROR_TYPE.UNKNOWN]: {
        type: exports.ERROR_TYPE.UNKNOWN,
        code: 9000,
        stringify: (params) => `Unknown error${params ? `: ${params === null || params === void 0 ? void 0 : params.toString()}` : ""}`,
        format: (params) => ({
            code: exports.ERROR[exports.ERROR_TYPE.UNKNOWN].code,
            message: exports.ERROR[exports.ERROR_TYPE.UNKNOWN].stringify(params),
        }),
    },
};

}(error$2));

var error = /*@__PURE__*/getDefaultExportFromCjs(error$2);

var error$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), error$2, {
    'default': error
}));

var require$$3$i = /*@__PURE__*/getAugmentedNamespace(error$1);

var relay$2 = {};

function assertType(obj, key, type = "string") {
    if (!obj[key] || typeof obj[key] !== type) {
        throw new Error(`Missing or invalid "${key}" param`);
    }
}
function hasRequiredParams(params, required) {
    let matches = true;
    required.forEach(key => {
        const exists = key in params;
        if (!exists) {
            matches = false;
        }
    });
    return matches;
}
function hasExactParamsLength(params, length) {
    return Array.isArray(params)
        ? params.length === length
        : Object.keys(params).length === length;
}
function hasRequiredParamsLength(params, minLength) {
    return Array.isArray(params)
        ? params.length >= minLength
        : Object.keys(params).length >= minLength;
}
function checkParams$1(params, required, optional) {
    const exact = !optional.length;
    const matchesLength = exact
        ? hasExactParamsLength(params, required.length)
        : hasRequiredParamsLength(params, required.length);
    if (!matchesLength)
        return false;
    return hasRequiredParams(params, required);
}
function methodEndsWith(method, expected, separator = "_") {
    const split = method.split(separator);
    return (split[split.length - 1].trim().toLowerCase() ===
        expected.trim().toLowerCase());
}

function isSubscribeRequest(request) {
    return isSubscribeMethod(request.method) && isSubscribeParams(request.params);
}
function isSubscribeMethod(method) {
    return methodEndsWith(method, "subscribe");
}
function isSubscribeParams(params) {
    const required = ["topic"];
    const optional = [];
    return checkParams$1(params, required, optional);
}
function isPublishRequest(request) {
    return isPublishMethod(request.method) && isPublishParams(request.params);
}
function isPublishMethod(method) {
    return methodEndsWith(method, "publish");
}
function isPublishParams(params) {
    const required = ["message", "topic", "ttl"];
    const optional = ["prompt", "tag"];
    return checkParams$1(params, required, optional);
}
function isUnsubscribeRequest(request) {
    return (isUnsubscribeMethod(request.method) && isUnsubscribeParams(request.params));
}
function isUnsubscribeMethod(method) {
    return methodEndsWith(method, "unsubscribe");
}
function isUnsubscribeParams(params) {
    const required = ["id", "topic"];
    const optional = [];
    return checkParams$1(params, required, optional);
}
function isSubscriptionRequest(request) {
    return (isSubscriptionMethod(request.method) && isSubscriptionParams(request.params));
}
function isSubscriptionMethod(method) {
    return methodEndsWith(method, "subscription");
}
function isSubscriptionParams(params) {
    const required = ["id", "data"];
    const optional = [];
    return checkParams$1(params, required, optional);
}

function parseSubscribeRequest(request) {
    if (!isSubscribeMethod(request.method)) {
        throw new Error("JSON-RPC Request has invalid subscribe method");
    }
    if (!isSubscribeParams(request.params)) {
        throw new Error("JSON-RPC Request has invalid subscribe params");
    }
    const params = request.params;
    assertType(params, "topic");
    return params;
}
function parsePublishRequest(request) {
    if (!isPublishMethod(request.method)) {
        throw new Error("JSON-RPC Request has invalid publish method");
    }
    if (!isPublishParams(request.params)) {
        throw new Error("JSON-RPC Request has invalid publish params");
    }
    const params = request.params;
    assertType(params, "topic");
    assertType(params, "message");
    assertType(params, "ttl", "number");
    return params;
}
function parseUnsubscribeRequest(request) {
    if (!isUnsubscribeMethod(request.method)) {
        throw new Error("JSON-RPC Request has invalid unsubscribe method");
    }
    if (!isUnsubscribeParams(request.params)) {
        throw new Error("JSON-RPC Request has invalid unsubscribe params");
    }
    const params = request.params;
    assertType(params, "id");
    return params;
}
function parseSubscriptionRequest(request) {
    if (!isSubscriptionMethod(request.method)) {
        throw new Error("JSON-RPC Request has invalid subscription method");
    }
    if (!isSubscriptionParams(request.params)) {
        throw new Error("JSON-RPC Request has invalid subscription params");
    }
    const params = request.params;
    assertType(params, "id");
    assertType(params, "data");
    return params;
}

const RELAY_JSONRPC = {
    waku: {
        publish: "waku_publish",
        subscribe: "waku_subscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
    },
    irn: {
        publish: "irn_publish",
        subscribe: "irn_subscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
    },
    iridium: {
        publish: "iridium_publish",
        subscribe: "iridium_subscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
    },
};

var esm$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    parseSubscribeRequest: parseSubscribeRequest,
    parsePublishRequest: parsePublishRequest,
    parseUnsubscribeRequest: parseUnsubscribeRequest,
    parseSubscriptionRequest: parseSubscriptionRequest,
    RELAY_JSONRPC: RELAY_JSONRPC,
    isSubscribeRequest: isSubscribeRequest,
    isSubscribeMethod: isSubscribeMethod,
    isSubscribeParams: isSubscribeParams,
    isPublishRequest: isPublishRequest,
    isPublishMethod: isPublishMethod,
    isPublishParams: isPublishParams,
    isUnsubscribeRequest: isUnsubscribeRequest,
    isUnsubscribeMethod: isUnsubscribeMethod,
    isUnsubscribeParams: isUnsubscribeParams,
    isSubscriptionRequest: isSubscriptionRequest,
    isSubscriptionMethod: isSubscriptionMethod,
    isSubscriptionParams: isSubscriptionParams
});

var require$$0$d = /*@__PURE__*/getAugmentedNamespace(esm$5);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelayProtocolApi = exports.getRelayProtocolName = exports.RELAYER_DEFAULT_PROTOCOL = void 0;
const relay_api_1 = require$$0$d;
exports.RELAYER_DEFAULT_PROTOCOL = "waku";
function getRelayProtocolName(opts) {
    return (opts === null || opts === void 0 ? void 0 : opts.relay) || { protocol: exports.RELAYER_DEFAULT_PROTOCOL };
}
exports.getRelayProtocolName = getRelayProtocolName;
function getRelayProtocolApi(protocol) {
    const jsonrpc = relay_api_1.RELAY_JSONRPC[protocol];
    if (typeof jsonrpc === "undefined") {
        throw new Error(`Relay Protocol not supported: ${protocol}`);
    }
    return jsonrpc;
}
exports.getRelayProtocolApi = getRelayProtocolApi;

}(relay$2));

var relay = /*@__PURE__*/getDefaultExportFromCjs(relay$2);

var relay$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), relay$2, {
    'default': relay
}));

var require$$5$c = /*@__PURE__*/getAugmentedNamespace(relay$1);

var uri$1 = {};

Object.defineProperty(uri$1, "__esModule", { value: true });
var formatUri_1 = uri$1.formatUri = formatRelayParams_1 = uri$1.formatRelayParams = parseUri_1 = uri$1.parseUri = parseRelayParams_1 = uri$1.parseRelayParams = void 0;
const tslib_1$k = require$$0$G;
const qs = tslib_1$k.__importStar(require$$1$s);
function parseRelayParams(params, delimiter = "-") {
    const relay = {};
    const prefix = "relay" + delimiter;
    Object.keys(params).forEach(key => {
        if (key.startsWith(prefix)) {
            const name = key.replace(prefix, "");
            const value = params[key];
            relay[name] = value;
        }
    });
    return relay;
}
var parseRelayParams_1 = uri$1.parseRelayParams = parseRelayParams;
function parseUri(str) {
    const pathStart = str.indexOf(":");
    const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : undefined;
    const protocol = str.substring(0, pathStart);
    const path = str.substring(pathStart + 1, pathEnd);
    const requiredValues = path.split("@");
    const queryString = typeof pathEnd !== "undefined" ? str.substring(pathEnd) : "";
    const queryParams = qs.parse(queryString);
    const result = {
        protocol,
        topic: requiredValues[0],
        version: parseInt(requiredValues[1], 10),
        symKey: queryParams.symKey,
        relay: parseRelayParams(queryParams),
    };
    return result;
}
var parseUri_1 = uri$1.parseUri = parseUri;
function formatRelayParams(relay, delimiter = "-") {
    const prefix = "relay";
    const params = {};
    Object.keys(relay).forEach(key => {
        const k = prefix + delimiter + key;
        if (relay[key]) {
            params[k] = relay[key];
        }
    });
    return params;
}
var formatRelayParams_1 = uri$1.formatRelayParams = formatRelayParams;
function formatUri(params) {
    return (`${params.protocol}:${params.topic}@${params.version}?` +
        qs.stringify(Object.assign({ symKey: params.symKey }, formatRelayParams(params.relay))));
}
formatUri_1 = uri$1.formatUri = formatUri;

var uri = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), uri$1, {
    get formatUri () { return formatUri_1; },
    get formatRelayParams () { return formatRelayParams_1; },
    get parseUri () { return parseUri_1; },
    get parseRelayParams () { return parseRelayParams_1; },
    'default': uri$1
}));

var require$$6$9 = /*@__PURE__*/getAugmentedNamespace(uri);

var validators$3 = {};

var namespaces$1 = {};

Object.defineProperty(namespaces$1, "__esModule", { value: true });
var getNamespacesEventsForChainId_1 = namespaces$1.getNamespacesEventsForChainId = getNamespacesMethodsForChainId_1 = namespaces$1.getNamespacesMethodsForChainId = getNamespacesChains_1 = namespaces$1.getNamespacesChains = getAccountsChains_1 = namespaces$1.getAccountsChains = void 0;
function getAccountsChains(accounts) {
    const chains = [];
    accounts.forEach(account => {
        const [chain, chainId] = account.split(":");
        chains.push(`${chain}:${chainId}`);
    });
    return chains;
}
var getAccountsChains_1 = namespaces$1.getAccountsChains = getAccountsChains;
function getNamespacesChains(namespaces) {
    const chains = [];
    Object.values(namespaces).forEach(namespace => {
        chains.push(...getAccountsChains(namespace.accounts));
        if (namespace.extension) {
            namespace.extension.forEach(extension => {
                chains.push(...getAccountsChains(extension.accounts));
            });
        }
    });
    return chains;
}
var getNamespacesChains_1 = namespaces$1.getNamespacesChains = getNamespacesChains;
function getNamespacesMethodsForChainId(namespaces, chainId) {
    const methods = [];
    Object.values(namespaces).forEach(namespace => {
        const chains = getAccountsChains(namespace.accounts);
        if (chains.includes(chainId))
            methods.push(...namespace.methods);
        if (namespace.extension) {
            namespace.extension.forEach(extension => {
                const extensionChains = getAccountsChains(extension.accounts);
                if (extensionChains.includes(chainId))
                    methods.push(...extension.methods);
            });
        }
    });
    return methods;
}
var getNamespacesMethodsForChainId_1 = namespaces$1.getNamespacesMethodsForChainId = getNamespacesMethodsForChainId;
function getNamespacesEventsForChainId(namespaces, chainId) {
    const events = [];
    Object.values(namespaces).forEach(namespace => {
        const chains = getAccountsChains(namespace.accounts);
        if (chains.includes(chainId))
            events.push(...namespace.events);
        if (namespace.extension) {
            namespace.extension.forEach(extension => {
                const extensionChains = getAccountsChains(extension.accounts);
                if (extensionChains.includes(chainId))
                    events.push(...extension.events);
            });
        }
    });
    return events;
}
getNamespacesEventsForChainId_1 = namespaces$1.getNamespacesEventsForChainId = getNamespacesEventsForChainId;

var namespaces = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), namespaces$1, {
    get getNamespacesEventsForChainId () { return getNamespacesEventsForChainId_1; },
    get getNamespacesMethodsForChainId () { return getNamespacesMethodsForChainId_1; },
    get getNamespacesChains () { return getNamespacesChains_1; },
    get getAccountsChains () { return getAccountsChains_1; },
    'default': namespaces$1
}));

var require$$8$5 = /*@__PURE__*/getAugmentedNamespace(namespaces);

Object.defineProperty(validators$3, "__esModule", { value: true });
var isValidNamespacesEvent_1 = validators$3.isValidNamespacesEvent = isValidNamespacesRequest_1 = validators$3.isValidNamespacesRequest = isValidNamespacesChainId_1 = validators$3.isValidNamespacesChainId = isValidEvent_1 = validators$3.isValidEvent = isValidResponse_1 = validators$3.isValidResponse = isValidRequest_1 = validators$3.isValidRequest = isValidErrorReason_1 = validators$3.isValidErrorReason = isValidAccounts_1 = validators$3.isValidAccounts = isValidParams_1 = validators$3.isValidParams = isValidId_1 = validators$3.isValidId = isValidRelays_1 = validators$3.isValidRelays = isValidRelay_1 = validators$3.isValidRelay = isValidNamespaces_1 = validators$3.isValidNamespaces = isValidNamespaceBody_1 = validators$3.isValidNamespaceBody = isValidRequiredNamespaces_1 = validators$3.isValidRequiredNamespaces = isValidRequiredNamespaceBody_1 = validators$3.isValidRequiredNamespaceBody = isSessionStruct_1 = validators$3.isSessionStruct = isProposalStruct_1 = validators$3.isProposalStruct = isValidUrl_1 = validators$3.isValidUrl = isValidAccountId_1 = validators$3.isValidAccountId = isValidChainId_1 = validators$3.isValidChainId = isValidNumber_1 = validators$3.isValidNumber = isValidString_1 = validators$3.isValidString = isUndefined_1 = validators$3.isUndefined = isValidObject_1 = validators$3.isValidObject = isValidArray_1 = validators$3.isValidArray = isSessionCompatible_1 = validators$3.isSessionCompatible = void 0;
const namespaces_1 = require$$8$5;
const misc_1 = require$$4$e;
function isSessionCompatible(session, params) {
    const { requiredNamespaces } = params;
    const sessionKeys = Object.keys(session.namespaces);
    const paramsKeys = Object.keys(requiredNamespaces);
    let compatible = true;
    if (!misc_1.hasOverlap(paramsKeys, sessionKeys))
        return false;
    sessionKeys.forEach(key => {
        const { accounts, methods, events, extension } = session.namespaces[key];
        const chains = namespaces_1.getAccountsChains(accounts);
        const requiredNamespace = requiredNamespaces[key];
        if (!misc_1.hasOverlap(requiredNamespace.chains, chains) ||
            !misc_1.hasOverlap(requiredNamespace.methods, methods) ||
            !misc_1.hasOverlap(requiredNamespace.events, events)) {
            compatible = false;
        }
        if (compatible && extension) {
            extension.forEach(extensionNamespace => {
                var _a;
                const { accounts, methods, events } = extensionNamespace;
                const chains = namespaces_1.getAccountsChains(accounts);
                const overlap = (_a = requiredNamespace.extension) === null || _a === void 0 ? void 0 : _a.find(ext => misc_1.hasOverlap(ext.chains, chains) &&
                    misc_1.hasOverlap(ext.methods, methods) &&
                    misc_1.hasOverlap(ext.events, events));
                if (!overlap)
                    compatible = false;
            });
        }
    });
    return compatible;
}
var isSessionCompatible_1 = validators$3.isSessionCompatible = isSessionCompatible;
function isValidArray(arr, itemCondition) {
    if (Array.isArray(arr)) {
        if (typeof itemCondition !== "undefined" && arr.length) {
            const matches = arr.filter(itemCondition);
            return matches.length === arr.length;
        }
        else {
            return true;
        }
    }
    return false;
}
var isValidArray_1 = validators$3.isValidArray = isValidArray;
function isValidObject(obj) {
    return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;
}
var isValidObject_1 = validators$3.isValidObject = isValidObject;
function isUndefined$1(input) {
    return typeof input === "undefined";
}
var isUndefined_1 = validators$3.isUndefined = isUndefined$1;
function isValidString(input, optional) {
    if (optional && isUndefined$1(input))
        return true;
    return typeof input === "string" && Boolean(input.trim().length);
}
var isValidString_1 = validators$3.isValidString = isValidString;
function isValidNumber(input, optional) {
    if (optional && isUndefined$1(input))
        return true;
    return typeof input === "number";
}
var isValidNumber_1 = validators$3.isValidNumber = isValidNumber;
function isValidChainId(value, optional) {
    if (typeof value === "undefined" && optional)
        return true;
    if (isValidString(value, false) && value.includes(":")) {
        const split = value.split(":");
        return split.length === 2;
    }
    return false;
}
var isValidChainId_1 = validators$3.isValidChainId = isValidChainId;
function isValidAccountId(value) {
    if (isValidString(value, false) && value.includes(":")) {
        const split = value.split(":");
        if (split.length === 3) {
            const chainId = split[0] + ":" + split[1];
            return !!split[2] && isValidChainId(chainId, false);
        }
    }
    return false;
}
var isValidAccountId_1 = validators$3.isValidAccountId = isValidAccountId;
function isValidUrl(value) {
    if (isValidString(value, false)) {
        try {
            const url = new URL(value);
            return typeof url !== "undefined";
        }
        catch (e) {
            return false;
        }
    }
    return false;
}
var isValidUrl_1 = validators$3.isValidUrl = isValidUrl;
function isProposalStruct(input) {
    var _a;
    return (_a = input === null || input === void 0 ? void 0 : input.proposer) === null || _a === void 0 ? void 0 : _a.publicKey;
}
var isProposalStruct_1 = validators$3.isProposalStruct = isProposalStruct;
function isSessionStruct(input) {
    return input === null || input === void 0 ? void 0 : input.topic;
}
var isSessionStruct_1 = validators$3.isSessionStruct = isSessionStruct;
function isValidRequiredNamespaceBody(input) {
    const { methods, events, chains } = input;
    let validChains = true;
    const validRequiredNamespace = isValidArray(methods) && isValidArray(events) && isValidArray(chains);
    if (validRequiredNamespace) {
        chains.forEach((chain) => {
            if (!isValidChainId(chain, false))
                validChains = false;
        });
    }
    return validRequiredNamespace && validChains;
}
var isValidRequiredNamespaceBody_1 = validators$3.isValidRequiredNamespaceBody = isValidRequiredNamespaceBody;
function isValidRequiredNamespaces(input, optional) {
    let valid = false;
    if (optional && !input)
        return true;
    else if (input && isValidObject(input)) {
        valid = true;
        Object.values(input).forEach((namespace) => {
            if (!isValidRequiredNamespaceBody(namespace))
                valid = false;
            if (valid && (namespace === null || namespace === void 0 ? void 0 : namespace.extension)) {
                if (!isValidArray(namespace.extension))
                    valid = false;
                namespace.extension.forEach((extension) => {
                    if (!isValidRequiredNamespaceBody(extension))
                        valid = false;
                });
            }
        });
    }
    return valid;
}
var isValidRequiredNamespaces_1 = validators$3.isValidRequiredNamespaces = isValidRequiredNamespaces;
function isValidNamespaceBody(input) {
    const { methods, events, accounts } = input;
    let validAccounts = true;
    const validNamespace = isValidArray(methods) && isValidArray(events) && isValidArray(accounts);
    if (validNamespace) {
        accounts.forEach((account) => {
            if (!isValidAccountId(account))
                validAccounts = false;
        });
    }
    return validNamespace && validAccounts;
}
var isValidNamespaceBody_1 = validators$3.isValidNamespaceBody = isValidNamespaceBody;
function isValidNamespaces(input, optional) {
    let valid = false;
    if (optional && !input)
        return true;
    else if (input && isValidObject(input)) {
        valid = true;
        Object.values(input).forEach((namespace) => {
            if (!isValidNamespaceBody(namespace))
                valid = false;
            if (valid && (namespace === null || namespace === void 0 ? void 0 : namespace.extension)) {
                if (!isValidArray(namespace.extension))
                    valid = false;
                namespace.extension.forEach((extension) => {
                    if (!isValidNamespaceBody(extension))
                        valid = false;
                });
            }
        });
    }
    return valid;
}
var isValidNamespaces_1 = validators$3.isValidNamespaces = isValidNamespaces;
function isValidRelay(input) {
    return isValidString(input.protocol, true);
}
var isValidRelay_1 = validators$3.isValidRelay = isValidRelay;
function isValidRelays(input, optional) {
    let valid = false;
    if (optional && !input)
        valid = true;
    else if (input && isValidArray(input) && input.length) {
        input.forEach((relay) => {
            valid = isValidRelay(relay);
        });
    }
    return valid;
}
var isValidRelays_1 = validators$3.isValidRelays = isValidRelays;
function isValidId(input) {
    return typeof input === "number";
}
var isValidId_1 = validators$3.isValidId = isValidId;
function isValidParams(input) {
    return typeof input !== "undefined" && typeof input !== null;
}
var isValidParams_1 = validators$3.isValidParams = isValidParams;
function isValidAccounts(input, optional) {
    let valid = false;
    if (optional && !input)
        valid = true;
    else if (input && isValidArray(input) && input.length) {
        input.forEach((account) => {
            valid = isValidAccountId(account);
        });
    }
    return valid;
}
var isValidAccounts_1 = validators$3.isValidAccounts = isValidAccounts;
function isValidErrorReason(input) {
    if (!input)
        return false;
    if (typeof input !== "object")
        return false;
    if (!input.code || !isValidNumber(input.code, false))
        return false;
    if (!input.message || !isValidString(input.message, false))
        return false;
    return true;
}
var isValidErrorReason_1 = validators$3.isValidErrorReason = isValidErrorReason;
function isValidRequest(request) {
    if (isUndefined$1(request))
        return false;
    if (!isValidString(request.method, false))
        return false;
    return true;
}
var isValidRequest_1 = validators$3.isValidRequest = isValidRequest;
function isValidResponse(response) {
    if (isUndefined$1(response))
        return false;
    if (isUndefined$1(response.result) && isUndefined$1(response.error))
        return false;
    if (!isValidNumber(response.id, false))
        return false;
    if (!isValidString(response.jsonrpc, false))
        return false;
    return true;
}
var isValidResponse_1 = validators$3.isValidResponse = isValidResponse;
function isValidEvent(event) {
    if (isUndefined$1(event))
        return false;
    if (!isValidString(event.name, false))
        return false;
    return true;
}
var isValidEvent_1 = validators$3.isValidEvent = isValidEvent;
function isValidNamespacesChainId(namespaces, chainId) {
    if (!isValidChainId(chainId, false))
        return false;
    const chains = namespaces_1.getNamespacesChains(namespaces);
    if (!chains.includes(chainId))
        return false;
    return true;
}
var isValidNamespacesChainId_1 = validators$3.isValidNamespacesChainId = isValidNamespacesChainId;
function isValidNamespacesRequest(namespaces, chainId, method) {
    if (!isValidString(method, false))
        return false;
    const methods = namespaces_1.getNamespacesMethodsForChainId(namespaces, chainId);
    return methods.includes(method);
}
var isValidNamespacesRequest_1 = validators$3.isValidNamespacesRequest = isValidNamespacesRequest;
function isValidNamespacesEvent(namespaces, chainId, eventName) {
    if (!isValidString(eventName, false))
        return false;
    const events = namespaces_1.getNamespacesEventsForChainId(namespaces, chainId);
    return events.includes(eventName);
}
isValidNamespacesEvent_1 = validators$3.isValidNamespacesEvent = isValidNamespacesEvent;

var validators$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), validators$3, {
    get isValidNamespacesEvent () { return isValidNamespacesEvent_1; },
    get isValidNamespacesRequest () { return isValidNamespacesRequest_1; },
    get isValidNamespacesChainId () { return isValidNamespacesChainId_1; },
    get isValidEvent () { return isValidEvent_1; },
    get isValidResponse () { return isValidResponse_1; },
    get isValidRequest () { return isValidRequest_1; },
    get isValidErrorReason () { return isValidErrorReason_1; },
    get isValidAccounts () { return isValidAccounts_1; },
    get isValidParams () { return isValidParams_1; },
    get isValidId () { return isValidId_1; },
    get isValidRelays () { return isValidRelays_1; },
    get isValidRelay () { return isValidRelay_1; },
    get isValidNamespaces () { return isValidNamespaces_1; },
    get isValidNamespaceBody () { return isValidNamespaceBody_1; },
    get isValidRequiredNamespaces () { return isValidRequiredNamespaces_1; },
    get isValidRequiredNamespaceBody () { return isValidRequiredNamespaceBody_1; },
    get isSessionStruct () { return isSessionStruct_1; },
    get isProposalStruct () { return isProposalStruct_1; },
    get isValidUrl () { return isValidUrl_1; },
    get isValidAccountId () { return isValidAccountId_1; },
    get isValidChainId () { return isValidChainId_1; },
    get isValidNumber () { return isValidNumber_1; },
    get isValidString () { return isValidString_1; },
    get isUndefined () { return isUndefined_1; },
    get isValidObject () { return isValidObject_1; },
    get isValidArray () { return isValidArray_1; },
    get isSessionCompatible () { return isSessionCompatible_1; },
    'default': validators$3
}));

var require$$7$7 = /*@__PURE__*/getAugmentedNamespace(validators$2);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$E, exports);
tslib_1.__exportStar(require$$2$m, exports);
tslib_1.__exportStar(require$$3$i, exports);
tslib_1.__exportStar(require$$4$e, exports);
tslib_1.__exportStar(require$$5$c, exports);
tslib_1.__exportStar(require$$6$9, exports);
tslib_1.__exportStar(require$$7$7, exports);
tslib_1.__exportStar(require$$8$5, exports);

}(cjs$c));

var index$9 = /*@__PURE__*/getDefaultExportFromCjs(cjs$c);

var cjs$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$c, {
    'default': index$9
}));

var require$$4$d = /*@__PURE__*/getAugmentedNamespace(cjs$7);

var controllers$3 = {};

var crypto$7 = {};

var isTypedarray      = isTypedArray$3;
isTypedArray$3.strict = isStrictTypedArray;
isTypedArray$3.loose  = isLooseTypedArray;

var toString$4 = Object.prototype.toString;
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
};

function isTypedArray$3(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString$4.call(arr)]
}

var isTypedarray$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), isTypedarray, {
    'default': isTypedarray
}));

var require$$0$c = /*@__PURE__*/getAugmentedNamespace(isTypedarray$1);

var isTypedArray$2 = require$$0$c.strict;

var typedarrayToBuffer = function typedarrayToBuffer (arr) {
  if (isTypedArray$2(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer$1.from(arr.buffer);
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer$1.from(arr)
  }
};

const ENC_HEX = "hex";
const ENC_UTF8 = "utf8";
const ENC_BIN = "binary";
const TYPE_BUFFER = "buffer";
const TYPE_ARRAY = "array";
const TYPE_TYPED_ARRAY = "typed-array";
const TYPE_ARRAY_BUFFER = "array-buffer";
const STRING_ZERO = "0";
function bufferToArray(buf) {
    return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
    const hex = buf.toString(ENC_HEX);
    return prefixed ? addHexPrefix$1(hex) : hex;
}
function bufferToUtf8(buf) {
    return buf.toString(ENC_UTF8);
}
function bufferToNumber(buf) {
    return buf.readUIntBE(0, buf.length);
}
function bufferToBinary(buf) {
    return arrayToBinary(bufferToArray(buf));
}
function arrayToBuffer(arr) {
    return typedarrayToBuffer(arr);
}
function arrayToHex(arr, prefixed = false) {
    return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
    return bufferToUtf8(arrayToBuffer(arr));
}
function arrayToNumber(arr) {
    return bufferToNumber(arrayToBuffer(arr));
}
function arrayToBinary(arr) {
    return Array.from(arr)
        .map(numberToBinary)
        .join("");
}
function hexToBuffer(hex) {
    return Buffer$1.from(removeHexPrefix$1(hex), ENC_HEX);
}
function hexToArray(hex) {
    return bufferToArray(hexToBuffer(hex));
}
function hexToUtf8(hex) {
    return bufferToUtf8(hexToBuffer(hex));
}
function hexToNumber(hex) {
    return arrayToNumber(hexToArray(hex));
}
function hexToBinary(hex) {
    return arrayToBinary(hexToArray(hex));
}
function utf8ToBuffer(utf8) {
    return Buffer$1.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
    return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
    return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function utf8ToNumber(utf8) {
    const num = parseInt(utf8, 10);
    assert(isDefined(num), "Number can only safely store up to 53 bits");
    return num;
}
function utf8ToBinary(utf8) {
    return arrayToBinary(utf8ToArray(utf8));
}
function numberToBuffer(num) {
    return binaryToBuffer(numberToBinary(num));
}
function numberToArray(num) {
    return binaryToArray(numberToBinary(num));
}
function numberToHex(num, prefixed) {
    return binaryToHex(numberToBinary(num), prefixed);
}
function numberToUtf8(num) {
    return `${num}`;
}
function numberToBinary(num) {
    const bin = (num >>> 0).toString(2);
    return sanitizeBytes(bin);
}
function binaryToBuffer(bin) {
    return arrayToBuffer(binaryToArray(bin));
}
function binaryToArray(bin) {
    return new Uint8Array(splitBytes(bin).map(x => parseInt(x, 2)));
}
function binaryToHex(bin, prefixed) {
    return arrayToHex(binaryToArray(bin), prefixed);
}
function binaryToUtf8(bin) {
    return arrayToUtf8(binaryToArray(bin));
}
function binaryToNumber(bin) {
    return arrayToNumber(binaryToArray(bin));
}
function isBinaryString(str) {
    if (typeof str !== "string" || !new RegExp(/^[01]+$/).test(str)) {
        return false;
    }
    if (str.length % 8 !== 0) {
        return false;
    }
    return true;
}
function isHexString$1(str, length) {
    if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && str.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
function isBuffer$1(val) {
    return Buffer$1.isBuffer(val);
}
function isTypedArray$1(val) {
    return isTypedarray.strict(val) && !isBuffer$1(val);
}
function isArrayBuffer$2(val) {
    return (!isTypedArray$1(val) &&
        !isBuffer$1(val) &&
        typeof val.byteLength !== "undefined");
}
function getType$1(val) {
    if (isBuffer$1(val)) {
        return TYPE_BUFFER;
    }
    else if (isTypedArray$1(val)) {
        return TYPE_TYPED_ARRAY;
    }
    else if (isArrayBuffer$2(val)) {
        return TYPE_ARRAY_BUFFER;
    }
    else if (Array.isArray(val)) {
        return TYPE_ARRAY;
    }
    else {
        return typeof val;
    }
}
function getEncoding$1(str) {
    if (isBinaryString(str)) {
        return ENC_BIN;
    }
    if (isHexString$1(str)) {
        return ENC_HEX;
    }
    return ENC_UTF8;
}
function concatBuffers$1(...args) {
    const result = Buffer$1.concat(args);
    return result;
}
function concatArrays(...args) {
    let result = [];
    args.forEach(arg => (result = result.concat(Array.from(arg))));
    return new Uint8Array([...result]);
}
function trimLeft(data, length) {
    const diff = data.length - length;
    if (diff > 0) {
        data = data.slice(diff);
    }
    return data;
}
function trimRight(data, length) {
    return data.slice(0, length);
}
function calcByteLength(length, byteSize = 8) {
    const remainder = length % byteSize;
    return remainder
        ? ((length - remainder) / byteSize) * byteSize + byteSize
        : length;
}
function splitBytes(str, byteSize = 8) {
    const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, "gi"));
    return Array.from(bytes || []);
}
function swapBytes(str) {
    return splitBytes(str)
        .map(reverseString)
        .join("");
}
function swapHex(str) {
    return binaryToHex(swapBytes(hexToBinary(str)));
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
    return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
    return padString(str, length, true, padding);
}
function padRight(str, length, padding = STRING_ZERO) {
    return padString(str, length, false, padding);
}
function removeHexPrefix$1(hex) {
    return hex.replace(/^0x/, "");
}
function addHexPrefix$1(hex) {
    return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex$1(hex) {
    hex = removeHexPrefix$1(hex);
    hex = sanitizeBytes(hex, 2);
    if (hex) {
        hex = addHexPrefix$1(hex);
    }
    return hex;
}
function removeHexLeadingZeros$1(hex) {
    const prefixed = hex.startsWith("0x");
    hex = removeHexPrefix$1(hex);
    hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
    return prefixed ? addHexPrefix$1(hex) : hex;
}
function isUndefined(value) {
    return typeof value === "undefined";
}
function isDefined(value) {
    return !isUndefined(value);
}
function assert(assertion, errorMessage) {
    if (!assertion) {
        throw new Error(errorMessage);
    }
}
function reverseString(str) {
    return str
        .split("")
        .reverse()
        .join("");
}
function padString(str, length, left, padding = STRING_ZERO) {
    const diff = length - str.length;
    let result = str;
    if (diff > 0) {
        const pad = padding.repeat(diff);
        result = left ? pad + str : str + pad;
    }
    return result;
}

var esm$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    bufferToArray: bufferToArray,
    bufferToHex: bufferToHex,
    bufferToUtf8: bufferToUtf8,
    bufferToNumber: bufferToNumber,
    bufferToBinary: bufferToBinary,
    arrayToBuffer: arrayToBuffer,
    arrayToHex: arrayToHex,
    arrayToUtf8: arrayToUtf8,
    arrayToNumber: arrayToNumber,
    arrayToBinary: arrayToBinary,
    hexToBuffer: hexToBuffer,
    hexToArray: hexToArray,
    hexToUtf8: hexToUtf8,
    hexToNumber: hexToNumber,
    hexToBinary: hexToBinary,
    utf8ToBuffer: utf8ToBuffer,
    utf8ToArray: utf8ToArray,
    utf8ToHex: utf8ToHex,
    utf8ToNumber: utf8ToNumber,
    utf8ToBinary: utf8ToBinary,
    numberToBuffer: numberToBuffer,
    numberToArray: numberToArray,
    numberToHex: numberToHex,
    numberToUtf8: numberToUtf8,
    numberToBinary: numberToBinary,
    binaryToBuffer: binaryToBuffer,
    binaryToArray: binaryToArray,
    binaryToHex: binaryToHex,
    binaryToUtf8: binaryToUtf8,
    binaryToNumber: binaryToNumber,
    isBinaryString: isBinaryString,
    isHexString: isHexString$1,
    isBuffer: isBuffer$1,
    isTypedArray: isTypedArray$1,
    isArrayBuffer: isArrayBuffer$2,
    getType: getType$1,
    getEncoding: getEncoding$1,
    concatBuffers: concatBuffers$1,
    concatArrays: concatArrays,
    trimLeft: trimLeft,
    trimRight: trimRight,
    calcByteLength: calcByteLength,
    splitBytes: splitBytes,
    swapBytes: swapBytes,
    swapHex: swapHex,
    sanitizeBytes: sanitizeBytes,
    padLeft: padLeft,
    padRight: padRight,
    removeHexPrefix: removeHexPrefix$1,
    addHexPrefix: addHexPrefix$1,
    sanitizeHex: sanitizeHex$1,
    removeHexLeadingZeros: removeHexLeadingZeros$1
});

var require$$1$r = /*@__PURE__*/getAugmentedNamespace(esm$4);

function safeJsonParse$1(value) {
    if (typeof value !== "string") {
        throw new Error(`Cannot safe json parse value of type ${typeof value}`);
    }
    try {
        return JSON.parse(value);
    }
    catch (_a) {
        return value;
    }
}
function safeJsonStringify$1(value) {
    return typeof value === "string" ? value : JSON.stringify(value);
}

var esm$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    safeJsonParse: safeJsonParse$1,
    safeJsonStringify: safeJsonStringify$1
});

var require$$1$q = /*@__PURE__*/getAugmentedNamespace(esm$3);

var constants$c = {};

var core$3 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.CORE_STORAGE_OPTIONS = exports.CORE_DEFAULT = exports.CORE_STORAGE_PREFIX = exports.CORE_CONTEXT = exports.CORE_VERSION = exports.CORE_PROTOCOL = void 0;
exports.CORE_PROTOCOL = "wc";
exports.CORE_VERSION = 2;
exports.CORE_CONTEXT = "core";
exports.CORE_STORAGE_PREFIX = `${exports.CORE_PROTOCOL}@${exports.CORE_VERSION}:${exports.CORE_CONTEXT}:`;
exports.CORE_DEFAULT = {
    name: exports.CORE_CONTEXT,
    logger: "error",
    relayUrl: "wss://relay.walletconnect.com",
};
exports.CORE_STORAGE_OPTIONS = {
    database: ":memory:",
};

}(core$3));

var core$1 = /*@__PURE__*/getDefaultExportFromCjs(core$3);

var core$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), core$3, {
    'default': core$1
}));

var require$$1$p = /*@__PURE__*/getAugmentedNamespace(core$2);

var crypto$6 = {};

Object.defineProperty(crypto$6, "__esModule", { value: true });
var CRYPTO_CONTEXT = crypto$6.CRYPTO_CONTEXT = void 0;
CRYPTO_CONTEXT = crypto$6.CRYPTO_CONTEXT = "crypto";

var crypto$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), crypto$6, {
    get CRYPTO_CONTEXT () { return CRYPTO_CONTEXT; },
    'default': crypto$6
}));

var require$$2$k = /*@__PURE__*/getAugmentedNamespace(crypto$5);

var keychain$3 = {};

Object.defineProperty(keychain$3, "__esModule", { value: true });
var KEYCHAIN_STORAGE_VERSION = keychain$3.KEYCHAIN_STORAGE_VERSION = KEYCHAIN_CONTEXT = keychain$3.KEYCHAIN_CONTEXT = void 0;
var KEYCHAIN_CONTEXT = keychain$3.KEYCHAIN_CONTEXT = "keychain";
KEYCHAIN_STORAGE_VERSION = keychain$3.KEYCHAIN_STORAGE_VERSION = "0.3";

var keychain$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), keychain$3, {
    get KEYCHAIN_STORAGE_VERSION () { return KEYCHAIN_STORAGE_VERSION; },
    get KEYCHAIN_CONTEXT () { return KEYCHAIN_CONTEXT; },
    'default': keychain$3
}));

var require$$3$h = /*@__PURE__*/getAugmentedNamespace(keychain$2);

var messages$3 = {};

Object.defineProperty(messages$3, "__esModule", { value: true });
var MESSAGES_STORAGE_VERSION = messages$3.MESSAGES_STORAGE_VERSION = MESSAGES_CONTEXT = messages$3.MESSAGES_CONTEXT = void 0;
var MESSAGES_CONTEXT = messages$3.MESSAGES_CONTEXT = "messages";
MESSAGES_STORAGE_VERSION = messages$3.MESSAGES_STORAGE_VERSION = "0.3";

var messages$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), messages$3, {
    get MESSAGES_STORAGE_VERSION () { return MESSAGES_STORAGE_VERSION; },
    get MESSAGES_CONTEXT () { return MESSAGES_CONTEXT; },
    'default': messages$3
}));

var require$$4$c = /*@__PURE__*/getAugmentedNamespace(messages$2);

var publisher$3 = {};

Object.defineProperty(publisher$3, "__esModule", { value: true });
var PUBLISHER_CONTEXT = publisher$3.PUBLISHER_CONTEXT = PUBLISHER_DEFAULT_TTL = publisher$3.PUBLISHER_DEFAULT_TTL = void 0;
const time_1$8 = require$$3$q;
var PUBLISHER_DEFAULT_TTL = publisher$3.PUBLISHER_DEFAULT_TTL = time_1$8.SIX_HOURS;
PUBLISHER_CONTEXT = publisher$3.PUBLISHER_CONTEXT = "publisher";

var publisher$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), publisher$3, {
    get PUBLISHER_CONTEXT () { return PUBLISHER_CONTEXT; },
    get PUBLISHER_DEFAULT_TTL () { return PUBLISHER_DEFAULT_TTL; },
    'default': publisher$3
}));

var require$$5$b = /*@__PURE__*/getAugmentedNamespace(publisher$2);

var relayer$3 = {};

Object.defineProperty(relayer$3, "__esModule", { value: true });
var RELAYER_STORAGE_OPTIONS = relayer$3.RELAYER_STORAGE_OPTIONS = RELAYER_RECONNECT_TIMEOUT = relayer$3.RELAYER_RECONNECT_TIMEOUT = RELAYER_PROVIDER_EVENTS = relayer$3.RELAYER_PROVIDER_EVENTS = RELAYER_SUBSCRIBER_SUFFIX = relayer$3.RELAYER_SUBSCRIBER_SUFFIX = RELAYER_EVENTS = relayer$3.RELAYER_EVENTS = RELAYER_CONTEXT = relayer$3.RELAYER_CONTEXT = RELAYER_DEFAULT_RELAY_URL = relayer$3.RELAYER_DEFAULT_RELAY_URL = RELAYER_DEFAULT_LOGGER = relayer$3.RELAYER_DEFAULT_LOGGER = RELAYER_DEFAULT_PROTOCOL = relayer$3.RELAYER_DEFAULT_PROTOCOL = void 0;
const time_1$7 = require$$3$q;
var RELAYER_DEFAULT_PROTOCOL = relayer$3.RELAYER_DEFAULT_PROTOCOL = "waku";
var RELAYER_DEFAULT_LOGGER = relayer$3.RELAYER_DEFAULT_LOGGER = "error";
var RELAYER_DEFAULT_RELAY_URL = relayer$3.RELAYER_DEFAULT_RELAY_URL = "wss://relay.walletconnect.com";
var RELAYER_CONTEXT = relayer$3.RELAYER_CONTEXT = "relayer";
var RELAYER_EVENTS = relayer$3.RELAYER_EVENTS = {
    message: "relayer_message",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error",
};
var RELAYER_SUBSCRIBER_SUFFIX = relayer$3.RELAYER_SUBSCRIBER_SUFFIX = "_subscription";
var RELAYER_PROVIDER_EVENTS = relayer$3.RELAYER_PROVIDER_EVENTS = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error",
};
var RELAYER_RECONNECT_TIMEOUT = relayer$3.RELAYER_RECONNECT_TIMEOUT = time_1$7.ONE_SECOND;
RELAYER_STORAGE_OPTIONS = relayer$3.RELAYER_STORAGE_OPTIONS = {
    database: ":memory:",
};

var relayer$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), relayer$3, {
    get RELAYER_STORAGE_OPTIONS () { return RELAYER_STORAGE_OPTIONS; },
    get RELAYER_RECONNECT_TIMEOUT () { return RELAYER_RECONNECT_TIMEOUT; },
    get RELAYER_PROVIDER_EVENTS () { return RELAYER_PROVIDER_EVENTS; },
    get RELAYER_SUBSCRIBER_SUFFIX () { return RELAYER_SUBSCRIBER_SUFFIX; },
    get RELAYER_EVENTS () { return RELAYER_EVENTS; },
    get RELAYER_CONTEXT () { return RELAYER_CONTEXT; },
    get RELAYER_DEFAULT_RELAY_URL () { return RELAYER_DEFAULT_RELAY_URL; },
    get RELAYER_DEFAULT_LOGGER () { return RELAYER_DEFAULT_LOGGER; },
    get RELAYER_DEFAULT_PROTOCOL () { return RELAYER_DEFAULT_PROTOCOL; },
    'default': relayer$3
}));

var require$$6$8 = /*@__PURE__*/getAugmentedNamespace(relayer$2);

var store$3 = {};

Object.defineProperty(store$3, "__esModule", { value: true });
var STORE_STORAGE_VERSION = store$3.STORE_STORAGE_VERSION = void 0;
STORE_STORAGE_VERSION = store$3.STORE_STORAGE_VERSION = "0.3";

var store$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), store$3, {
    get STORE_STORAGE_VERSION () { return STORE_STORAGE_VERSION; },
    'default': store$3
}));

var require$$7$6 = /*@__PURE__*/getAugmentedNamespace(store$2);

var subscriber$3 = {};

Object.defineProperty(subscriber$3, "__esModule", { value: true });
var SUBSCRIBER_STORAGE_VERSION = subscriber$3.SUBSCRIBER_STORAGE_VERSION = SUBSCRIBER_CONTEXT = subscriber$3.SUBSCRIBER_CONTEXT = SUBSCRIBER_DEFAULT_TTL = subscriber$3.SUBSCRIBER_DEFAULT_TTL = SUBSCRIBER_EVENTS = subscriber$3.SUBSCRIBER_EVENTS = void 0;
const time_1$6 = require$$3$q;
var SUBSCRIBER_EVENTS = subscriber$3.SUBSCRIBER_EVENTS = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    expired: "subscription_expired",
    disabled: "subscription_disabled",
    sync: "subscription_sync",
};
var SUBSCRIBER_DEFAULT_TTL = subscriber$3.SUBSCRIBER_DEFAULT_TTL = time_1$6.THIRTY_DAYS;
var SUBSCRIBER_CONTEXT = subscriber$3.SUBSCRIBER_CONTEXT = "subscription";
SUBSCRIBER_STORAGE_VERSION = subscriber$3.SUBSCRIBER_STORAGE_VERSION = "0.3";

var subscriber$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), subscriber$3, {
    get SUBSCRIBER_STORAGE_VERSION () { return SUBSCRIBER_STORAGE_VERSION; },
    get SUBSCRIBER_CONTEXT () { return SUBSCRIBER_CONTEXT; },
    get SUBSCRIBER_DEFAULT_TTL () { return SUBSCRIBER_DEFAULT_TTL; },
    get SUBSCRIBER_EVENTS () { return SUBSCRIBER_EVENTS; },
    'default': subscriber$3
}));

var require$$8$4 = /*@__PURE__*/getAugmentedNamespace(subscriber$2);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$p, exports);
tslib_1.__exportStar(require$$2$k, exports);
tslib_1.__exportStar(require$$3$h, exports);
tslib_1.__exportStar(require$$4$c, exports);
tslib_1.__exportStar(require$$5$b, exports);
tslib_1.__exportStar(require$$6$8, exports);
tslib_1.__exportStar(require$$7$6, exports);
tslib_1.__exportStar(require$$8$4, exports);

}(constants$c));

var index$8 = /*@__PURE__*/getDefaultExportFromCjs(constants$c);

var constants$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constants$c, {
    'default': index$8
}));

var require$$2$j = /*@__PURE__*/getAugmentedNamespace(constants$b);

var keychain$1 = {};

Object.defineProperty(keychain$1, "__esModule", { value: true });
var KeyChain_1 = keychain$1.KeyChain = void 0;
const tslib_1$j = require$$0$G;
const logger_1$a = require$$2$s;
const utils_1$c = require$$4$d;
const constants_1$e = require$$2$j;
class KeyChain {
    constructor(core, logger) {
        this.core = core;
        this.logger = logger;
        this.keychain = new Map();
        this.name = constants_1$e.KEYCHAIN_CONTEXT;
        this.version = constants_1$e.KEYCHAIN_STORAGE_VERSION;
        this.initialized = false;
        this.storagePrefix = constants_1$e.CORE_STORAGE_PREFIX;
        this.init = () => tslib_1$j.__awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                const keychain = yield this.getKeyChain();
                if (typeof keychain !== "undefined") {
                    this.keychain = keychain;
                }
                this.initialized = true;
            }
        });
        this.has = tag => {
            this.isInitialized();
            return this.keychain.has(tag);
        };
        this.set = (tag, key) => tslib_1$j.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.keychain.set(tag, key);
            yield this.persist();
        });
        this.get = tag => {
            this.isInitialized();
            const key = this.keychain.get(tag);
            if (typeof key === "undefined") {
                throw new Error(utils_1$c.ERROR.NO_MATCHING_KEY.format({ tag }).message);
            }
            return key;
        };
        this.del = (tag) => tslib_1$j.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.keychain.delete(tag);
            yield this.persist();
        });
        this.core = core;
        this.logger = logger_1$a.generateChildLogger(logger, this.name);
    }
    get context() {
        return logger_1$a.getLoggerContext(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
    }
    setKeyChain(keychain) {
        return tslib_1$j.__awaiter(this, void 0, void 0, function* () {
            yield this.core.storage.setItem(this.storageKey, utils_1$c.mapToObj(keychain));
        });
    }
    getKeyChain() {
        return tslib_1$j.__awaiter(this, void 0, void 0, function* () {
            const keychain = yield this.core.storage.getItem(this.storageKey);
            return typeof keychain !== "undefined" ? utils_1$c.objToMap(keychain) : undefined;
        });
    }
    persist() {
        return tslib_1$j.__awaiter(this, void 0, void 0, function* () {
            yield this.setKeyChain(this.keychain);
        });
    }
    isInitialized() {
        if (!this.initialized) {
            throw new Error(utils_1$c.ERROR.NOT_INITIALIZED.stringify(this.name));
        }
    }
}
KeyChain_1 = keychain$1.KeyChain = KeyChain;

var keychain = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), keychain$1, {
    get KeyChain () { return KeyChain_1; },
    'default': keychain$1
}));

var require$$6$7 = /*@__PURE__*/getAugmentedNamespace(keychain);

Object.defineProperty(crypto$7, "__esModule", { value: true });
var Crypto_1 = crypto$7.Crypto = void 0;
const tslib_1$i = require$$0$G;
const encoding$5 = tslib_1$i.__importStar(require$$1$r);
const logger_1$9 = require$$2$s;
const safe_json_1 = require$$1$q;
const utils_1$b = require$$4$d;
const constants_1$d = require$$2$j;
const keychain_1 = require$$6$7;
class Crypto {
    constructor(core, logger, keychain) {
        this.core = core;
        this.logger = logger;
        this.name = constants_1$d.CRYPTO_CONTEXT;
        this.initialized = false;
        this.init = () => tslib_1$i.__awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                yield this.keychain.init();
                this.initialized = true;
            }
        });
        this.hasKeys = tag => {
            this.isInitialized();
            return this.keychain.has(tag);
        };
        this.generateKeyPair = () => {
            this.isInitialized();
            const keyPair = utils_1$b.generateKeyPair();
            return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);
        };
        this.generateSharedKey = (selfPublicKey, peerPublicKey, overrideTopic) => {
            this.isInitialized();
            const privateKey = this.getPrivateKey(selfPublicKey);
            const sharedKey = utils_1$b.deriveSharedKey(privateKey, peerPublicKey);
            const symKey = utils_1$b.deriveSymmetricKey(sharedKey);
            return this.setSymKey(symKey, overrideTopic);
        };
        this.setSymKey = (symKey, overrideTopic) => tslib_1$i.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            const topic = overrideTopic || utils_1$b.hashKey(symKey);
            yield this.keychain.set(topic, symKey);
            return topic;
        });
        this.deleteKeyPair = (publicKey) => tslib_1$i.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.keychain.del(publicKey);
        });
        this.deleteSymKey = (topic) => tslib_1$i.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.keychain.del(topic);
        });
        this.encrypt = (topic, message) => {
            this.isInitialized();
            const symKey = this.getSymKey(topic);
            const result = utils_1$b.encrypt({ symKey, message });
            return result;
        };
        this.decrypt = (topic, encoded) => {
            this.isInitialized();
            const symKey = this.getSymKey(topic);
            const result = utils_1$b.decrypt({ symKey, encoded });
            return result;
        };
        this.encode = (topic, payload) => {
            this.isInitialized();
            const hasKeys = this.hasKeys(topic);
            const message = safe_json_1.safeJsonStringify(payload);
            const result = hasKeys ? this.encrypt(topic, message) : encoding$5.utf8ToHex(message);
            return result;
        };
        this.decode = (topic, encoded) => {
            this.isInitialized();
            const hasKeys = this.hasKeys(topic);
            const message = hasKeys ? this.decrypt(topic, encoded) : encoding$5.hexToUtf8(encoded);
            const payload = safe_json_1.safeJsonParse(message);
            return payload;
        };
        this.core = core;
        this.logger = logger_1$9.generateChildLogger(logger, this.name);
        this.keychain = keychain || new keychain_1.KeyChain(this.core, this.logger);
    }
    get context() {
        return logger_1$9.getLoggerContext(this.logger);
    }
    setPrivateKey(publicKey, privateKey) {
        return tslib_1$i.__awaiter(this, void 0, void 0, function* () {
            yield this.keychain.set(publicKey, privateKey);
            return publicKey;
        });
    }
    getPrivateKey(publicKey) {
        const privateKey = this.keychain.get(publicKey);
        return privateKey;
    }
    getSymKey(topic) {
        const symKey = this.keychain.get(topic);
        return symKey;
    }
    isInitialized() {
        if (!this.initialized) {
            throw new Error(utils_1$b.ERROR.NOT_INITIALIZED.stringify(this.name));
        }
    }
}
Crypto_1 = crypto$7.Crypto = Crypto;

var crypto$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), crypto$7, {
    get Crypto () { return Crypto_1; },
    'default': crypto$7
}));

var require$$1$o = /*@__PURE__*/getAugmentedNamespace(crypto$4);

var messages$1 = {};

Object.defineProperty(messages$1, "__esModule", { value: true });
var MessageTracker_1 = messages$1.MessageTracker = void 0;
const tslib_1$h = require$$0$G;
const logger_1$8 = require$$2$s;
const types_1$9 = require$$3$m;
const utils_1$a = require$$4$d;
const constants_1$c = require$$2$j;
class MessageTracker extends types_1$9.IMessageTracker {
    constructor(logger, core) {
        super(logger, core);
        this.logger = logger;
        this.core = core;
        this.messages = new Map();
        this.name = constants_1$c.MESSAGES_CONTEXT;
        this.version = constants_1$c.MESSAGES_STORAGE_VERSION;
        this.initialized = false;
        this.storagePrefix = constants_1$c.CORE_STORAGE_PREFIX;
        this.init = () => tslib_1$h.__awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                this.logger.trace(`Initialized`);
                try {
                    const messages = yield this.getRelayerMessages();
                    if (typeof messages !== "undefined") {
                        this.messages = messages;
                    }
                    this.logger.debug(`Successfully Restored records for ${this.name}`);
                    this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
                }
                catch (e) {
                    this.logger.debug(`Failed to Restore records for ${this.name}`);
                    this.logger.error(e);
                }
                finally {
                    this.initialized = true;
                }
            }
        });
        this.set = (topic, message) => tslib_1$h.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            const hash = utils_1$a.hashMessage(message);
            let messages = this.messages.get(topic);
            if (typeof messages === "undefined") {
                messages = {};
            }
            if (typeof messages[hash] !== "undefined") {
                return hash;
            }
            messages[hash] = message;
            this.messages.set(topic, messages);
            yield this.persist();
            return hash;
        });
        this.get = topic => {
            this.isInitialized();
            let messages = this.messages.get(topic);
            if (typeof messages === "undefined") {
                messages = {};
            }
            return messages;
        };
        this.has = (topic, message) => {
            this.isInitialized();
            const messages = this.get(topic);
            const hash = utils_1$a.hashMessage(message);
            return typeof messages[hash] !== "undefined";
        };
        this.del = (topic) => tslib_1$h.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.messages.delete(topic);
            yield this.persist();
        });
        this.logger = logger_1$8.generateChildLogger(logger, this.name);
        this.core = core;
    }
    get context() {
        return logger_1$8.getLoggerContext(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
    }
    setRelayerMessages(messages) {
        return tslib_1$h.__awaiter(this, void 0, void 0, function* () {
            yield this.core.storage.setItem(this.storageKey, utils_1$a.mapToObj(messages));
        });
    }
    getRelayerMessages() {
        return tslib_1$h.__awaiter(this, void 0, void 0, function* () {
            const messages = yield this.core.storage.getItem(this.storageKey);
            return typeof messages !== "undefined" ? utils_1$a.objToMap(messages) : undefined;
        });
    }
    persist() {
        return tslib_1$h.__awaiter(this, void 0, void 0, function* () {
            yield this.setRelayerMessages(this.messages);
        });
    }
    isInitialized() {
        if (!this.initialized) {
            throw new Error(utils_1$a.ERROR.NOT_INITIALIZED.stringify(this.name));
        }
    }
}
MessageTracker_1 = messages$1.MessageTracker = MessageTracker;

var messages = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), messages$1, {
    get MessageTracker () { return MessageTracker_1; },
    'default': messages$1
}));

var require$$2$i = /*@__PURE__*/getAugmentedNamespace(messages);

var relayer$1 = {};

const PARSE_ERROR = "PARSE_ERROR";
const INVALID_REQUEST = "INVALID_REQUEST";
const METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
const INVALID_PARAMS = "INVALID_PARAMS";
const INTERNAL_ERROR = "INTERNAL_ERROR";
const SERVER_ERROR = "SERVER_ERROR";
const RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
const SERVER_ERROR_CODE_RANGE = [-32000, -32099];
const STANDARD_ERROR_MAP = {
    [PARSE_ERROR]: { code: -32700, message: "Parse error" },
    [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
    [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
    [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
    [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
    [SERVER_ERROR]: { code: -32000, message: "Server error" },
};
const DEFAULT_ERROR = SERVER_ERROR;

function isServerErrorCode(code) {
    return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
    return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
    return typeof code === "number";
}
function getError(type) {
    if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
        return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }
    return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
    const match = Object.values(STANDARD_ERROR_MAP).find(e => e.code === code);
    if (!match) {
        return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }
    return match;
}
function validateJsonRpcError(response) {
    if (typeof response.error.code === "undefined") {
        return { valid: false, error: "Missing code for JSON-RPC error" };
    }
    if (typeof response.error.message === "undefined") {
        return { valid: false, error: "Missing message for JSON-RPC error" };
    }
    if (!isValidErrorCode(response.error.code)) {
        return {
            valid: false,
            error: `Invalid error code type for JSON-RPC: ${response.error.code}`,
        };
    }
    if (isReservedErrorCode(response.error.code)) {
        const error = getErrorByCode(response.error.code);
        if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message &&
            response.error.message === error.message) {
            return {
                valid: false,
                error: `Invalid error code message for JSON-RPC: ${response.error.code}`,
            };
        }
    }
    return { valid: true };
}
function parseConnectionError(e, url, type) {
    return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED")
        ? new Error(`Unavailable ${type} RPC url at ${url}`)
        : e;
}

var cjs$6 = {};

var crypto$3 = {};

Object.defineProperty(crypto$3, "__esModule", { value: true });
var isBrowserCryptoAvailable_1 = crypto$3.isBrowserCryptoAvailable = getSubtleCrypto_1 = crypto$3.getSubtleCrypto = getBrowerCrypto_1 = crypto$3.getBrowerCrypto = void 0;
function getBrowerCrypto() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
}
var getBrowerCrypto_1 = crypto$3.getBrowerCrypto = getBrowerCrypto;
function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
}
var getSubtleCrypto_1 = crypto$3.getSubtleCrypto = getSubtleCrypto;
function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
}
isBrowserCryptoAvailable_1 = crypto$3.isBrowserCryptoAvailable = isBrowserCryptoAvailable;

var crypto$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), crypto$3, {
    get isBrowserCryptoAvailable () { return isBrowserCryptoAvailable_1; },
    get getSubtleCrypto () { return getSubtleCrypto_1; },
    get getBrowerCrypto () { return getBrowerCrypto_1; },
    'default': crypto$3
}));

var require$$1$n = /*@__PURE__*/getAugmentedNamespace(crypto$2);

var env$3 = {};

Object.defineProperty(env$3, "__esModule", { value: true });
var isBrowser_1$1 = env$3.isBrowser = isNode_1$1 = env$3.isNode = isReactNative_1 = env$3.isReactNative = void 0;
function isReactNative() {
    return (typeof document === "undefined" &&
        typeof navigator !== "undefined" &&
        navigator.product === "ReactNative");
}
var isReactNative_1 = env$3.isReactNative = isReactNative;
function isNode$2() {
    return (typeof browser$1$1 !== "undefined" &&
        typeof browser$1$1.versions !== "undefined" &&
        typeof browser$1$1.versions.node !== "undefined");
}
var isNode_1$1 = env$3.isNode = isNode$2;
function isBrowser$2() {
    return !isReactNative() && !isNode$2();
}
isBrowser_1$1 = env$3.isBrowser = isBrowser$2;

var env$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), env$3, {
    get isBrowser () { return isBrowser_1$1; },
    get isNode () { return isNode_1$1; },
    get isReactNative () { return isReactNative_1; },
    'default': env$3
}));

var require$$2$h = /*@__PURE__*/getAugmentedNamespace(env$2);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$n, exports);
tslib_1.__exportStar(require$$2$h, exports);

}(cjs$6));

const isNodeJs = cjs$6.isNode;

function payloadId$1() {
    const date = Date.now() * Math.pow(10, 3);
    const extra = Math.floor(Math.random() * Math.pow(10, 3));
    return date + extra;
}
function formatJsonRpcRequest(method, params, id) {
    return {
        id: id || payloadId$1(),
        jsonrpc: "2.0",
        method,
        params,
    };
}
function formatJsonRpcResult(id, result) {
    return {
        id,
        jsonrpc: "2.0",
        result,
    };
}
function formatJsonRpcError(id, error, data) {
    return {
        id,
        jsonrpc: "2.0",
        error: formatErrorMessage(error, data),
    };
}
function formatErrorMessage(error, data) {
    if (typeof error === "undefined") {
        return getError(INTERNAL_ERROR);
    }
    if (typeof error === "string") {
        error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
    }
    if (typeof data !== "undefined") {
        error.data = data;
    }
    if (isReservedErrorCode(error.code)) {
        error = getErrorByCode(error.code);
    }
    return error;
}

function isValidRoute(route) {
    if (route.includes("*")) {
        return isValidWildcardRoute(route);
    }
    if (/\W/g.test(route)) {
        return false;
    }
    return true;
}
function isValidDefaultRoute(route) {
    return route === "*";
}
function isValidWildcardRoute(route) {
    if (isValidDefaultRoute(route)) {
        return true;
    }
    if (!route.includes("*")) {
        return false;
    }
    if (route.split("*").length !== 2) {
        return false;
    }
    if (route.split("*").filter(x => x.trim() === "").length !== 1) {
        return false;
    }
    return true;
}
function isValidLeadingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

class IEvents$1 {
}

class IJsonRpcConnection extends IEvents$1 {
    constructor(opts) {
        super();
    }
}
class IBaseJsonRpcProvider extends IEvents$1 {
    constructor() {
        super();
    }
}
class IJsonRpcProvider extends IBaseJsonRpcProvider {
    constructor(connection) {
        super();
    }
}

const HTTP_REGEX = "^https?:";
const WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
    const matches = url.match(new RegExp(/^\w+:/, "gi"));
    if (!matches || !matches.length)
        return;
    return matches[0];
}
function matchRegexProtocol(url, regex) {
    const protocol = getUrlProtocol(url);
    if (typeof protocol === "undefined")
        return false;
    return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
    return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
    return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

function isJsonRpcPayload(payload) {
    return (typeof payload === "object" &&
        "id" in payload &&
        "jsonrpc" in payload &&
        payload.jsonrpc === "2.0");
}
function isJsonRpcRequest$1(payload) {
    return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
    return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
    return "result" in payload;
}
function isJsonRpcError(payload) {
    return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
    return "error" in validation && validation.valid === false;
}

var esm$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    PARSE_ERROR: PARSE_ERROR,
    INVALID_REQUEST: INVALID_REQUEST,
    METHOD_NOT_FOUND: METHOD_NOT_FOUND,
    INVALID_PARAMS: INVALID_PARAMS,
    INTERNAL_ERROR: INTERNAL_ERROR,
    SERVER_ERROR: SERVER_ERROR,
    RESERVED_ERROR_CODES: RESERVED_ERROR_CODES,
    SERVER_ERROR_CODE_RANGE: SERVER_ERROR_CODE_RANGE,
    STANDARD_ERROR_MAP: STANDARD_ERROR_MAP,
    DEFAULT_ERROR: DEFAULT_ERROR,
    isServerErrorCode: isServerErrorCode,
    isReservedErrorCode: isReservedErrorCode,
    isValidErrorCode: isValidErrorCode,
    getError: getError,
    getErrorByCode: getErrorByCode,
    validateJsonRpcError: validateJsonRpcError,
    parseConnectionError: parseConnectionError,
    __moduleExports: cjs$6,
    isNodeJs: isNodeJs,
    payloadId: payloadId$1,
    formatJsonRpcRequest: formatJsonRpcRequest,
    formatJsonRpcResult: formatJsonRpcResult,
    formatJsonRpcError: formatJsonRpcError,
    formatErrorMessage: formatErrorMessage,
    isValidRoute: isValidRoute,
    isValidDefaultRoute: isValidDefaultRoute,
    isValidWildcardRoute: isValidWildcardRoute,
    isValidLeadingWildcardRoute: isValidLeadingWildcardRoute,
    isValidTrailingWildcardRoute: isValidTrailingWildcardRoute,
    IEvents: IEvents$1,
    IJsonRpcConnection: IJsonRpcConnection,
    IBaseJsonRpcProvider: IBaseJsonRpcProvider,
    IJsonRpcProvider: IJsonRpcProvider,
    isHttpUrl: isHttpUrl,
    isWsUrl: isWsUrl,
    isLocalhostUrl: isLocalhostUrl,
    isJsonRpcPayload: isJsonRpcPayload,
    isJsonRpcRequest: isJsonRpcRequest$1,
    isJsonRpcResponse: isJsonRpcResponse,
    isJsonRpcResult: isJsonRpcResult,
    isJsonRpcError: isJsonRpcError,
    isJsonRpcValidationInvalid: isJsonRpcValidationInvalid
});

class JsonRpcProvider extends IJsonRpcProvider {
    constructor(connection) {
        super(connection);
        this.events = new EventEmitter$3();
        this.hasRegisteredEventListeners = false;
        this.connection = this.setConnection(connection);
        if (this.connection.connected) {
            this.registerEventListeners();
        }
    }
    async connect(connection = this.connection) {
        await this.open(connection);
    }
    async disconnect() {
        await this.close();
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async request(request, context) {
        return this.requestStrict(formatJsonRpcRequest(request.method, request.params || []), context);
    }
    async requestStrict(request, context) {
        return new Promise(async (resolve, reject) => {
            if (!this.connection.connected) {
                try {
                    await this.open();
                }
                catch (e) {
                    reject(e);
                }
            }
            this.events.on(`${request.id}`, response => {
                if (isJsonRpcError(response)) {
                    reject(response.error);
                }
                else {
                    resolve(response.result);
                }
            });
            try {
                await this.connection.send(request, context);
            }
            catch (e) {
                reject(e);
            }
        });
    }
    setConnection(connection = this.connection) {
        return connection;
    }
    onPayload(payload) {
        this.events.emit("payload", payload);
        if (isJsonRpcResponse(payload)) {
            this.events.emit(`${payload.id}`, payload);
        }
        else {
            this.events.emit("message", {
                type: payload.method,
                data: payload.params,
            });
        }
    }
    async open(connection = this.connection) {
        if (this.connection === connection && this.connection.connected)
            return;
        if (this.connection.connected)
            this.close();
        if (typeof connection === "string") {
            await this.connection.open(connection);
            connection = this.connection;
        }
        this.connection = this.setConnection(connection);
        await this.connection.open();
        this.registerEventListeners();
        this.events.emit("connect");
    }
    async close() {
        await this.connection.close();
    }
    registerEventListeners() {
        if (this.hasRegisteredEventListeners)
            return;
        this.connection.on("payload", (payload) => this.onPayload(payload));
        this.connection.on("close", () => this.events.emit("disconnect"));
        this.connection.on("error", (error) => this.events.emit("error", error));
        this.hasRegisteredEventListeners = true;
    }
}

var esm$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': JsonRpcProvider,
    JsonRpcProvider: JsonRpcProvider
});

var require$$3$g = /*@__PURE__*/getAugmentedNamespace(esm$1);

var require$$2$g = /*@__PURE__*/getAugmentedNamespace(esm$2);

const EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
const resolveWebSocketImplementation = () => {
    if (typeof global$1 !== "undefined" && typeof global$1.WebSocket !== "undefined") {
        return global$1.WebSocket;
    }
    if (typeof window !== "undefined" && typeof window.WebSocket !== "undefined") {
        return window.WebSocket;
    }
    return require("ws");
};
const isBrowser$1 = () => typeof window !== "undefined";
const WS = resolveWebSocketImplementation();
class WsConnection {
    constructor(url) {
        this.url = url;
        this.events = new EventEmitter$3();
        this.registering = false;
        if (!isWsUrl(url)) {
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
        }
        this.url = url;
    }
    get connected() {
        return typeof this.socket !== "undefined";
    }
    get connecting() {
        return this.registering;
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async open(url = this.url) {
        await this.register(url);
    }
    async close() {
        if (typeof this.socket === "undefined") {
            throw new Error("Connection already closed");
        }
        this.socket.close();
        this.onClose();
    }
    async send(payload, context) {
        if (typeof this.socket === "undefined") {
            this.socket = await this.register();
        }
        try {
            this.socket.send(safeJsonStringify$1(payload));
        }
        catch (e) {
            this.onError(payload.id, e);
        }
    }
    register(url = this.url) {
        if (!isWsUrl(url)) {
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
        }
        if (this.registering) {
            const currentMaxListeners = this.events.getMaxListeners();
            if (this.events.listenerCount("register_error") >= currentMaxListeners ||
                this.events.listenerCount("open") >= currentMaxListeners) {
                this.events.setMaxListeners(currentMaxListeners + 1);
            }
            return new Promise((resolve, reject) => {
                this.events.once("register_error", error => {
                    this.resetMaxListeners();
                    reject(error);
                });
                this.events.once("open", () => {
                    this.resetMaxListeners();
                    if (typeof this.socket === "undefined") {
                        return reject(new Error("WebSocket connection is missing or invalid"));
                    }
                    resolve(this.socket);
                });
            });
        }
        this.url = url;
        this.registering = true;
        return new Promise((resolve, reject) => {
            const opts = !cjs$6.isReactNative() ? { rejectUnauthorized: !isLocalhostUrl(url) } : undefined;
            const socket = new WS(url, [], opts);
            if (isBrowser$1()) {
                socket.onerror = (event) => {
                    const errorEvent = event;
                    reject(this.emitError(errorEvent.error));
                };
            }
            else {
                socket.on("error", (errorEvent) => {
                    reject(this.emitError(errorEvent));
                });
            }
            socket.onopen = () => {
                this.onOpen(socket);
                resolve(socket);
            };
        });
    }
    onOpen(socket) {
        socket.onmessage = (event) => this.onPayload(event);
        socket.onclose = () => this.onClose();
        this.socket = socket;
        this.registering = false;
        this.events.emit("open");
    }
    onClose() {
        this.socket = undefined;
        this.registering = false;
        this.events.emit("close");
    }
    onPayload(e) {
        if (typeof e.data === "undefined")
            return;
        const payload = typeof e.data === "string" ? safeJsonParse$1(e.data) : e.data;
        this.events.emit("payload", payload);
    }
    onError(id, e) {
        const error = this.parseError(e);
        const message = error.message || error.toString();
        const payload = formatJsonRpcError(id, message);
        this.events.emit("payload", payload);
    }
    parseError(e, url = this.url) {
        return parseConnectionError(e, url, "WS");
    }
    resetMaxListeners() {
        if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
            this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
        }
    }
    emitError(errorEvent) {
        const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || `WebSocket connection failed for URL: ${this.url}`));
        this.events.emit("register_error", error);
        return error;
    }
}

var esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': WsConnection,
    WsConnection: WsConnection
});

var require$$5$a = /*@__PURE__*/getAugmentedNamespace(esm);

var publisher$1 = {};

Object.defineProperty(publisher$1, "__esModule", { value: true });
var Publisher_1 = publisher$1.Publisher = void 0;
const tslib_1$g = require$$0$G;
const heartbeat_1$3 = require$$1$J;
const logger_1$7 = require$$2$s;
const types_1$8 = require$$3$m;
const utils_1$9 = require$$4$d;
const events_1$7 = require$$1$19;
const constants_1$b = require$$2$j;
class Publisher extends types_1$8.IPublisher {
    constructor(relayer, logger) {
        super(relayer, logger);
        this.relayer = relayer;
        this.logger = logger;
        this.events = new events_1$7.EventEmitter();
        this.name = constants_1$b.PUBLISHER_CONTEXT;
        this.queue = new Map();
        this.publish = (topic, message, opts) => tslib_1$g.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Publishing Payload`);
            this.logger.trace({ type: "method", method: "publish", params: { topic, message, opts } });
            try {
                const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || constants_1$b.PUBLISHER_DEFAULT_TTL;
                const relay = utils_1$9.getRelayProtocolName(opts);
                const prompt = (opts === null || opts === void 0 ? void 0 : opts.prompt) || false;
                const params = { topic, message, opts: { ttl, relay, prompt } };
                const hash = utils_1$9.hashMessage(message);
                this.queue.set(hash, params);
                yield this.rpcPublish(topic, message, ttl, relay, prompt);
                this.onPublish(hash, params);
                this.logger.debug(`Successfully Published Payload`);
                this.logger.trace({ type: "method", method: "publish", params: { topic, message, opts } });
            }
            catch (e) {
                this.logger.debug(`Failed to Publish Payload`);
                this.logger.error(e);
                throw e;
            }
        });
        this.on = (event, listener) => {
            this.events.on(event, listener);
        };
        this.once = (event, listener) => {
            this.events.once(event, listener);
        };
        this.off = (event, listener) => {
            this.events.off(event, listener);
        };
        this.removeListener = (event, listener) => {
            this.events.removeListener(event, listener);
        };
        this.relayer = relayer;
        this.logger = logger_1$7.generateChildLogger(logger, this.name);
        this.registerEventListeners();
    }
    get context() {
        return logger_1$7.getLoggerContext(this.logger);
    }
    rpcPublish(topic, message, ttl, relay, prompt) {
        var _a, _b;
        const api = utils_1$9.getRelayProtocolApi(relay.protocol);
        const request = {
            method: api.publish,
            params: {
                topic,
                message,
                ttl,
                prompt,
            },
        };
        if (typeof ((_a = request.params) === null || _a === void 0 ? void 0 : _a.prompt) === "undefined") {
            (_b = request.params) === null || _b === void 0 ? true : delete _b.prompt;
        }
        this.logger.debug(`Outgoing Relay Payload`);
        this.logger.trace({ type: "message", direction: "outgoing", request });
        return this.relayer.provider.request(request);
    }
    onPublish(hash, _params) {
        this.queue.delete(hash);
    }
    checkQueue() {
        this.queue.forEach((params) => tslib_1$g.__awaiter(this, void 0, void 0, function* () {
            const { topic, message, opts: { ttl, relay }, } = params;
            const hash = utils_1$9.hashMessage(message);
            yield this.rpcPublish(topic, message, ttl, relay);
            this.onPublish(hash, params);
        }));
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(heartbeat_1$3.HEARTBEAT_EVENTS.pulse, () => {
            this.checkQueue();
        });
    }
}
Publisher_1 = publisher$1.Publisher = Publisher;

var publisher = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), publisher$1, {
    get Publisher () { return Publisher_1; },
    'default': publisher$1
}));

var require$$12$2 = /*@__PURE__*/getAugmentedNamespace(publisher);

var subscriber$1 = {};

var topicmap$1 = {};

Object.defineProperty(topicmap$1, "__esModule", { value: true });
var SubscriberTopicMap_1 = topicmap$1.SubscriberTopicMap = void 0;
class SubscriberTopicMap {
    constructor() {
        this.map = new Map();
        this.set = (topic, id) => {
            const ids = this.get(topic);
            if (this.exists(topic, id))
                return;
            this.map.set(topic, [...ids, id]);
        };
        this.get = topic => {
            const ids = this.map.get(topic);
            return ids || [];
        };
        this.exists = (topic, id) => {
            const ids = this.get(topic);
            return ids.includes(id);
        };
        this.delete = (topic, id) => {
            if (typeof id === "undefined") {
                this.map.delete(topic);
                return;
            }
            if (!this.map.has(topic))
                return;
            const ids = this.get(topic);
            if (!this.exists(topic, id))
                return;
            const remaining = ids.filter(x => x !== id);
            if (!remaining.length) {
                this.map.delete(topic);
                return;
            }
            this.map.set(topic, remaining);
        };
        this.clear = () => {
            this.map.clear();
        };
    }
    get topics() {
        return Array.from(this.map.keys());
    }
}
SubscriberTopicMap_1 = topicmap$1.SubscriberTopicMap = SubscriberTopicMap;

var topicmap = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), topicmap$1, {
    get SubscriberTopicMap () { return SubscriberTopicMap_1; },
    'default': topicmap$1
}));

var require$$7$5 = /*@__PURE__*/getAugmentedNamespace(topicmap);

Object.defineProperty(subscriber$1, "__esModule", { value: true });
var Subscriber_1 = subscriber$1.Subscriber = void 0;
const tslib_1$f = require$$0$G;
const events_1$6 = require$$1$19;
const heartbeat_1$2 = require$$1$J;
const logger_1$6 = require$$2$s;
const types_1$7 = require$$3$m;
const utils_1$8 = require$$4$d;
const constants_1$a = require$$2$j;
const topicmap_1 = require$$7$5;
class Subscriber extends types_1$7.ISubscriber {
    constructor(relayer, logger) {
        super(relayer, logger);
        this.relayer = relayer;
        this.logger = logger;
        this.subscriptions = new Map();
        this.topicMap = new topicmap_1.SubscriberTopicMap();
        this.events = new events_1$6.EventEmitter();
        this.name = constants_1$a.SUBSCRIBER_CONTEXT;
        this.version = constants_1$a.SUBSCRIBER_STORAGE_VERSION;
        this.pending = new Map();
        this.cached = [];
        this.initialized = false;
        this.storagePrefix = constants_1$a.CORE_STORAGE_PREFIX;
        this.init = () => tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                this.logger.trace(`Initialized`);
                yield this.restore();
                yield this.reset();
                this.registerEventListeners();
                this.onEnable();
            }
        });
        this.subscribe = (topic, opts) => tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.logger.debug(`Subscribing Topic`);
            this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
            try {
                const relay = utils_1$8.getRelayProtocolName(opts);
                const params = { topic, relay };
                this.pending.set(topic, params);
                const id = yield this.rpcSubscribe(topic, relay);
                this.onSubscribe(id, params);
                this.logger.debug(`Successfully Subscribed Topic`);
                this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
                return id;
            }
            catch (e) {
                this.logger.debug(`Failed to Subscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
        this.unsubscribe = (topic, opts) => tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            if (typeof (opts === null || opts === void 0 ? void 0 : opts.id) !== "undefined") {
                yield this.unsubscribeById(topic, opts.id, opts);
            }
            else {
                yield this.unsubscribeByTopic(topic, opts);
            }
        });
        this.on = (event, listener) => {
            this.events.on(event, listener);
        };
        this.once = (event, listener) => {
            this.events.once(event, listener);
        };
        this.off = (event, listener) => {
            this.events.off(event, listener);
        };
        this.removeListener = (event, listener) => {
            this.events.removeListener(event, listener);
        };
        this.relayer = relayer;
        this.logger = logger_1$6.generateChildLogger(logger, this.name);
    }
    get context() {
        return logger_1$6.getLoggerContext(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
    }
    get length() {
        return this.subscriptions.size;
    }
    get ids() {
        return Array.from(this.subscriptions.keys());
    }
    get values() {
        return Array.from(this.subscriptions.values());
    }
    get topics() {
        return this.topicMap.topics;
    }
    hasSubscription(id, topic) {
        let result = false;
        try {
            const subscription = this.getSubscription(id);
            result = subscription.topic === topic;
        }
        catch (e) {
        }
        return result;
    }
    onEnable() {
        this.cached = [];
        this.initialized = true;
    }
    onDisable() {
        this.cached = this.values;
        this.subscriptions.clear();
        this.topicMap.clear();
        this.initialized = false;
    }
    unsubscribeByTopic(topic, opts) {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            const ids = this.topicMap.get(topic);
            yield Promise.all(ids.map((id) => tslib_1$f.__awaiter(this, void 0, void 0, function* () { return yield this.unsubscribeById(topic, id, opts); })));
        });
    }
    unsubscribeById(topic, id, opts) {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Unsubscribing Topic`);
            this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
            try {
                const relay = utils_1$8.getRelayProtocolName(opts);
                yield this.rpcUnsubscribe(topic, id, relay);
                const reason = utils_1$8.ERROR.DELETED.format({ context: this.name });
                yield this.onUnsubscribe(topic, id, reason);
                this.logger.debug(`Successfully Unsubscribed Topic`);
                this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
            }
            catch (e) {
                this.logger.debug(`Failed to Unsubscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    rpcSubscribe(topic, relay) {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            const api = utils_1$8.getRelayProtocolApi(relay.protocol);
            const request = {
                method: api.subscribe,
                params: {
                    topic,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            return yield this.relayer.provider.request(request);
        });
    }
    rpcUnsubscribe(topic, id, relay) {
        const api = utils_1$8.getRelayProtocolApi(relay.protocol);
        const request = {
            method: api.unsubscribe,
            params: {
                topic,
                id,
            },
        };
        this.logger.debug(`Outgoing Relay Payload`);
        this.logger.trace({ type: "payload", direction: "outgoing", request });
        return this.relayer.provider.request(request);
    }
    onSubscribe(id, params) {
        this.setSubscription(id, Object.assign(Object.assign({}, params), { id }));
        this.pending.delete(params.topic);
    }
    onResubscribe(id, params) {
        this.addSubscription(id, Object.assign(Object.assign({}, params), { id }));
        this.pending.delete(params.topic);
    }
    onUnsubscribe(topic, id, reason) {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            this.events.removeAllListeners(id);
            if (this.hasSubscription(id, topic)) {
                this.deleteSubscription(id, reason);
            }
            yield this.relayer.messages.del(topic);
        });
    }
    setRelayerSubscriptions(subscriptions) {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            yield this.relayer.core.storage.setItem(this.storageKey, subscriptions);
        });
    }
    getRelayerSubscriptions() {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            const subscriptions = yield this.relayer.core.storage.getItem(this.storageKey);
            return subscriptions;
        });
    }
    setSubscription(id, subscription) {
        if (this.subscriptions.has(id))
            return;
        this.logger.debug(`Setting subscription`);
        this.logger.trace({ type: "method", method: "setSubscription", id, subscription });
        this.addSubscription(id, subscription);
    }
    addSubscription(id, subscription) {
        this.subscriptions.set(id, Object.assign({}, subscription));
        this.topicMap.set(subscription.topic, id);
        this.events.emit(constants_1$a.SUBSCRIBER_EVENTS.created, subscription);
    }
    getSubscription(id) {
        this.logger.debug(`Getting subscription`);
        this.logger.trace({ type: "method", method: "getSubscription", id });
        const subscription = this.subscriptions.get(id);
        if (!subscription) {
            const error = utils_1$8.ERROR.NO_MATCHING_ID.format({
                context: this.name,
                id,
            });
            throw new Error(error.message);
        }
        return subscription;
    }
    deleteSubscription(id, reason) {
        this.logger.debug(`Deleting subscription`);
        this.logger.trace({ type: "method", method: "deleteSubscription", id, reason });
        const subscription = this.getSubscription(id);
        this.subscriptions.delete(id);
        this.topicMap.delete(subscription.topic, id);
        this.events.emit(constants_1$a.SUBSCRIBER_EVENTS.deleted, Object.assign(Object.assign({}, subscription), { reason }));
    }
    persist() {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            yield this.setRelayerSubscriptions(this.values);
            this.events.emit(constants_1$a.SUBSCRIBER_EVENTS.sync);
        });
    }
    reset() {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length)
                return;
            yield Promise.all(this.cached.map((subscription) => tslib_1$f.__awaiter(this, void 0, void 0, function* () { return yield this.resubscribe(subscription); })));
        });
    }
    restore() {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            try {
                const persisted = yield this.getRelayerSubscriptions();
                if (typeof persisted === "undefined")
                    return;
                if (!persisted.length)
                    return;
                if (this.subscriptions.size) {
                    const error = utils_1$8.ERROR.RESTORE_WILL_OVERRIDE.format({
                        context: this.name,
                    });
                    this.logger.error(error.message);
                    throw new Error(error.message);
                }
                this.cached = persisted;
                this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);
                this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
            }
            catch (e) {
                this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);
                this.logger.error(e);
            }
        });
    }
    resubscribe(subscription) {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            const { topic, relay } = subscription;
            const params = { topic, relay };
            this.pending.set(params.topic, params);
            const id = yield this.rpcSubscribe(params.topic, params.relay);
            this.onResubscribe(id, params);
            if (this.ids.includes(subscription.id)) {
                const reason = utils_1$8.ERROR.RESUBSCRIBED.format({ topic: subscription.topic });
                this.deleteSubscription(subscription.id, reason);
            }
        });
    }
    onConnect() {
        return tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            yield this.reset();
            this.onEnable();
        });
    }
    onDisconnect() {
        this.onDisable();
    }
    checkPending() {
        this.pending.forEach((params) => tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            const id = yield this.rpcSubscribe(params.topic, params.relay);
            this.onSubscribe(id, params);
        }));
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(heartbeat_1$2.HEARTBEAT_EVENTS.pulse, () => {
            this.checkPending();
        });
        this.relayer.provider.on(constants_1$a.RELAYER_PROVIDER_EVENTS.connect, () => tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            yield this.onConnect();
        }));
        this.relayer.provider.on(constants_1$a.RELAYER_PROVIDER_EVENTS.disconnect, () => {
            this.onDisconnect();
        });
        this.events.on(constants_1$a.SUBSCRIBER_EVENTS.created, (createdEvent) => tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            const eventName = constants_1$a.SUBSCRIBER_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: createdEvent });
            yield this.persist();
        }));
        this.events.on(constants_1$a.SUBSCRIBER_EVENTS.deleted, (deletedEvent) => tslib_1$f.__awaiter(this, void 0, void 0, function* () {
            const eventName = constants_1$a.SUBSCRIBER_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
            yield this.persist();
        }));
    }
    isInitialized() {
        if (!this.initialized) {
            throw new Error(utils_1$8.ERROR.NOT_INITIALIZED.stringify(this.name));
        }
    }
}
Subscriber_1 = subscriber$1.Subscriber = Subscriber;

var subscriber = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), subscriber$1, {
    get Subscriber () { return Subscriber_1; },
    'default': subscriber$1
}));

var require$$5$9 = /*@__PURE__*/getAugmentedNamespace(subscriber);

Object.defineProperty(relayer$1, "__esModule", { value: true });
var Relayer_1 = relayer$1.Relayer = void 0;
const tslib_1$e = require$$0$G;
const pino_1$2 = tslib_1$e.__importDefault(require$$6$e);
const events_1$5 = require$$1$19;
const jsonrpc_provider_1 = require$$3$g;
const jsonrpc_utils_1$2 = require$$2$g;
const jsonrpc_ws_connection_1 = tslib_1$e.__importDefault(require$$5$a);
const logger_1$5 = require$$2$s;
const time_1$5 = require$$3$q;
const types_1$6 = require$$3$m;
const utils_1$7 = require$$4$d;
const constants_1$9 = require$$2$j;
const messages_1 = require$$2$i;
const publisher_1 = require$$12$2;
const subscriber_1 = require$$5$9;
class Relayer extends types_1$6.IRelayer {
    constructor(opts) {
        super(opts);
        this.protocol = "irn";
        this.version = 1;
        this.events = new events_1$5.EventEmitter();
        this.name = constants_1$9.RELAYER_CONTEXT;
        this.initialized = false;
        this.core = opts.core;
        this.logger =
            typeof opts.logger !== "undefined" && typeof opts.logger !== "string"
                ? logger_1$5.generateChildLogger(opts.logger, this.name)
                : pino_1$2.default(logger_1$5.getDefaultLoggerOptions({ level: opts.logger || constants_1$9.RELAYER_DEFAULT_LOGGER }));
        const rpcUrl = opts.rpcUrl ||
            utils_1$7.formatRelayRpcUrl(this.protocol, this.version, constants_1$9.RELAYER_DEFAULT_RELAY_URL, opts.projectId);
        this.provider =
            typeof opts.relayProvider !== "string" && typeof opts.relayProvider !== "undefined"
                ? opts.relayProvider
                : new jsonrpc_provider_1.JsonRpcProvider(new jsonrpc_ws_connection_1.default(rpcUrl));
        this.messages = new messages_1.MessageTracker(this.logger, opts.core);
        this.subscriber = new subscriber_1.Subscriber(this, this.logger);
        this.publisher = new publisher_1.Publisher(this, this.logger);
    }
    init() {
        return tslib_1$e.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield Promise.all([this.messages.init(), this.provider.connect(), this.subscriber.init()]);
            this.registerEventListeners();
            this.initialized = true;
        });
    }
    get context() {
        return logger_1$5.getLoggerContext(this.logger);
    }
    get connected() {
        return this.provider.connection.connected;
    }
    get connecting() {
        return this.provider.connection.connecting;
    }
    publish(topic, message, opts) {
        return tslib_1$e.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.publisher.publish(topic, message, opts);
            yield this.recordMessageEvent({ topic, message });
        });
    }
    subscribe(topic, opts) {
        return tslib_1$e.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            const id = yield this.subscriber.subscribe(topic, opts);
            return id;
        });
    }
    unsubscribe(topic, opts) {
        return tslib_1$e.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.subscriber.unsubscribe(topic, opts);
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    recordMessageEvent(messageEvent) {
        return tslib_1$e.__awaiter(this, void 0, void 0, function* () {
            const { topic, message } = messageEvent;
            yield this.messages.set(topic, message);
        });
    }
    shouldIgnoreMessageEvent(messageEvent) {
        const { topic, message } = messageEvent;
        if (!this.subscriber.topics.includes(topic))
            return true;
        const exists = this.messages.has(topic, message);
        return exists;
    }
    onProviderPayload(payload) {
        return tslib_1$e.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Incoming Relay Payload`);
            this.logger.trace({ type: "payload", direction: "incoming", payload });
            if (jsonrpc_utils_1$2.isJsonRpcRequest(payload)) {
                if (!payload.method.endsWith(constants_1$9.RELAYER_SUBSCRIBER_SUFFIX))
                    return;
                const event = payload.params;
                const { topic, message } = event.data;
                const messageEvent = { topic, message };
                this.logger.debug(`Emitting Relayer Payload`);
                this.logger.trace(Object.assign({ type: "event", event: event.id }, messageEvent));
                this.events.emit(event.id, messageEvent);
                yield this.acknowledgePayload(payload);
                yield this.onMessageEvent(messageEvent);
            }
        });
    }
    onMessageEvent(messageEvent) {
        return tslib_1$e.__awaiter(this, void 0, void 0, function* () {
            if (this.shouldIgnoreMessageEvent(messageEvent))
                return;
            this.events.emit(constants_1$9.RELAYER_EVENTS.message, messageEvent);
            yield this.recordMessageEvent(messageEvent);
        });
    }
    acknowledgePayload(payload) {
        return tslib_1$e.__awaiter(this, void 0, void 0, function* () {
            const response = jsonrpc_utils_1$2.formatJsonRpcResult(payload.id, true);
            yield this.provider.connection.send(response);
        });
    }
    registerEventListeners() {
        this.provider.on(constants_1$9.RELAYER_PROVIDER_EVENTS.payload, (payload) => this.onProviderPayload(payload));
        this.provider.on(constants_1$9.RELAYER_PROVIDER_EVENTS.connect, () => {
            this.events.emit(constants_1$9.RELAYER_EVENTS.connect);
        });
        this.provider.on(constants_1$9.RELAYER_PROVIDER_EVENTS.disconnect, () => {
            this.events.emit(constants_1$9.RELAYER_EVENTS.disconnect);
            setTimeout(() => {
                this.provider.connect();
            }, time_1$5.toMiliseconds(constants_1$9.RELAYER_RECONNECT_TIMEOUT));
        });
        this.provider.on(constants_1$9.RELAYER_PROVIDER_EVENTS.error, (err) => this.events.emit(constants_1$9.RELAYER_EVENTS.error, err));
    }
    isInitialized() {
        if (!this.initialized) {
            throw new Error(utils_1$7.ERROR.NOT_INITIALIZED.stringify(this.name));
        }
    }
}
Relayer_1 = relayer$1.Relayer = Relayer;

var relayer = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), relayer$1, {
    get Relayer () { return Relayer_1; },
    'default': relayer$1
}));

var require$$3$f = /*@__PURE__*/getAugmentedNamespace(relayer);

var store$1 = {};

Object.defineProperty(store$1, "__esModule", { value: true });
var Store_1 = store$1.Store = void 0;
const tslib_1$d = require$$0$G;
const logger_1$4 = require$$2$s;
const types_1$5 = require$$3$m;
const utils_1$6 = require$$4$d;
const constants_1$8 = require$$2$j;
class Store extends types_1$5.IStore {
    constructor(core, logger, name, storagePrefix = constants_1$8.CORE_STORAGE_PREFIX) {
        super(core, logger, name, storagePrefix);
        this.core = core;
        this.logger = logger;
        this.name = name;
        this.map = new Map();
        this.version = constants_1$8.STORE_STORAGE_VERSION;
        this.cached = [];
        this.initialized = false;
        this.storagePrefix = constants_1$8.CORE_STORAGE_PREFIX;
        this.init = () => tslib_1$d.__awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                this.logger.trace(`Initialized`);
                yield this.restore();
                this.cached.forEach(value => {
                    if (utils_1$6.isProposalStruct(value)) {
                        this.map.set(value.id, value);
                    }
                    else if (utils_1$6.isSessionStruct(value)) {
                        this.map.set(value.topic, value);
                    }
                });
                this.cached = [];
                this.initialized = true;
            }
        });
        this.set = (key, value) => tslib_1$d.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            if (this.map.has(key)) {
                yield this.update(key, value);
            }
            else {
                this.logger.debug(`Setting value`);
                this.logger.trace({ type: "method", method: "set", key, value });
                this.map.set(key, value);
                yield this.persist();
            }
        });
        this.get = key => {
            this.isInitialized();
            this.logger.debug(`Getting value`);
            this.logger.trace({ type: "method", method: "get", key });
            const value = this.getData(key);
            return value;
        };
        this.update = (key, update) => tslib_1$d.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.logger.debug(`Updating value`);
            this.logger.trace({ type: "method", method: "update", key, update });
            const value = Object.assign(Object.assign({}, this.getData(key)), update);
            this.map.set(key, value);
            yield this.persist();
        });
        this.delete = (key, reason) => tslib_1$d.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            if (!this.map.has(key))
                return;
            this.logger.debug(`Deleting value`);
            this.logger.trace({ type: "method", method: "delete", key, reason });
            this.map.delete(key);
            yield this.persist();
        });
        this.logger = logger_1$4.generateChildLogger(logger, this.name);
        this.storagePrefix = storagePrefix;
    }
    get context() {
        return logger_1$4.getLoggerContext(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
    }
    get length() {
        return this.map.size;
    }
    get keys() {
        return Array.from(this.map.keys());
    }
    get values() {
        return Array.from(this.map.values());
    }
    setDataStore(value) {
        return tslib_1$d.__awaiter(this, void 0, void 0, function* () {
            yield this.core.storage.setItem(this.storageKey, value);
        });
    }
    getDataStore() {
        return tslib_1$d.__awaiter(this, void 0, void 0, function* () {
            const value = yield this.core.storage.getItem(this.storageKey);
            return value;
        });
    }
    getData(key) {
        const value = this.map.get(key);
        if (!value) {
            const error = utils_1$6.ERROR.NO_MATCHING_TOPIC.format({
                context: this.name,
                topic: key,
            });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        return value;
    }
    persist() {
        return tslib_1$d.__awaiter(this, void 0, void 0, function* () {
            yield this.setDataStore(this.values);
        });
    }
    restore() {
        return tslib_1$d.__awaiter(this, void 0, void 0, function* () {
            try {
                const persisted = yield this.getDataStore();
                if (typeof persisted === "undefined")
                    return;
                if (!persisted.length)
                    return;
                if (this.map.size) {
                    const error = utils_1$6.ERROR.RESTORE_WILL_OVERRIDE.format({
                        context: this.name,
                    });
                    this.logger.error(error.message);
                    throw new Error(error.message);
                }
                this.cached = persisted;
                this.logger.debug(`Successfully Restored value for ${this.name}`);
                this.logger.trace({ type: "method", method: "restore", value: this.values });
            }
            catch (e) {
                this.logger.debug(`Failed to Restore value for ${this.name}`);
                this.logger.error(e);
            }
        });
    }
    isInitialized() {
        if (!this.initialized) {
            throw new Error(utils_1$6.ERROR.NOT_INITIALIZED.stringify(this.name));
        }
    }
}
Store_1 = store$1.Store = Store;

var store = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), store$1, {
    get Store () { return Store_1; },
    'default': store$1
}));

var require$$4$b = /*@__PURE__*/getAugmentedNamespace(store);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$o, exports);
tslib_1.__exportStar(require$$2$i, exports);
tslib_1.__exportStar(require$$3$f, exports);
tslib_1.__exportStar(require$$4$b, exports);
tslib_1.__exportStar(require$$5$9, exports);
tslib_1.__exportStar(require$$6$7, exports);

}(controllers$3));

var index$7 = /*@__PURE__*/getDefaultExportFromCjs(controllers$3);

var controllers$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), controllers$3, {
    'default': index$7
}));

var require$$3$e = /*@__PURE__*/getAugmentedNamespace(controllers$2);

Object.defineProperty(core$9, "__esModule", { value: true });
var Core_1 = core$9.Core = void 0;
const tslib_1$c = require$$0$G;
const pino_1$1 = tslib_1$c.__importDefault(require$$6$e);
const events_1$4 = require$$1$19;
const keyvaluestorage_1 = tslib_1$c.__importDefault(require$$3$s);
const heartbeat_1$1 = require$$1$J;
const logger_1$3 = require$$2$s;
const types_1$4 = require$$3$m;
const utils_1$5 = require$$4$d;
const controllers_1$1 = require$$3$e;
const constants_1$7 = require$$2$j;
class Core extends types_1$4.ICore {
    constructor(opts) {
        super(opts);
        this.protocol = constants_1$7.CORE_PROTOCOL;
        this.version = constants_1$7.CORE_VERSION;
        this.name = constants_1$7.CORE_CONTEXT;
        this.events = new events_1$4.EventEmitter();
        this.initialized = false;
        this.on = (name, listener) => {
            return this.events.on(name, listener);
        };
        this.once = (name, listener) => {
            return this.events.once(name, listener);
        };
        this.off = (name, listener) => {
            return this.events.off(name, listener);
        };
        this.removeListener = (name, listener) => {
            return this.events.removeListener(name, listener);
        };
        this.projectId = opts === null || opts === void 0 ? void 0 : opts.projectId;
        const logger = typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "undefined" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "string"
            ? opts.logger
            : pino_1$1.default(logger_1$3.getDefaultLoggerOptions({ level: (opts === null || opts === void 0 ? void 0 : opts.logger) || constants_1$7.CORE_DEFAULT.logger }));
        this.logger = logger_1$3.generateChildLogger(logger, this.name);
        this.heartbeat = new heartbeat_1$1.HeartBeat();
        this.crypto = new controllers_1$1.Crypto(this, this.logger, opts === null || opts === void 0 ? void 0 : opts.keychain);
        this.storage = new keyvaluestorage_1.default(Object.assign(Object.assign({}, constants_1$7.CORE_STORAGE_OPTIONS), opts === null || opts === void 0 ? void 0 : opts.storageOptions));
        this.relayUrl = utils_1$5.formatRelayRpcUrl(this.protocol, this.version, (opts === null || opts === void 0 ? void 0 : opts.relayUrl) || constants_1$7.CORE_DEFAULT.relayUrl, this.projectId);
        this.relayer = new controllers_1$1.Relayer({
            core: this,
            rpcUrl: this.relayUrl,
            logger: this.logger,
            projectId: this.projectId,
        });
    }
    static init(opts) {
        return tslib_1$c.__awaiter(this, void 0, void 0, function* () {
            const core = new Core(opts);
            yield core.initialize();
            return core;
        });
    }
    get context() {
        return logger_1$3.getLoggerContext(this.logger);
    }
    start() {
        return tslib_1$c.__awaiter(this, void 0, void 0, function* () {
            if (this.initialized)
                return;
            yield this.initialize();
        });
    }
    initialize() {
        return tslib_1$c.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            try {
                yield Promise.all([this.crypto.init(), this.relayer.init(), this.heartbeat.init()]);
                this.initialized = true;
                this.logger.info(`Core Initilization Success`);
            }
            catch (error) {
                this.logger.info(`Core Initilization Failure`);
                this.logger.error(error.message);
                throw error;
            }
        });
    }
}
Core_1 = core$9.Core = Core;

var core = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), core$9, {
    get Core () { return Core_1; },
    'default': core$9
}));

var require$$1$m = /*@__PURE__*/getAugmentedNamespace(core);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Core = void 0;
const tslib_1 = require$$0$G;
const core_1 = require$$1$m;
tslib_1.__exportStar(require$$2$j, exports);
tslib_1.__exportStar(require$$3$e, exports);
exports.Core = core_1.Core;
exports.default = core_1.Core;

}(cjs$p));

var index$6 = /*@__PURE__*/getDefaultExportFromCjs(cjs$p);

var cjs$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$p, {
    'default': index$6
}));

var require$$1$l = /*@__PURE__*/getAugmentedNamespace(cjs$5);

var constants$a = {};

var client$3 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SIGN_CLIENT_STORAGE_OPTIONS = exports.SIGN_CLIENT_EVENTS = exports.SIGN_CLIENT_DEFAULT = exports.SIGN_CLIENT_STORAGE_PREFIX = exports.SIGN_CLIENT_CONTEXT = exports.SIGN_CLIENT_VERSION = exports.SIGN_CLIENT_PROTOCOL = void 0;
exports.SIGN_CLIENT_PROTOCOL = "wc";
exports.SIGN_CLIENT_VERSION = 2;
exports.SIGN_CLIENT_CONTEXT = "client";
exports.SIGN_CLIENT_STORAGE_PREFIX = `${exports.SIGN_CLIENT_PROTOCOL}@${exports.SIGN_CLIENT_VERSION}:${exports.SIGN_CLIENT_CONTEXT}:`;
exports.SIGN_CLIENT_DEFAULT = {
    name: exports.SIGN_CLIENT_CONTEXT,
    logger: "error",
    controller: false,
    relayUrl: "wss://relay.walletconnect.com",
};
exports.SIGN_CLIENT_EVENTS = {
    session_proposal: "session_proposal",
    session_update: "session_update",
    session_extend: "session_extend",
    session_ping: "session_ping",
    pairing_ping: "pairing_ping",
    session_delete: "session_delete",
    session_expire: "session_expire",
    pairing_delete: "pairing_delete",
    pairing_expire: "pairing_expire",
    session_request: "session_request",
    session_event: "session_event",
    proposal_expire: "proposal_expire",
};
exports.SIGN_CLIENT_STORAGE_OPTIONS = {
    database: ":memory:",
};

}(client$3));

var client$1 = /*@__PURE__*/getDefaultExportFromCjs(client$3);

var client$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), client$3, {
    'default': client$1
}));

var require$$1$k = /*@__PURE__*/getAugmentedNamespace(client$2);

var expirer$3 = {};

Object.defineProperty(expirer$3, "__esModule", { value: true });
var EXPIRER_DEFAULT_TTL = expirer$3.EXPIRER_DEFAULT_TTL = EXPIRER_STORAGE_VERSION = expirer$3.EXPIRER_STORAGE_VERSION = EXPIRER_EVENTS = expirer$3.EXPIRER_EVENTS = EXPIRER_CONTEXT = expirer$3.EXPIRER_CONTEXT = void 0;
const time_1$4 = require$$3$q;
var EXPIRER_CONTEXT = expirer$3.EXPIRER_CONTEXT = "expirer";
var EXPIRER_EVENTS = expirer$3.EXPIRER_EVENTS = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync",
};
var EXPIRER_STORAGE_VERSION = expirer$3.EXPIRER_STORAGE_VERSION = "0.3";
EXPIRER_DEFAULT_TTL = expirer$3.EXPIRER_DEFAULT_TTL = time_1$4.ONE_DAY;

var expirer$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), expirer$3, {
    get EXPIRER_DEFAULT_TTL () { return EXPIRER_DEFAULT_TTL; },
    get EXPIRER_STORAGE_VERSION () { return EXPIRER_STORAGE_VERSION; },
    get EXPIRER_EVENTS () { return EXPIRER_EVENTS; },
    get EXPIRER_CONTEXT () { return EXPIRER_CONTEXT; },
    'default': expirer$3
}));

var require$$2$f = /*@__PURE__*/getAugmentedNamespace(expirer$2);

var history$3 = {};

Object.defineProperty(history$3, "__esModule", { value: true });
var HISTORY_STORAGE_VERSION = history$3.HISTORY_STORAGE_VERSION = HISTORY_CONTEXT = history$3.HISTORY_CONTEXT = HISTORY_EVENTS = history$3.HISTORY_EVENTS = void 0;
var HISTORY_EVENTS = history$3.HISTORY_EVENTS = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync",
};
var HISTORY_CONTEXT = history$3.HISTORY_CONTEXT = "history";
HISTORY_STORAGE_VERSION = history$3.HISTORY_STORAGE_VERSION = "0.3";

var history$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), history$3, {
    get HISTORY_STORAGE_VERSION () { return HISTORY_STORAGE_VERSION; },
    get HISTORY_CONTEXT () { return HISTORY_CONTEXT; },
    get HISTORY_EVENTS () { return HISTORY_EVENTS; },
    'default': history$3
}));

var require$$3$d = /*@__PURE__*/getAugmentedNamespace(history$2);

var pairing$3 = {};

Object.defineProperty(pairing$3, "__esModule", { value: true });
var PAIRING_DEFAULT_TTL = pairing$3.PAIRING_DEFAULT_TTL = PAIRING_CONTEXT = pairing$3.PAIRING_CONTEXT = void 0;
const time_1$3 = require$$3$q;
var PAIRING_CONTEXT = pairing$3.PAIRING_CONTEXT = "pairing";
PAIRING_DEFAULT_TTL = pairing$3.PAIRING_DEFAULT_TTL = time_1$3.THIRTY_DAYS;

var pairing$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pairing$3, {
    get PAIRING_DEFAULT_TTL () { return PAIRING_DEFAULT_TTL; },
    get PAIRING_CONTEXT () { return PAIRING_CONTEXT; },
    'default': pairing$3
}));

var require$$4$a = /*@__PURE__*/getAugmentedNamespace(pairing$2);

var proposal$3 = {};

Object.defineProperty(proposal$3, "__esModule", { value: true });
var PROPOSAL_EXPIRY = proposal$3.PROPOSAL_EXPIRY = PROPOSAL_CONTEXT = proposal$3.PROPOSAL_CONTEXT = void 0;
const utils_1$4 = require$$4$d;
const time_1$2 = require$$3$q;
var PROPOSAL_CONTEXT = proposal$3.PROPOSAL_CONTEXT = "proposal";
PROPOSAL_EXPIRY = proposal$3.PROPOSAL_EXPIRY = utils_1$4.calcExpiry(time_1$2.THIRTY_DAYS);

var proposal$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), proposal$3, {
    get PROPOSAL_EXPIRY () { return PROPOSAL_EXPIRY; },
    get PROPOSAL_CONTEXT () { return PROPOSAL_CONTEXT; },
    'default': proposal$3
}));

var require$$5$8 = /*@__PURE__*/getAugmentedNamespace(proposal$2);

var session$6 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SESSION_EXPIRY = exports.SESSION_DEFAULT_TTL = exports.SESSION_CONTEXT = void 0;
const time_1 = require$$3$q;
const utils_1 = require$$4$d;
exports.SESSION_CONTEXT = "session";
exports.SESSION_DEFAULT_TTL = time_1.SEVEN_DAYS;
exports.SESSION_EXPIRY = utils_1.calcExpiry(exports.SESSION_DEFAULT_TTL);

}(session$6));

var session$4 = /*@__PURE__*/getDefaultExportFromCjs(session$6);

var session$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), session$6, {
    'default': session$4
}));

var require$$6$6 = /*@__PURE__*/getAugmentedNamespace(session$5);

var engine$3 = {};

Object.defineProperty(engine$3, "__esModule", { value: true });
var ENGINE_CONTEXT = engine$3.ENGINE_CONTEXT = void 0;
ENGINE_CONTEXT = engine$3.ENGINE_CONTEXT = "engine";

var engine$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), engine$3, {
    get ENGINE_CONTEXT () { return ENGINE_CONTEXT; },
    'default': engine$3
}));

var require$$7$4 = /*@__PURE__*/getAugmentedNamespace(engine$2);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$k, exports);
tslib_1.__exportStar(require$$2$f, exports);
tslib_1.__exportStar(require$$3$d, exports);
tslib_1.__exportStar(require$$4$a, exports);
tslib_1.__exportStar(require$$5$8, exports);
tslib_1.__exportStar(require$$6$6, exports);
tslib_1.__exportStar(require$$7$4, exports);

}(constants$a));

var index$5 = /*@__PURE__*/getDefaultExportFromCjs(constants$a);

var constants$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constants$a, {
    'default': index$5
}));

var require$$2$e = /*@__PURE__*/getAugmentedNamespace(constants$9);

var controllers$1 = {};

var engine$1 = {};

Object.defineProperty(engine$1, "__esModule", { value: true });
var Engine_1 = engine$1.Engine = void 0;
const tslib_1$b = require$$0$G;
const events_1$3 = tslib_1$b.__importDefault(require$$1$19);
const core_1$4 = require$$1$l;
const constants_1$6 = require$$2$e;
const jsonrpc_utils_1$1 = require$$2$g;
const time_1$1 = require$$3$q;
const types_1$3 = require$$3$m;
const utils_1$3 = require$$4$d;
class Engine extends types_1$3.IEngine {
    constructor(client) {
        super(client);
        this.events = new events_1$3.default();
        this.initialized = false;
        this.name = constants_1$6.ENGINE_CONTEXT;
        this.init = () => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                yield this.cleanup();
                this.registerRelayerEvents();
                this.registerExpirerEvents();
                this.initialized = true;
            }
        });
        this.connect = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.isValidConnect(params);
            const { pairingTopic, requiredNamespaces, relays } = params;
            let topic = pairingTopic;
            let uri = undefined;
            let active = false;
            if (topic) {
                const pairing = this.client.pairing.get(topic);
                active = pairing.active;
            }
            if (!topic || !active) {
                const { topic: newTopic, uri: newUri } = yield this.createPairing();
                topic = newTopic;
                uri = newUri;
            }
            const publicKey = yield this.client.core.crypto.generateKeyPair();
            const proposal = {
                requiredNamespaces,
                relays: relays !== null && relays !== void 0 ? relays : [{ protocol: core_1$4.RELAYER_DEFAULT_PROTOCOL }],
                proposer: {
                    publicKey,
                    metadata: this.client.metadata,
                },
            };
            const { reject, resolve, done: approval } = utils_1$3.createDelayedPromise();
            this.events.once(utils_1$3.engineEvent("session_connect"), ({ error, session }) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
                if (error)
                    reject(error);
                else if (session) {
                    session.self.publicKey = publicKey;
                    yield this.client.session.set(session.topic, session);
                    yield this.setExpiry(session.topic, session.expiry);
                    if (topic)
                        yield this.client.pairing.update(topic, { peerMetadata: session.peer.metadata });
                    resolve(session);
                }
            }));
            if (!topic)
                throw new Error(utils_1$3.ERROR.MISSING_OR_INVALID.stringify({ name: "topic" }));
            const id = yield this.sendRequest(topic, "wc_sessionPropose", proposal);
            const expiry = utils_1$3.calcExpiry(time_1$1.FIVE_MINUTES);
            yield this.setProposal(id, Object.assign({ id, expiry }, proposal));
            return { uri, approval };
        });
        this.pair = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.isValidPair(params);
            const { topic, symKey, relay } = utils_1$3.parseUri(params.uri);
            const expiry = utils_1$3.calcExpiry(time_1$1.FIVE_MINUTES);
            const pairing = { topic, relay, expiry, active: false };
            yield this.client.pairing.set(topic, pairing);
            yield this.client.core.crypto.setSymKey(symKey, topic);
            yield this.client.core.relayer.subscribe(topic, { relay });
            yield this.setExpiry(topic, expiry);
            return pairing;
        });
        this.approve = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.isValidApprove(params);
            const { id, relayProtocol, namespaces } = params;
            const { pairingTopic, proposer } = this.client.proposal.get(id);
            const selfPublicKey = yield this.client.core.crypto.generateKeyPair();
            const peerPublicKey = proposer.publicKey;
            const sessionTopic = yield this.client.core.crypto.generateSharedKey(selfPublicKey, peerPublicKey);
            const sessionSettle = {
                relay: {
                    protocol: relayProtocol !== null && relayProtocol !== void 0 ? relayProtocol : "waku",
                },
                namespaces,
                controller: {
                    publicKey: selfPublicKey,
                    metadata: this.client.metadata,
                },
                expiry: constants_1$6.SESSION_EXPIRY,
            };
            yield this.client.core.relayer.subscribe(sessionTopic);
            const requestId = yield this.sendRequest(sessionTopic, "wc_sessionSettle", sessionSettle);
            const { done: acknowledged, resolve, reject } = utils_1$3.createDelayedPromise();
            this.events.once(utils_1$3.engineEvent("session_approve", requestId), ({ error }) => {
                if (error)
                    reject(error);
                else
                    resolve(this.client.session.get(sessionTopic));
            });
            const session = Object.assign(Object.assign({}, sessionSettle), { topic: sessionTopic, acknowledged: false, self: sessionSettle.controller, peer: {
                    publicKey: proposer.publicKey,
                    metadata: proposer.metadata,
                }, controller: selfPublicKey });
            yield this.client.session.set(sessionTopic, session);
            yield this.setExpiry(sessionTopic, constants_1$6.SESSION_EXPIRY);
            if (pairingTopic)
                yield this.client.pairing.update(pairingTopic, { peerMetadata: session.peer.metadata });
            if (pairingTopic && id) {
                yield this.sendResult(id, pairingTopic, {
                    relay: {
                        protocol: relayProtocol !== null && relayProtocol !== void 0 ? relayProtocol : "waku",
                    },
                    responderPublicKey: selfPublicKey,
                });
                yield this.client.proposal.delete(id, utils_1$3.ERROR.DELETED.format());
                yield this.activatePairing(pairingTopic);
            }
            return { topic: sessionTopic, acknowledged };
        });
        this.reject = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.isValidReject(params);
            const { id, reason } = params;
            const { pairingTopic } = this.client.proposal.get(id);
            if (pairingTopic) {
                yield this.sendError(id, pairingTopic, reason);
                yield this.client.proposal.delete(id, utils_1$3.ERROR.DELETED.format());
            }
        });
        this.update = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.isValidUpdate(params);
            const { topic, namespaces } = params;
            const id = yield this.sendRequest(topic, "wc_sessionUpdate", { namespaces });
            const { done: acknowledged, resolve, reject } = utils_1$3.createDelayedPromise();
            this.events.once(utils_1$3.engineEvent("session_update", id), ({ error }) => {
                if (error)
                    reject(error);
                else
                    resolve();
            });
            yield this.client.session.update(topic, { namespaces });
            return { acknowledged };
        });
        this.extend = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.isValidExtend(params);
            const { topic } = params;
            const id = yield this.sendRequest(topic, "wc_sessionExtend", {});
            const { done: acknowledged, resolve, reject } = utils_1$3.createDelayedPromise();
            this.events.once(utils_1$3.engineEvent("session_extend", id), ({ error }) => {
                if (error)
                    reject(error);
                else
                    resolve();
            });
            yield this.setExpiry(topic, constants_1$6.SESSION_EXPIRY);
            return { acknowledged };
        });
        this.request = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.isValidRequest(params);
            const { chainId, request, topic } = params;
            const id = yield this.sendRequest(topic, "wc_sessionRequest", { request, chainId });
            const { done, resolve, reject } = utils_1$3.createDelayedPromise();
            this.events.once(utils_1$3.engineEvent("session_request", id), ({ error, result }) => {
                if (error)
                    reject(error);
                else if (result)
                    resolve(result);
            });
            return yield done();
        });
        this.respond = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.isValidRespond(params);
            const { topic, response } = params;
            const { id } = response;
            if (jsonrpc_utils_1$1.isJsonRpcResult(response)) {
                yield this.sendResult(id, topic, response.result);
            }
            else if (jsonrpc_utils_1$1.isJsonRpcError(response)) {
                yield this.sendError(id, topic, response.error);
            }
        });
        this.ping = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.isValidPing(params);
            const { topic } = params;
            if (this.client.session.keys.includes(topic)) {
                const id = yield this.sendRequest(topic, "wc_sessionPing", {});
                const { done, resolve, reject } = utils_1$3.createDelayedPromise();
                this.events.once(utils_1$3.engineEvent("session_ping", id), ({ error }) => {
                    if (error)
                        reject(error);
                    else
                        resolve();
                });
                yield done();
            }
            else if (this.client.pairing.keys.includes(topic)) {
                const id = yield this.sendRequest(topic, "wc_pairingPing", {});
                const { done, resolve, reject } = utils_1$3.createDelayedPromise();
                this.events.once(utils_1$3.engineEvent("pairing_ping", id), ({ error }) => {
                    if (error)
                        reject(error);
                    else
                        resolve();
                });
                yield done();
            }
        });
        this.emit = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.isValidEmit(params);
            const { topic, event, chainId } = params;
            yield this.sendRequest(topic, "wc_sessionEvent", { event, chainId });
        });
        this.disconnect = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            yield this.isValidDisconnect(params);
            const { topic } = params;
            if (this.client.session.keys.includes(topic)) {
                yield this.sendRequest(topic, "wc_sessionDelete", utils_1$3.ERROR.DELETED.format());
                yield this.deleteSession(topic);
            }
            else if (this.client.pairing.keys.includes(topic)) {
                yield this.sendRequest(topic, "wc_pairingDelete", utils_1$3.ERROR.DELETED.format());
                yield this.deletePairing(topic);
            }
        });
        this.find = params => {
            this.isInitialized();
            return this.client.session.values.filter(session => utils_1$3.isSessionCompatible(session, params));
        };
        this.activatePairing = (topic) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            yield this.client.pairing.update(topic, { active: true, expiry: constants_1$6.PROPOSAL_EXPIRY });
            yield this.setExpiry(topic, constants_1$6.PROPOSAL_EXPIRY);
        });
        this.deleteSession = (topic) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { self } = this.client.session.get(topic);
            yield Promise.all([
                this.client.core.relayer.unsubscribe(topic),
                this.client.session.delete(topic, utils_1$3.ERROR.DELETED.format()),
                this.client.core.crypto.deleteKeyPair(self.publicKey),
                this.client.core.crypto.deleteSymKey(topic),
                this.client.expirer.del(utils_1$3.formatTopicTarget(topic)),
            ]);
        });
        this.deletePairing = (topic) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this.client.core.relayer.unsubscribe(topic),
                this.client.pairing.delete(topic, utils_1$3.ERROR.DELETED.format()),
                this.client.core.crypto.deleteSymKey(topic),
                this.client.expirer.del(utils_1$3.formatTopicTarget(topic)),
            ]);
        });
        this.deleteProposal = (id) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this.client.proposal.delete(id, utils_1$3.ERROR.DELETED.format()),
                this.client.expirer.del(utils_1$3.formatIdTarget(id)),
            ]);
        });
        this.setExpiry = (topic, expiry) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (this.client.pairing.keys.includes(topic)) {
                yield this.client.pairing.update(topic, { expiry });
            }
            else if (this.client.session.keys.includes(topic)) {
                yield this.client.session.update(topic, { expiry });
            }
            const target = utils_1$3.formatTopicTarget(topic);
            this.client.expirer.set(target, { target, expiry });
        });
        this.setProposal = (id, proposal) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            yield this.client.proposal.set(id, proposal);
            const target = utils_1$3.formatIdTarget(id);
            this.client.expirer.set(target, { target, expiry: proposal.expiry });
        });
        this.sendRequest = (topic, method, params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const payload = jsonrpc_utils_1$1.formatJsonRpcRequest(method, params);
            const message = this.client.core.crypto.encode(topic, payload);
            yield this.client.core.relayer.publish(topic, message);
            this.client.history.set(topic, payload);
            return payload.id;
        });
        this.sendResult = (id, topic, result) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const payload = jsonrpc_utils_1$1.formatJsonRpcResult(id, result);
            const message = this.client.core.crypto.encode(topic, payload);
            yield this.client.core.relayer.publish(topic, message);
            yield this.client.history.resolve(payload);
        });
        this.sendError = (id, topic, error) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const payload = jsonrpc_utils_1$1.formatJsonRpcError(id, error);
            const message = this.client.core.crypto.encode(topic, payload);
            yield this.client.core.relayer.publish(topic, message);
            yield this.client.history.resolve(payload);
        });
        this.cleanup = () => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const sessionTopics = [];
            const pairingTopics = [];
            const proposalIds = [];
            this.client.session.values.forEach(session => {
                if (utils_1$3.isExpired(session.expiry))
                    sessionTopics.push(session.topic);
            });
            this.client.pairing.values.forEach(pairing => {
                if (utils_1$3.isExpired(pairing.expiry))
                    pairingTopics.push(pairing.topic);
            });
            this.client.proposal.values.forEach(proposal => {
                if (utils_1$3.isExpired(proposal.expiry))
                    proposalIds.push(proposal.id);
            });
            yield Promise.all([
                ...sessionTopics.map(this.deleteSession),
                ...pairingTopics.map(this.deletePairing),
                ...proposalIds.map(this.deleteProposal),
            ]);
        });
        this.onRelayEventRequest = event => {
            const { topic, payload } = event;
            const reqMethod = payload.method;
            switch (reqMethod) {
                case "wc_sessionPropose":
                    return this.onSessionProposeRequest(topic, payload);
                case "wc_sessionSettle":
                    return this.onSessionSettleRequest(topic, payload);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateRequest(topic, payload);
                case "wc_sessionExtend":
                    return this.onSessionExtendRequest(topic, payload);
                case "wc_sessionPing":
                    return this.onSessionPingRequest(topic, payload);
                case "wc_pairingPing":
                    return this.onPairingPingRequest(topic, payload);
                case "wc_sessionDelete":
                    return this.onSessionDeleteRequest(topic, payload);
                case "wc_pairingDelete":
                    return this.onPairingDeleteRequest(topic, payload);
                case "wc_sessionRequest":
                    return this.onSessionRequest(topic, payload);
                case "wc_sessionEvent":
                    return this.onSessionEventRequest(topic, payload);
                default:
                    return;
            }
        };
        this.onRelayEventResponse = (event) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = event;
            const record = yield this.client.history.get(topic, payload.id);
            const resMethod = record.request.method;
            switch (resMethod) {
                case "wc_sessionPropose":
                    return this.onSessionProposeResponse(topic, payload);
                case "wc_sessionSettle":
                    return this.onSessionSettleResponse(topic, payload);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateResponse(topic, payload);
                case "wc_sessionExtend":
                    return this.onSessionExtendResponse(topic, payload);
                case "wc_sessionPing":
                    return this.onSessionPingResponse(topic, payload);
                case "wc_pairingPing":
                    return this.onPairingPingResponse(topic, payload);
                case "wc_sessionRequest":
                    return this.onSessionRequestResponse(topic, payload);
                default:
                    return;
            }
        });
        this.onSessionProposeRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { params, id } = payload;
            try {
                this.isValidConnect(Object.assign({}, payload.params));
                const expiry = utils_1$3.calcExpiry(time_1$1.FIVE_MINUTES);
                const proposal = Object.assign({ id, pairingTopic: topic, expiry }, params);
                yield this.setProposal(id, proposal);
                this.client.events.emit("session_proposal", { id, params: proposal });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onSessionProposeResponse = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id: id } = payload;
            if (jsonrpc_utils_1$1.isJsonRpcResult(payload)) {
                const { result } = payload;
                this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result });
                const proposal = this.client.proposal.get(id);
                this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal });
                const selfPublicKey = proposal.proposer.publicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    selfPublicKey,
                });
                const peerPublicKey = result.responderPublicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    peerPublicKey,
                });
                const sessionTopic = yield this.client.core.crypto.generateSharedKey(selfPublicKey, peerPublicKey);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    sessionTopic,
                });
                const subscriptionId = yield this.client.core.relayer.subscribe(sessionTopic);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    subscriptionId,
                });
                yield this.activatePairing(topic);
            }
            else if (jsonrpc_utils_1$1.isJsonRpcError(payload)) {
                yield this.client.proposal.delete(id, utils_1$3.ERROR.DELETED.format());
                this.events.emit(utils_1$3.engineEvent("session_connect"), { error: payload.error });
            }
        });
        this.onSessionSettleRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id, params } = payload;
            try {
                this.isValidApprove(Object.assign({ id }, params));
                const { relay, controller, expiry, namespaces } = payload.params;
                const session = {
                    topic,
                    relay,
                    expiry,
                    namespaces,
                    acknowledged: true,
                    controller: controller.publicKey,
                    self: {
                        publicKey: "",
                        metadata: this.client.metadata,
                    },
                    peer: {
                        publicKey: controller.publicKey,
                        metadata: controller.metadata,
                    },
                };
                yield this.sendResult(payload.id, topic, true);
                this.events.emit(utils_1$3.engineEvent("session_connect"), { session });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onSessionSettleResponse = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id } = payload;
            if (jsonrpc_utils_1$1.isJsonRpcResult(payload)) {
                yield this.client.session.update(topic, { acknowledged: true });
                this.events.emit(utils_1$3.engineEvent("session_approve", id), {});
            }
            else if (jsonrpc_utils_1$1.isJsonRpcError(payload)) {
                yield this.client.session.delete(topic, utils_1$3.ERROR.DELETED.format());
                this.events.emit(utils_1$3.engineEvent("session_approve", id), { error: payload.error });
            }
        });
        this.onSessionUpdateRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { params, id } = payload;
            try {
                this.isValidUpdate(Object.assign({ topic }, params));
                yield this.client.session.update(topic, { namespaces: params.namespaces });
                yield this.sendResult(id, topic, true);
                this.client.events.emit("session_update", { id, topic, params });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onSessionUpdateResponse = (_topic, payload) => {
            const { id } = payload;
            if (jsonrpc_utils_1$1.isJsonRpcResult(payload)) {
                this.events.emit(utils_1$3.engineEvent("session_update", id), {});
            }
            else if (jsonrpc_utils_1$1.isJsonRpcError(payload)) {
                this.events.emit(utils_1$3.engineEvent("session_update", id), { error: payload.error });
            }
        };
        this.onSessionExtendRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id } = payload;
            try {
                this.isValidExtend({ topic });
                yield this.setExpiry(topic, constants_1$6.SESSION_EXPIRY);
                yield this.sendResult(id, topic, true);
                this.client.events.emit("session_extend", { id, topic });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onSessionExtendResponse = (_topic, payload) => {
            const { id } = payload;
            if (jsonrpc_utils_1$1.isJsonRpcResult(payload)) {
                this.events.emit(utils_1$3.engineEvent("session_extend", id), {});
            }
            else if (jsonrpc_utils_1$1.isJsonRpcError(payload)) {
                this.events.emit(utils_1$3.engineEvent("session_extend", id), { error: payload.error });
            }
        };
        this.onSessionPingRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id } = payload;
            try {
                this.isValidPing({ topic });
                yield this.sendResult(id, topic, true);
                this.client.events.emit("session_ping", { id, topic });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onSessionPingResponse = (_topic, payload) => {
            const { id } = payload;
            if (jsonrpc_utils_1$1.isJsonRpcResult(payload)) {
                this.events.emit(utils_1$3.engineEvent("session_ping", id), {});
            }
            else if (jsonrpc_utils_1$1.isJsonRpcError(payload)) {
                this.events.emit(utils_1$3.engineEvent("session_ping", id), { error: payload.error });
            }
        };
        this.onPairingPingRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id } = payload;
            try {
                this.isValidPing({ topic });
                yield this.sendResult(id, topic, true);
                this.client.events.emit("pairing_ping", { id, topic });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onPairingPingResponse = (_topic, payload) => {
            const { id } = payload;
            if (jsonrpc_utils_1$1.isJsonRpcResult(payload)) {
                this.events.emit(utils_1$3.engineEvent("pairing_ping", id), {});
            }
            else if (jsonrpc_utils_1$1.isJsonRpcError(payload)) {
                this.events.emit(utils_1$3.engineEvent("pairing_ping", id), { error: payload.error });
            }
        };
        this.onSessionDeleteRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id } = payload;
            try {
                this.isValidDisconnect({ topic, reason: payload.params });
                yield this.sendResult(id, topic, true);
                yield this.deleteSession(topic);
                this.client.events.emit("session_delete", { id, topic });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onPairingDeleteRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id } = payload;
            try {
                this.isValidDisconnect({ topic, reason: payload.params });
                yield this.sendResult(id, topic, true);
                yield this.deletePairing(topic);
                this.client.events.emit("pairing_delete", { id, topic });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onSessionRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id, params } = payload;
            try {
                this.isValidRequest(Object.assign({ topic }, params));
                this.client.events.emit("session_request", { id, topic, params });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.onSessionRequestResponse = (_topic, payload) => {
            const { id } = payload;
            if (jsonrpc_utils_1$1.isJsonRpcResult(payload)) {
                this.events.emit(utils_1$3.engineEvent("session_request", id), { result: payload.result });
            }
            else if (jsonrpc_utils_1$1.isJsonRpcError(payload)) {
                this.events.emit(utils_1$3.engineEvent("session_request", id), { error: payload.error });
            }
        };
        this.onSessionEventRequest = (topic, payload) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { id, params } = payload;
            try {
                this.isValidEmit(Object.assign({ topic }, params));
                this.client.events.emit("session_event", { id, topic, params });
            }
            catch (err) {
                yield this.sendError(id, topic, err);
                this.client.logger.error(err);
            }
        });
        this.isValidConnect = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "connect params" });
            const { pairingTopic, requiredNamespaces, relays } = params;
            if (!utils_1$3.isUndefined(pairingTopic))
                yield this.isValidPairingTopic(pairingTopic);
            if (!utils_1$3.isValidRequiredNamespaces(requiredNamespaces, false))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "connect requiredNamespaces" });
            if (!utils_1$3.isValidRelays(relays, true))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "connect relays" });
        });
        this.isValidPair = params => {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "pair params" });
            if (!utils_1$3.isValidUrl(params.uri))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "pair uri" });
        };
        this.isValidApprove = params => {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "approve params" });
            const { id, namespaces, relayProtocol } = params;
            if (!utils_1$3.isValidId(id))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "approve id" });
            if (!utils_1$3.isValidNamespaces(namespaces, false))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "approve namespaces" });
            if (!utils_1$3.isValidString(relayProtocol, true))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "approve relayProtocol" });
        };
        this.isValidReject = params => {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "reject params" });
            const { id, reason } = params;
            if (!utils_1$3.isValidId(id))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "reject id" });
            if (!utils_1$3.isValidErrorReason(reason))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "reject reason" });
        };
        this.isValidUpdate = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "update params" });
            const { topic, namespaces } = params;
            yield this.isValidSessionTopic(topic);
            if (!utils_1$3.isValidNamespaces(namespaces, false))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "update namespaces" });
        });
        this.isValidExtend = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "extend params" });
            const { topic } = params;
            yield this.isValidSessionTopic(topic);
        });
        this.isValidRequest = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "request params" });
            const { topic, request, chainId } = params;
            yield this.isValidSessionTopic(topic);
            const { namespaces } = this.client.session.get(topic);
            if (!utils_1$3.isValidNamespacesChainId(namespaces, chainId))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "request chainId" });
            if (!utils_1$3.isValidRequest(request))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "request method" });
            if (!utils_1$3.isValidNamespacesRequest(namespaces, chainId, request.method))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "request method" });
        });
        this.isValidRespond = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "respond params" });
            const { topic, response } = params;
            yield this.isValidSessionTopic(topic);
            if (!utils_1$3.isValidResponse(response))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "respond response" });
        });
        this.isValidPing = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "ping params" });
            const { topic } = params;
            yield this.isValidSessionOrPairingTopic(topic);
        });
        this.isValidEmit = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "emit params" });
            const { topic, event, chainId } = params;
            yield this.isValidSessionTopic(topic);
            const { namespaces } = this.client.session.get(topic);
            if (!utils_1$3.isValidNamespacesChainId(namespaces, chainId))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "emit chainId" });
            if (!utils_1$3.isValidEvent(event))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "emit event" });
            if (!utils_1$3.isValidNamespacesEvent(namespaces, chainId, event.name))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "emit event" });
        });
        this.isValidDisconnect = (params) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidParams(params))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "disconnect params" });
            const { topic } = params;
            yield this.isValidSessionOrPairingTopic(topic);
        });
    }
    createPairing() {
        return tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const symKey = utils_1$3.generateRandomBytes32();
            const topic = yield this.client.core.crypto.setSymKey(symKey);
            const expiry = utils_1$3.calcExpiry(time_1$1.FIVE_MINUTES);
            const relay = { protocol: core_1$4.RELAYER_DEFAULT_PROTOCOL };
            const pairing = { topic, expiry, relay, active: false };
            const uri = utils_1$3.formatUri({
                protocol: this.client.protocol,
                version: this.client.version,
                topic,
                symKey,
                relay,
            });
            yield this.client.pairing.set(topic, pairing);
            yield this.client.core.relayer.subscribe(topic);
            yield this.setExpiry(topic, expiry);
            return { topic, uri };
        });
    }
    isInitialized() {
        if (!this.initialized)
            throw new Error(utils_1$3.ERROR.NOT_INITIALIZED.stringify(this.name));
    }
    registerRelayerEvents() {
        this.client.core.relayer.on(core_1$4.RELAYER_EVENTS.message, (event) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const { topic, message } = event;
            const payload = this.client.core.crypto.decode(topic, message);
            if (jsonrpc_utils_1$1.isJsonRpcRequest(payload)) {
                this.client.history.set(topic, payload);
                this.onRelayEventRequest({ topic, payload });
            }
            else if (jsonrpc_utils_1$1.isJsonRpcResponse(payload)) {
                yield this.client.history.resolve(payload);
                this.onRelayEventResponse({ topic, payload });
            }
        }));
    }
    registerExpirerEvents() {
        this.client.expirer.on(constants_1$6.EXPIRER_EVENTS.expired, (event) => tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            const [type, value] = event.target.split(":");
            if (type === "topic" && typeof value === "string") {
                const topic = value;
                if (this.client.session.keys.includes(topic)) {
                    yield this.deleteSession(topic);
                    this.client.events.emit("session_expire", { topic });
                }
                else if (this.client.pairing.keys.includes(topic)) {
                    yield this.deletePairing(topic);
                    this.client.events.emit("pairing_expire", { topic });
                }
            }
            else if (type === "id" && typeof value === "number") {
                const id = value;
                yield this.deleteProposal(id);
            }
        }));
    }
    isValidPairingTopic(topic) {
        return tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidString(topic, false))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: `pairing topic` });
            if (!this.client.pairing.keys.includes(topic))
                throw utils_1$3.ERROR.NO_MATCHING_TOPIC.format({ context: "pairing", topic });
            if (utils_1$3.isExpired(this.client.pairing.get(topic).expiry)) {
                yield this.deletePairing(topic);
                throw utils_1$3.ERROR.EXPIRED.format({ context: "pairing", topic });
            }
        });
    }
    isValidSessionTopic(topic) {
        return tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (!utils_1$3.isValidString(topic, false))
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: `session topic` });
            if (!this.client.session.keys.includes(topic))
                throw utils_1$3.ERROR.NO_MATCHING_TOPIC.format({ context: "session", topic });
            if (utils_1$3.isExpired(this.client.session.get(topic).expiry)) {
                yield this.deleteSession(topic);
                throw utils_1$3.ERROR.EXPIRED.format({ context: "session", topic });
            }
        });
    }
    isValidSessionOrPairingTopic(topic) {
        return tslib_1$b.__awaiter(this, void 0, void 0, function* () {
            if (this.client.session.keys.includes(topic))
                yield this.isValidSessionTopic(topic);
            else if (this.client.pairing.keys.includes(topic))
                yield this.isValidPairingTopic(topic);
            else
                throw utils_1$3.ERROR.MISSING_OR_INVALID.format({ name: "topic" });
        });
    }
}
Engine_1 = engine$1.Engine = Engine;

var engine = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), engine$1, {
    get Engine () { return Engine_1; },
    'default': engine$1
}));

var require$$1$j = /*@__PURE__*/getAugmentedNamespace(engine);

var expirer$1 = {};

Object.defineProperty(expirer$1, "__esModule", { value: true });
var Expirer_1 = expirer$1.Expirer = void 0;
const tslib_1$a = require$$0$G;
const heartbeat_1 = require$$1$J;
const logger_1$2 = require$$2$s;
const time_1 = require$$3$q;
const types_1$2 = require$$3$m;
const utils_1$2 = require$$4$d;
const events_1$2 = require$$1$19;
const constants_1$5 = require$$2$e;
class Expirer extends types_1$2.IExpirer {
    constructor(core, logger) {
        super(core, logger);
        this.core = core;
        this.logger = logger;
        this.expirations = new Map();
        this.events = new events_1$2.EventEmitter();
        this.name = constants_1$5.EXPIRER_CONTEXT;
        this.version = constants_1$5.EXPIRER_STORAGE_VERSION;
        this.cached = [];
        this.initialized = false;
        this.storagePrefix = constants_1$5.SIGN_CLIENT_STORAGE_PREFIX;
        this.init = () => tslib_1$a.__awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                this.logger.trace(`Initialized`);
                yield this.restore();
                this.cached.forEach(expiration => this.expirations.set(expiration.target, expiration));
                this.cached = [];
                this.registerEventListeners();
                this.initialized = true;
            }
        });
        this.has = target => {
            try {
                const expiration = this.getExpiration(target);
                return typeof expiration !== "undefined";
            }
            catch (e) {
                return false;
            }
        };
        this.set = (target, expiration) => {
            this.isInitialized();
            this.expirations.set(target, expiration);
            this.checkExpiry(target, expiration);
            this.events.emit(constants_1$5.EXPIRER_EVENTS.created, {
                target,
                expiration,
            });
        };
        this.get = target => {
            this.isInitialized();
            return this.getExpiration(target);
        };
        this.del = (target) => tslib_1$a.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            const exists = yield this.has(target);
            if (exists) {
                const expiration = this.getExpiration(target);
                this.expirations.delete(target);
                this.events.emit(constants_1$5.EXPIRER_EVENTS.deleted, {
                    target,
                    expiration,
                });
            }
        });
        this.on = (event, listener) => {
            this.events.on(event, listener);
        };
        this.once = (event, listener) => {
            this.events.once(event, listener);
        };
        this.off = (event, listener) => {
            this.events.off(event, listener);
        };
        this.removeListener = (event, listener) => {
            this.events.removeListener(event, listener);
        };
        this.core;
        this.logger = logger_1$2.generateChildLogger(logger, this.name);
    }
    get context() {
        return logger_1$2.getLoggerContext(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
    }
    get length() {
        return this.expirations.size;
    }
    get keys() {
        return Array.from(this.expirations.keys());
    }
    get values() {
        return Array.from(this.expirations.values());
    }
    setExpirations(expirations) {
        return tslib_1$a.__awaiter(this, void 0, void 0, function* () {
            yield this.core.storage.setItem(this.storageKey, expirations);
        });
    }
    getExpirations() {
        return tslib_1$a.__awaiter(this, void 0, void 0, function* () {
            const expirations = yield this.core.storage.getItem(this.storageKey);
            return expirations;
        });
    }
    persist() {
        return tslib_1$a.__awaiter(this, void 0, void 0, function* () {
            yield this.setExpirations(this.values);
            this.events.emit(constants_1$5.EXPIRER_EVENTS.sync);
        });
    }
    restore() {
        return tslib_1$a.__awaiter(this, void 0, void 0, function* () {
            try {
                const persisted = yield this.getExpirations();
                if (typeof persisted === "undefined")
                    return;
                if (!persisted.length)
                    return;
                if (this.expirations.size) {
                    const error = utils_1$2.ERROR.RESTORE_WILL_OVERRIDE.format({
                        context: this.name,
                    });
                    this.logger.error(error.message);
                    throw new Error(error.message);
                }
                this.cached = persisted;
                this.logger.debug(`Successfully Restored expirations for ${this.name}`);
                this.logger.trace({ type: "method", method: "restore", expirations: this.values });
            }
            catch (e) {
                this.logger.debug(`Failed to Restore expirations for ${this.name}`);
                this.logger.error(e);
            }
        });
    }
    getExpiration(target) {
        const expiration = this.expirations.get(target);
        if (!expiration) {
            const error = utils_1$2.ERROR.NO_MATCHING_ID.format({
                context: this.name,
                target,
            });
            throw new Error(error.message);
        }
        return expiration;
    }
    checkExpiry(target, expiration) {
        const { expiry } = expiration;
        const msToTimeout = time_1.toMiliseconds(expiry) - Date.now();
        if (msToTimeout <= 0)
            this.expire(target, expiration);
    }
    expire(target, expiration) {
        this.expirations.delete(target);
        this.events.emit(constants_1$5.EXPIRER_EVENTS.expired, {
            target,
            expiration,
        });
    }
    checkExpirations() {
        this.expirations.forEach((expiration, target) => this.checkExpiry(target, expiration));
    }
    registerEventListeners() {
        this.core.heartbeat.on(heartbeat_1.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());
        this.events.on(constants_1$5.EXPIRER_EVENTS.created, (createdEvent) => {
            const eventName = constants_1$5.EXPIRER_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: createdEvent });
            this.persist();
        });
        this.events.on(constants_1$5.EXPIRER_EVENTS.expired, (expiredEvent) => {
            const eventName = constants_1$5.EXPIRER_EVENTS.expired;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: expiredEvent });
            this.persist();
        });
        this.events.on(constants_1$5.EXPIRER_EVENTS.deleted, (deletedEvent) => {
            const eventName = constants_1$5.EXPIRER_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
            this.persist();
        });
    }
    isInitialized() {
        if (!this.initialized) {
            throw new Error(utils_1$2.ERROR.NOT_INITIALIZED.stringify(this.name));
        }
    }
}
Expirer_1 = expirer$1.Expirer = Expirer;

var expirer = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), expirer$1, {
    get Expirer () { return Expirer_1; },
    'default': expirer$1
}));

var require$$2$d = /*@__PURE__*/getAugmentedNamespace(expirer);

var history$1 = {};

Object.defineProperty(history$1, "__esModule", { value: true });
var JsonRpcHistory_1 = history$1.JsonRpcHistory = void 0;
const tslib_1$9 = require$$0$G;
const jsonrpc_utils_1 = require$$2$g;
const logger_1$1 = require$$2$s;
const types_1$1 = require$$3$m;
const utils_1$1 = require$$4$d;
const events_1$1 = require$$1$19;
const constants_1$4 = require$$2$e;
class JsonRpcHistory extends types_1$1.IJsonRpcHistory {
    constructor(core, logger) {
        super(core, logger);
        this.core = core;
        this.logger = logger;
        this.records = new Map();
        this.events = new events_1$1.EventEmitter();
        this.name = constants_1$4.HISTORY_CONTEXT;
        this.version = constants_1$4.HISTORY_STORAGE_VERSION;
        this.cached = [];
        this.initialized = false;
        this.storagePrefix = constants_1$4.SIGN_CLIENT_STORAGE_PREFIX;
        this.init = () => tslib_1$9.__awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                this.logger.trace(`Initialized`);
                yield this.restore();
                this.cached.forEach(record => this.records.set(record.id, record));
                this.cached = [];
                this.registerEventListeners();
                this.initialized = true;
            }
        });
        this.set = (topic, request, chainId) => {
            this.isInitialized();
            this.logger.debug(`Setting JSON-RPC request history record`);
            this.logger.trace({ type: "method", method: "set", topic, request, chainId });
            if (this.records.has(request.id))
                return;
            const record = {
                id: request.id,
                topic,
                request: { method: request.method, params: request.params || null },
                chainId,
            };
            this.records.set(record.id, record);
            this.events.emit(constants_1$4.HISTORY_EVENTS.created, record);
        };
        this.resolve = (response) => tslib_1$9.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.logger.debug(`Updating JSON-RPC response history record`);
            this.logger.trace({ type: "method", method: "update", response });
            if (!this.records.has(response.id))
                return;
            const record = yield this.getRecord(response.id);
            if (typeof record.response !== "undefined")
                return;
            record.response = jsonrpc_utils_1.isJsonRpcError(response)
                ? { error: response.error }
                : { result: response.result };
            this.records.set(record.id, record);
            this.events.emit(constants_1$4.HISTORY_EVENTS.updated, record);
        });
        this.get = (topic, id) => tslib_1$9.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            this.logger.debug(`Getting record`);
            this.logger.trace({ type: "method", method: "get", topic, id });
            const record = yield this.getRecord(id);
            if (record.topic !== topic) {
                const error = utils_1$1.ERROR.MISMATCHED_TOPIC.format({
                    context: this.name,
                    id,
                });
                throw new Error(error.message);
            }
            return record;
        });
        this.delete = (topic, id) => {
            this.isInitialized();
            this.logger.debug(`Deleting record`);
            this.logger.trace({ type: "method", method: "delete", id });
            this.values.forEach((record) => {
                if (record.topic === topic) {
                    if (typeof id !== "undefined" && record.id !== id)
                        return;
                    this.records.delete(record.id);
                    this.events.emit(constants_1$4.HISTORY_EVENTS.deleted, record);
                }
            });
        };
        this.exists = (topic, id) => tslib_1$9.__awaiter(this, void 0, void 0, function* () {
            this.isInitialized();
            if (!this.records.has(id))
                return false;
            const record = yield this.getRecord(id);
            return record.topic === topic;
        });
        this.on = (event, listener) => {
            this.events.on(event, listener);
        };
        this.once = (event, listener) => {
            this.events.once(event, listener);
        };
        this.off = (event, listener) => {
            this.events.off(event, listener);
        };
        this.removeListener = (event, listener) => {
            this.events.removeListener(event, listener);
        };
        this.logger = logger_1$1.generateChildLogger(logger, this.name);
    }
    get context() {
        return logger_1$1.getLoggerContext(this.logger);
    }
    get storageKey() {
        return this.storagePrefix + this.version + "//" + this.name;
    }
    get size() {
        return this.records.size;
    }
    get keys() {
        return Array.from(this.records.keys());
    }
    get values() {
        return Array.from(this.records.values());
    }
    get pending() {
        const requests = [];
        this.values.forEach(record => {
            if (typeof record.response !== "undefined")
                return;
            const requestEvent = {
                topic: record.topic,
                request: jsonrpc_utils_1.formatJsonRpcRequest(record.request.method, record.request.params, record.id),
                chainId: record.chainId,
            };
            return requests.push(requestEvent);
        });
        return requests;
    }
    setJsonRpcRecords(records) {
        return tslib_1$9.__awaiter(this, void 0, void 0, function* () {
            yield this.core.storage.setItem(this.storageKey, records);
        });
    }
    getJsonRpcRecords() {
        return tslib_1$9.__awaiter(this, void 0, void 0, function* () {
            const records = yield this.core.storage.getItem(this.storageKey);
            return records;
        });
    }
    getRecord(id) {
        this.isInitialized();
        const record = this.records.get(id);
        if (!record) {
            const error = utils_1$1.ERROR.NO_MATCHING_ID.format({
                context: this.name,
                id,
            });
            throw new Error(error.message);
        }
        return record;
    }
    persist() {
        return tslib_1$9.__awaiter(this, void 0, void 0, function* () {
            yield this.setJsonRpcRecords(this.values);
            this.events.emit(constants_1$4.HISTORY_EVENTS.sync);
        });
    }
    restore() {
        return tslib_1$9.__awaiter(this, void 0, void 0, function* () {
            try {
                const persisted = yield this.getJsonRpcRecords();
                if (typeof persisted === "undefined")
                    return;
                if (!persisted.length)
                    return;
                if (this.records.size) {
                    const error = utils_1$1.ERROR.RESTORE_WILL_OVERRIDE.format({
                        context: this.name,
                    });
                    this.logger.error(error.message);
                    throw new Error(error.message);
                }
                this.cached = persisted;
                this.logger.debug(`Successfully Restored records for ${this.name}`);
                this.logger.trace({ type: "method", method: "restore", records: this.values });
            }
            catch (e) {
                this.logger.debug(`Failed to Restore records for ${this.name}`);
                this.logger.error(e);
            }
        });
    }
    registerEventListeners() {
        this.events.on(constants_1$4.HISTORY_EVENTS.created, (record) => {
            const eventName = constants_1$4.HISTORY_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, record });
            this.persist();
        });
        this.events.on(constants_1$4.HISTORY_EVENTS.updated, (record) => {
            const eventName = constants_1$4.HISTORY_EVENTS.updated;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, record });
            this.persist();
        });
        this.events.on(constants_1$4.HISTORY_EVENTS.deleted, (record) => {
            const eventName = constants_1$4.HISTORY_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, record });
            this.persist();
        });
    }
    isInitialized() {
        if (!this.initialized) {
            throw new Error(utils_1$1.ERROR.NOT_INITIALIZED.stringify(this.name));
        }
    }
}
JsonRpcHistory_1 = history$1.JsonRpcHistory = JsonRpcHistory;

var history = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), history$1, {
    get JsonRpcHistory () { return JsonRpcHistory_1; },
    'default': history$1
}));

var require$$3$c = /*@__PURE__*/getAugmentedNamespace(history);

var pairing$1 = {};

Object.defineProperty(pairing$1, "__esModule", { value: true });
var Pairing_1 = pairing$1.Pairing = void 0;
const core_1$3 = require$$1$l;
const constants_1$3 = require$$2$e;
class Pairing extends core_1$3.Store {
    constructor(core, logger) {
        super(core, logger, constants_1$3.PAIRING_CONTEXT, constants_1$3.SIGN_CLIENT_STORAGE_PREFIX);
        this.core = core;
        this.logger = logger;
    }
}
Pairing_1 = pairing$1.Pairing = Pairing;

var pairing = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pairing$1, {
    get Pairing () { return Pairing_1; },
    'default': pairing$1
}));

var require$$4$9 = /*@__PURE__*/getAugmentedNamespace(pairing);

var proposal$1 = {};

Object.defineProperty(proposal$1, "__esModule", { value: true });
var Proposal_1 = proposal$1.Proposal = void 0;
const core_1$2 = require$$1$l;
const constants_1$2 = require$$2$e;
class Proposal extends core_1$2.Store {
    constructor(core, logger) {
        super(core, logger, constants_1$2.PROPOSAL_CONTEXT, constants_1$2.SIGN_CLIENT_STORAGE_PREFIX);
        this.core = core;
        this.logger = logger;
    }
}
Proposal_1 = proposal$1.Proposal = Proposal;

var proposal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), proposal$1, {
    get Proposal () { return Proposal_1; },
    'default': proposal$1
}));

var require$$5$7 = /*@__PURE__*/getAugmentedNamespace(proposal);

var session$3 = {};

Object.defineProperty(session$3, "__esModule", { value: true });
var Session_1 = session$3.Session = void 0;
const core_1$1 = require$$1$l;
const constants_1$1 = require$$2$e;
class Session extends core_1$1.Store {
    constructor(core, logger) {
        super(core, logger, constants_1$1.SESSION_CONTEXT, constants_1$1.SIGN_CLIENT_STORAGE_PREFIX);
        this.core = core;
        this.logger = logger;
    }
}
Session_1 = session$3.Session = Session;

var session$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), session$3, {
    get Session () { return Session_1; },
    'default': session$3
}));

var require$$6$5 = /*@__PURE__*/getAugmentedNamespace(session$2);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$j, exports);
tslib_1.__exportStar(require$$2$d, exports);
tslib_1.__exportStar(require$$3$c, exports);
tslib_1.__exportStar(require$$4$9, exports);
tslib_1.__exportStar(require$$5$7, exports);
tslib_1.__exportStar(require$$6$5, exports);

}(controllers$1));

var index$4 = /*@__PURE__*/getDefaultExportFromCjs(controllers$1);

var controllers = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), controllers$1, {
    'default': index$4
}));

var require$$8$3 = /*@__PURE__*/getAugmentedNamespace(controllers);

Object.defineProperty(client$6, "__esModule", { value: true });
var SignClient_1 = client$6.SignClient = void 0;
const tslib_1$8 = require$$0$G;
const core_1 = require$$1$l;
const logger_1 = require$$2$s;
const types_1 = require$$3$m;
const utils_1 = require$$4$d;
const events_1 = require$$1$19;
const pino_1 = tslib_1$8.__importDefault(require$$6$e);
const constants_1 = require$$2$e;
const controllers_1 = require$$8$3;
class SignClient extends types_1.ISignClient {
    constructor(opts) {
        super(opts);
        this.protocol = constants_1.SIGN_CLIENT_PROTOCOL;
        this.version = constants_1.SIGN_CLIENT_VERSION;
        this.name = constants_1.SIGN_CLIENT_DEFAULT.name;
        this.events = new events_1.EventEmitter();
        this.on = (name, listener) => {
            return this.events.on(name, listener);
        };
        this.once = (name, listener) => {
            return this.events.once(name, listener);
        };
        this.off = (name, listener) => {
            return this.events.off(name, listener);
        };
        this.removeListener = (name, listener) => {
            return this.events.removeListener(name, listener);
        };
        this.connect = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.connect(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.pair = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.pair(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.approve = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.approve(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.reject = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.reject(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.update = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.update(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.extend = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.extend(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.request = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.request(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.respond = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.respond(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.ping = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.ping(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.emit = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.emit(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.disconnect = (params) => tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.engine.disconnect(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        });
        this.find = params => {
            try {
                return this.engine.find(params);
            }
            catch (error) {
                this.logger.error(error.message);
                throw error;
            }
        };
        this.name = (opts === null || opts === void 0 ? void 0 : opts.name) || constants_1.SIGN_CLIENT_DEFAULT.name;
        this.metadata = (opts === null || opts === void 0 ? void 0 : opts.metadata) || utils_1.getAppMetadata();
        const logger = typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "undefined" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "string"
            ? opts.logger
            : pino_1.default(logger_1.getDefaultLoggerOptions({ level: (opts === null || opts === void 0 ? void 0 : opts.logger) || constants_1.SIGN_CLIENT_DEFAULT.logger }));
        this.core = (opts === null || opts === void 0 ? void 0 : opts.core) || new core_1.Core(opts);
        this.logger = logger_1.generateChildLogger(logger, this.name);
        this.pairing = new controllers_1.Pairing(this.core, this.logger);
        this.session = new controllers_1.Session(this.core, this.logger);
        this.proposal = new controllers_1.Proposal(this.core, this.logger);
        this.history = new controllers_1.JsonRpcHistory(this.core, this.logger);
        this.expirer = new controllers_1.Expirer(this.core, this.logger);
        this.engine = new controllers_1.Engine(this);
    }
    static init(opts) {
        return tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            const client = new SignClient(opts);
            yield client.initialize();
            return client;
        });
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    initialize() {
        return tslib_1$8.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            try {
                yield this.core.start();
                yield this.pairing.init();
                yield this.session.init();
                yield this.proposal.init();
                yield this.history.init();
                yield this.expirer.init();
                yield this.engine.init();
                this.logger.info(`SignClient Initilization Success`);
            }
            catch (error) {
                this.logger.info(`SignClient Initilization Failure`);
                this.logger.error(error.message);
                throw error;
            }
        });
    }
}
SignClient_1 = client$6.SignClient = SignClient;

var client = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), client$6, {
    get SignClient () { return SignClient_1; },
    'default': client$6
}));

var require$$1$i = /*@__PURE__*/getAugmentedNamespace(client);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignClient = void 0;
const tslib_1 = require$$0$G;
const client_1 = require$$1$i;
tslib_1.__exportStar(require$$2$e, exports);
exports.SignClient = client_1.SignClient;
exports.default = client_1.SignClient;

}(cjs$q));

var Client = /*@__PURE__*/getDefaultExportFromCjs(cjs$q);

var cjs$4 = {};

var encoding$4 = {};

Object.defineProperty(encoding$4, "__esModule", { value: true });
var convertNumberToHex_1 = encoding$4.convertNumberToHex = convertNumberToUtf8_1 = encoding$4.convertNumberToUtf8 = convertNumberToArrayBuffer_1 = encoding$4.convertNumberToArrayBuffer = convertNumberToBuffer_1 = encoding$4.convertNumberToBuffer = convertHexToNumber_1 = encoding$4.convertHexToNumber = convertHexToUtf8_1 = encoding$4.convertHexToUtf8 = convertHexToArrayBuffer_1 = encoding$4.convertHexToArrayBuffer = convertHexToBuffer_1 = encoding$4.convertHexToBuffer = convertUtf8ToNumber_1 = encoding$4.convertUtf8ToNumber = convertUtf8ToHex_1 = encoding$4.convertUtf8ToHex = convertUtf8ToBuffer_1 = encoding$4.convertUtf8ToBuffer = convertUtf8ToArrayBuffer_1 = encoding$4.convertUtf8ToArrayBuffer = concatBuffers_1 = encoding$4.concatBuffers = convertBufferToNumber_1 = encoding$4.convertBufferToNumber = convertBufferToHex_1 = encoding$4.convertBufferToHex = convertBufferToUtf8_1 = encoding$4.convertBufferToUtf8 = convertBufferToArrayBuffer_1 = encoding$4.convertBufferToArrayBuffer = concatArrayBuffers_1 = encoding$4.concatArrayBuffers = convertArrayBufferToNumber_1 = encoding$4.convertArrayBufferToNumber = convertArrayBufferToHex_1 = encoding$4.convertArrayBufferToHex = convertArrayBufferToUtf8_1 = encoding$4.convertArrayBufferToUtf8 = convertArrayBufferToBuffer_1 = encoding$4.convertArrayBufferToBuffer = void 0;
const tslib_1$7 = require$$0$G;
const encoding$2 = tslib_1$7.__importStar(require$$1$r);
function convertArrayBufferToBuffer(arrBuf) {
    return encoding$2.arrayToBuffer(new Uint8Array(arrBuf));
}
var convertArrayBufferToBuffer_1 = encoding$4.convertArrayBufferToBuffer = convertArrayBufferToBuffer;
function convertArrayBufferToUtf8(arrBuf) {
    return encoding$2.arrayToUtf8(new Uint8Array(arrBuf));
}
var convertArrayBufferToUtf8_1 = encoding$4.convertArrayBufferToUtf8 = convertArrayBufferToUtf8;
function convertArrayBufferToHex(arrBuf, noPrefix) {
    return encoding$2.arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
var convertArrayBufferToHex_1 = encoding$4.convertArrayBufferToHex = convertArrayBufferToHex;
function convertArrayBufferToNumber(arrBuf) {
    return encoding$2.arrayToNumber(new Uint8Array(arrBuf));
}
var convertArrayBufferToNumber_1 = encoding$4.convertArrayBufferToNumber = convertArrayBufferToNumber;
function concatArrayBuffers(...args) {
    return encoding$2.hexToArray(args.map(b => encoding$2.arrayToHex(new Uint8Array(b))).join("")).buffer;
}
var concatArrayBuffers_1 = encoding$4.concatArrayBuffers = concatArrayBuffers;
function convertBufferToArrayBuffer(buf) {
    return encoding$2.bufferToArray(buf).buffer;
}
var convertBufferToArrayBuffer_1 = encoding$4.convertBufferToArrayBuffer = convertBufferToArrayBuffer;
function convertBufferToUtf8(buf) {
    return encoding$2.bufferToUtf8(buf);
}
var convertBufferToUtf8_1 = encoding$4.convertBufferToUtf8 = convertBufferToUtf8;
function convertBufferToHex(buf, noPrefix) {
    return encoding$2.bufferToHex(buf, !noPrefix);
}
var convertBufferToHex_1 = encoding$4.convertBufferToHex = convertBufferToHex;
function convertBufferToNumber(buf) {
    return encoding$2.bufferToNumber(buf);
}
var convertBufferToNumber_1 = encoding$4.convertBufferToNumber = convertBufferToNumber;
function concatBuffers(...args) {
    return encoding$2.concatBuffers(...args);
}
var concatBuffers_1 = encoding$4.concatBuffers = concatBuffers;
function convertUtf8ToArrayBuffer(utf8) {
    return encoding$2.utf8ToArray(utf8).buffer;
}
var convertUtf8ToArrayBuffer_1 = encoding$4.convertUtf8ToArrayBuffer = convertUtf8ToArrayBuffer;
function convertUtf8ToBuffer(utf8) {
    return encoding$2.utf8ToBuffer(utf8);
}
var convertUtf8ToBuffer_1 = encoding$4.convertUtf8ToBuffer = convertUtf8ToBuffer;
function convertUtf8ToHex(utf8, noPrefix) {
    return encoding$2.utf8ToHex(utf8, !noPrefix);
}
var convertUtf8ToHex_1 = encoding$4.convertUtf8ToHex = convertUtf8ToHex;
function convertUtf8ToNumber(utf8) {
    return encoding$2.utf8ToNumber(utf8);
}
var convertUtf8ToNumber_1 = encoding$4.convertUtf8ToNumber = convertUtf8ToNumber;
function convertHexToBuffer(hex) {
    return encoding$2.hexToBuffer(hex);
}
var convertHexToBuffer_1 = encoding$4.convertHexToBuffer = convertHexToBuffer;
function convertHexToArrayBuffer(hex) {
    return encoding$2.hexToArray(hex).buffer;
}
var convertHexToArrayBuffer_1 = encoding$4.convertHexToArrayBuffer = convertHexToArrayBuffer;
function convertHexToUtf8(hex) {
    return encoding$2.hexToUtf8(hex);
}
var convertHexToUtf8_1 = encoding$4.convertHexToUtf8 = convertHexToUtf8;
function convertHexToNumber(hex) {
    return encoding$2.hexToNumber(hex);
}
var convertHexToNumber_1 = encoding$4.convertHexToNumber = convertHexToNumber;
function convertNumberToBuffer(num) {
    return encoding$2.numberToBuffer(num);
}
var convertNumberToBuffer_1 = encoding$4.convertNumberToBuffer = convertNumberToBuffer;
function convertNumberToArrayBuffer(num) {
    return encoding$2.numberToArray(num).buffer;
}
var convertNumberToArrayBuffer_1 = encoding$4.convertNumberToArrayBuffer = convertNumberToArrayBuffer;
function convertNumberToUtf8(num) {
    return encoding$2.numberToUtf8(num);
}
var convertNumberToUtf8_1 = encoding$4.convertNumberToUtf8 = convertNumberToUtf8;
function convertNumberToHex(num, noPrefix) {
    return encoding$2.numberToHex(Number(num), !noPrefix);
}
convertNumberToHex_1 = encoding$4.convertNumberToHex = convertNumberToHex;

var encoding$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), encoding$4, {
    get convertNumberToHex () { return convertNumberToHex_1; },
    get convertNumberToUtf8 () { return convertNumberToUtf8_1; },
    get convertNumberToArrayBuffer () { return convertNumberToArrayBuffer_1; },
    get convertNumberToBuffer () { return convertNumberToBuffer_1; },
    get convertHexToNumber () { return convertHexToNumber_1; },
    get convertHexToUtf8 () { return convertHexToUtf8_1; },
    get convertHexToArrayBuffer () { return convertHexToArrayBuffer_1; },
    get convertHexToBuffer () { return convertHexToBuffer_1; },
    get convertUtf8ToNumber () { return convertUtf8ToNumber_1; },
    get convertUtf8ToHex () { return convertUtf8ToHex_1; },
    get convertUtf8ToBuffer () { return convertUtf8ToBuffer_1; },
    get convertUtf8ToArrayBuffer () { return convertUtf8ToArrayBuffer_1; },
    get concatBuffers () { return concatBuffers_1; },
    get convertBufferToNumber () { return convertBufferToNumber_1; },
    get convertBufferToHex () { return convertBufferToHex_1; },
    get convertBufferToUtf8 () { return convertBufferToUtf8_1; },
    get convertBufferToArrayBuffer () { return convertBufferToArrayBuffer_1; },
    get concatArrayBuffers () { return concatArrayBuffers_1; },
    get convertArrayBufferToNumber () { return convertArrayBufferToNumber_1; },
    get convertArrayBufferToHex () { return convertArrayBufferToHex_1; },
    get convertArrayBufferToUtf8 () { return convertArrayBufferToUtf8_1; },
    get convertArrayBufferToBuffer () { return convertArrayBufferToBuffer_1; },
    'default': encoding$4
}));

var require$$1$h = /*@__PURE__*/getAugmentedNamespace(encoding$3);

var env$1 = {};

var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = 'browser';
    }
    return BrowserInfo;
}());
var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.type = 'node';
        this.name = 'node';
        this.os = browser$1$1.platform;
    }
    return NodeInfo;
}());
var SearchBotDeviceInfo = /** @class */ (function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = 'bot-device';
    }
    return SearchBotDeviceInfo;
}());
var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.type = 'bot';
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());
var ReactNativeInfo = /** @class */ (function () {
    function ReactNativeInfo() {
        this.type = 'react-native';
        this.name = 'react-native';
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}());
// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /EdgA?\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    ['pie', /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
    ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FB[AS]V\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['curl', /^curl\/([0-9\.]+)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof document === 'undefined' &&
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative') {
        return new ReactNativeInfo();
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return (ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false));
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)
    var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
        }
    }
    else {
        versionParts = [];
    }
    var version = versionParts.join('.');
    var os = detectOS$1(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
}
function detectOS$1(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof browser$1$1 !== 'undefined' && browser$1$1.version;
    return isNode ? new NodeInfo(browser$1$1.version.slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}

var es$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BrowserInfo: BrowserInfo,
    NodeInfo: NodeInfo,
    SearchBotDeviceInfo: SearchBotDeviceInfo,
    BotInfo: BotInfo,
    ReactNativeInfo: ReactNativeInfo,
    detect: detect,
    browserName: browserName,
    parseUserAgent: parseUserAgent,
    detectOS: detectOS$1,
    getNodeVersion: getNodeVersion
});

var require$$0$b = /*@__PURE__*/getAugmentedNamespace(es$1);

var window$2 = {};

Object.defineProperty(window$2, "__esModule", { value: true });
var getLocalStorage = window$2.getLocalStorage = getLocalStorageOrThrow = window$2.getLocalStorageOrThrow = getCrypto = window$2.getCrypto = getCryptoOrThrow = window$2.getCryptoOrThrow = getLocation = window$2.getLocation = getLocationOrThrow = window$2.getLocationOrThrow = getNavigator = window$2.getNavigator = getNavigatorOrThrow = window$2.getNavigatorOrThrow = getDocument = window$2.getDocument = getDocumentOrThrow = window$2.getDocumentOrThrow = getFromWindowOrThrow = window$2.getFromWindowOrThrow = getFromWindow = window$2.getFromWindow = void 0;
const tslib_1$6 = require$$0$G;
const windowGetters = tslib_1$6.__importStar(require$$1$v);
var getFromWindow = window$2.getFromWindow = windowGetters.getFromWindow;
var getFromWindowOrThrow = window$2.getFromWindowOrThrow = windowGetters.getFromWindowOrThrow;
var getDocumentOrThrow = window$2.getDocumentOrThrow = windowGetters.getDocumentOrThrow;
var getDocument = window$2.getDocument = windowGetters.getDocument;
var getNavigatorOrThrow = window$2.getNavigatorOrThrow = windowGetters.getNavigatorOrThrow;
var getNavigator = window$2.getNavigator = windowGetters.getNavigator;
var getLocationOrThrow = window$2.getLocationOrThrow = windowGetters.getLocationOrThrow;
var getLocation = window$2.getLocation = windowGetters.getLocation;
var getCryptoOrThrow = window$2.getCryptoOrThrow = windowGetters.getCryptoOrThrow;
var getCrypto = window$2.getCrypto = windowGetters.getCrypto;
var getLocalStorageOrThrow = window$2.getLocalStorageOrThrow = windowGetters.getLocalStorageOrThrow;
getLocalStorage = window$2.getLocalStorage = windowGetters.getLocalStorage;

var window$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), window$2, {
    get getLocalStorage () { return getLocalStorage; },
    get getLocalStorageOrThrow () { return getLocalStorageOrThrow; },
    get getCrypto () { return getCrypto; },
    get getCryptoOrThrow () { return getCryptoOrThrow; },
    get getLocation () { return getLocation; },
    get getLocationOrThrow () { return getLocationOrThrow; },
    get getNavigator () { return getNavigator; },
    get getNavigatorOrThrow () { return getNavigatorOrThrow; },
    get getDocument () { return getDocument; },
    get getDocumentOrThrow () { return getDocumentOrThrow; },
    get getFromWindowOrThrow () { return getFromWindowOrThrow; },
    get getFromWindow () { return getFromWindow; },
    'default': window$2
}));

var require$$13$1 = /*@__PURE__*/getAugmentedNamespace(window$1);

Object.defineProperty(env$1, "__esModule", { value: true });
var isBrowser_1 = env$1.isBrowser = isNode_1 = env$1.isNode = isMobile_1 = env$1.isMobile = isIOS_1 = env$1.isIOS = isAndroid_1 = env$1.isAndroid = detectOS_1 = env$1.detectOS = detectEnv_1 = env$1.detectEnv = void 0;
const detect_browser_1 = require$$0$b;
const window_1$1 = require$$13$1;
function detectEnv(userAgent) {
    return detect_browser_1.detect(userAgent);
}
var detectEnv_1 = env$1.detectEnv = detectEnv;
function detectOS() {
    const env = detectEnv();
    return env && env.os ? env.os : undefined;
}
var detectOS_1 = env$1.detectOS = detectOS;
function isAndroid() {
    const os = detectOS();
    return os ? os.toLowerCase().includes("android") : false;
}
var isAndroid_1 = env$1.isAndroid = isAndroid;
function isIOS() {
    const os = detectOS();
    return os
        ? os.toLowerCase().includes("ios") ||
            (os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1)
        : false;
}
var isIOS_1 = env$1.isIOS = isIOS;
function isMobile() {
    const os = detectOS();
    return os ? isAndroid() || isIOS() : false;
}
var isMobile_1 = env$1.isMobile = isMobile;
function isNode$1() {
    const env = detectEnv();
    const result = env && env.name ? env.name.toLowerCase() === "node" : false;
    return result;
}
var isNode_1 = env$1.isNode = isNode$1;
function isBrowser() {
    const result = !isNode$1() && !!window_1$1.getNavigator();
    return result;
}
isBrowser_1 = env$1.isBrowser = isBrowser;

var env = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), env$1, {
    get isBrowser () { return isBrowser_1; },
    get isNode () { return isNode_1; },
    get isMobile () { return isMobile_1; },
    get isIOS () { return isIOS_1; },
    get isAndroid () { return isAndroid_1; },
    get detectOS () { return detectOS_1; },
    get detectEnv () { return detectEnv_1; },
    'default': env$1
}));

var require$$2$c = /*@__PURE__*/getAugmentedNamespace(env);

var json$1 = {};

Object.defineProperty(json$1, "__esModule", { value: true });
var safeJsonStringify = json$1.safeJsonStringify = safeJsonParse = json$1.safeJsonParse = void 0;
const tslib_1$5 = require$$0$G;
const safeJson = tslib_1$5.__importStar(require$$1$q);
var safeJsonParse = json$1.safeJsonParse = safeJson.safeJsonParse;
safeJsonStringify = json$1.safeJsonStringify = safeJson.safeJsonStringify;

var json = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), json$1, {
    get safeJsonStringify () { return safeJsonStringify; },
    get safeJsonParse () { return safeJsonParse; },
    'default': json$1
}));

var require$$3$b = /*@__PURE__*/getAugmentedNamespace(json);

var local$1 = {};

Object.defineProperty(local$1, "__esModule", { value: true });
var removeLocal_1 = local$1.removeLocal = getLocal_1 = local$1.getLocal = setLocal_1 = local$1.setLocal = void 0;
const json_1 = require$$3$b;
const window_1 = require$$13$1;
function setLocal(key, data) {
    const raw = json_1.safeJsonStringify(data);
    const local = window_1.getLocalStorage();
    if (local) {
        local.setItem(key, raw);
    }
}
var setLocal_1 = local$1.setLocal = setLocal;
function getLocal(key) {
    let data = null;
    let raw = null;
    const local = window_1.getLocalStorage();
    if (local) {
        raw = local.getItem(key);
    }
    data = raw ? json_1.safeJsonParse(raw) : raw;
    return data;
}
var getLocal_1 = local$1.getLocal = getLocal;
function removeLocal(key) {
    const local = window_1.getLocalStorage();
    if (local) {
        local.removeItem(key);
    }
}
removeLocal_1 = local$1.removeLocal = removeLocal;

var local = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), local$1, {
    get removeLocal () { return removeLocal_1; },
    get getLocal () { return getLocal_1; },
    get setLocal () { return setLocal_1; },
    'default': local$1
}));

var require$$4$8 = /*@__PURE__*/getAugmentedNamespace(local);

var meta$1 = {};

Object.defineProperty(meta$1, "__esModule", { value: true });
var getClientMeta_1 = meta$1.getClientMeta = void 0;
const tslib_1$4 = require$$0$G;
const windowMetadata = tslib_1$4.__importStar(require$$1$u);
function getClientMeta() {
    return windowMetadata.getWindowMetadata();
}
getClientMeta_1 = meta$1.getClientMeta = getClientMeta;

var meta = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), meta$1, {
    get getClientMeta () { return getClientMeta_1; },
    'default': meta$1
}));

var require$$5$6 = /*@__PURE__*/getAugmentedNamespace(meta);

var misc$1 = {};

var cjs$3 = {};

var crypto$1 = {};

Object.defineProperty(crypto$1, "__esModule", { value: true });

var crypto = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), crypto$1, {
    'default': crypto$1
}));

var require$$1$g = /*@__PURE__*/getAugmentedNamespace(crypto);

var constants$8 = {};

var errors$1 = {};

Object.defineProperty(errors$1, "__esModule", { value: true });
var ERROR_QRCODE_MODAL_USER_CLOSED = errors$1.ERROR_QRCODE_MODAL_USER_CLOSED = ERROR_QRCODE_MODAL_NOT_PROVIDED = errors$1.ERROR_QRCODE_MODAL_NOT_PROVIDED = ERROR_INVALID_URI = errors$1.ERROR_INVALID_URI = ERROR_INVALID_RESPONSE = errors$1.ERROR_INVALID_RESPONSE = ERROR_MISSING_REQUIRED = errors$1.ERROR_MISSING_REQUIRED = ERROR_MISSING_ID = errors$1.ERROR_MISSING_ID = ERROR_MISSING_METHOD = errors$1.ERROR_MISSING_METHOD = ERROR_MISSING_ERROR = errors$1.ERROR_MISSING_ERROR = ERROR_MISSING_RESULT = errors$1.ERROR_MISSING_RESULT = ERROR_MISSING_JSON_RPC = errors$1.ERROR_MISSING_JSON_RPC = ERROR_SESSION_REJECTED = errors$1.ERROR_SESSION_REJECTED = ERROR_SESSION_DISCONNECTED = errors$1.ERROR_SESSION_DISCONNECTED = ERROR_SESSION_CONNECTED = errors$1.ERROR_SESSION_CONNECTED = void 0;
var ERROR_SESSION_CONNECTED = errors$1.ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = errors$1.ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = errors$1.ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = errors$1.ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = errors$1.ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = errors$1.ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = errors$1.ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = errors$1.ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = errors$1.ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = errors$1.ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = errors$1.ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = errors$1.ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
ERROR_QRCODE_MODAL_USER_CLOSED = errors$1.ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

var errors = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), errors$1, {
    get ERROR_QRCODE_MODAL_USER_CLOSED () { return ERROR_QRCODE_MODAL_USER_CLOSED; },
    get ERROR_QRCODE_MODAL_NOT_PROVIDED () { return ERROR_QRCODE_MODAL_NOT_PROVIDED; },
    get ERROR_INVALID_URI () { return ERROR_INVALID_URI; },
    get ERROR_INVALID_RESPONSE () { return ERROR_INVALID_RESPONSE; },
    get ERROR_MISSING_REQUIRED () { return ERROR_MISSING_REQUIRED; },
    get ERROR_MISSING_ID () { return ERROR_MISSING_ID; },
    get ERROR_MISSING_METHOD () { return ERROR_MISSING_METHOD; },
    get ERROR_MISSING_ERROR () { return ERROR_MISSING_ERROR; },
    get ERROR_MISSING_RESULT () { return ERROR_MISSING_RESULT; },
    get ERROR_MISSING_JSON_RPC () { return ERROR_MISSING_JSON_RPC; },
    get ERROR_SESSION_REJECTED () { return ERROR_SESSION_REJECTED; },
    get ERROR_SESSION_DISCONNECTED () { return ERROR_SESSION_DISCONNECTED; },
    get ERROR_SESSION_CONNECTED () { return ERROR_SESSION_CONNECTED; },
    'default': errors$1
}));

var require$$1$f = /*@__PURE__*/getAugmentedNamespace(errors);

var events$4 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.reservedEvents = exports.RESERVED_EVENTS = void 0;
exports.RESERVED_EVENTS = [
    "session_request",
    "session_update",
    "exchange_key",
    "connect",
    "disconnect",
    "display_uri",
    "modal_closed",
    "transport_open",
    "transport_close",
    "transport_error",
];
exports.reservedEvents = exports.RESERVED_EVENTS;

}(events$4));

var events$2 = /*@__PURE__*/getDefaultExportFromCjs(events$4);

var events$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), events$4, {
    'default': events$2
}));

var require$$2$b = /*@__PURE__*/getAugmentedNamespace(events$3);

var jsonrpc$4 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.stateMethods = exports.STATE_METHODS = exports.signingMethods = exports.SIGNING_METHODS = exports.WALLET_METHODS = void 0;
exports.WALLET_METHODS = [
    "wallet_addEthereumChain",
    "wallet_switchEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
];
exports.SIGNING_METHODS = [
    "eth_sendTransaction",
    "eth_signTransaction",
    "eth_sign",
    "eth_signTypedData",
    "eth_signTypedData_v1",
    "eth_signTypedData_v2",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "personal_sign",
    ...exports.WALLET_METHODS,
];
exports.signingMethods = exports.SIGNING_METHODS;
exports.STATE_METHODS = ["eth_accounts", "eth_chainId", "net_version"];
exports.stateMethods = exports.STATE_METHODS;

}(jsonrpc$4));

var jsonrpc$2 = /*@__PURE__*/getDefaultExportFromCjs(jsonrpc$4);

var jsonrpc$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), jsonrpc$4, {
    'default': jsonrpc$2
}));

var require$$3$a = /*@__PURE__*/getAugmentedNamespace(jsonrpc$3);

var mobile$4 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.mobileLinkChoiceKey = exports.MOBILE_LINK_CHOICE_KEY = void 0;
exports.MOBILE_LINK_CHOICE_KEY = "WALLETCONNECT_DEEPLINK_CHOICE";
exports.mobileLinkChoiceKey = exports.MOBILE_LINK_CHOICE_KEY;

}(mobile$4));

var mobile$2 = /*@__PURE__*/getDefaultExportFromCjs(mobile$4);

var mobile$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), mobile$4, {
    'default': mobile$2
}));

var require$$4$7 = /*@__PURE__*/getAugmentedNamespace(mobile$3);

var networks$2 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.infuraNetworks = exports.INFURA_NETWORKS = void 0;
exports.INFURA_NETWORKS = {
    1: "mainnet",
    3: "ropsten",
    4: "rinkeby",
    5: "goerli",
    42: "kovan",
};
exports.infuraNetworks = exports.INFURA_NETWORKS;

}(networks$2));

var networks = /*@__PURE__*/getDefaultExportFromCjs(networks$2);

var networks$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), networks$2, {
    'default': networks
}));

var require$$5$5 = /*@__PURE__*/getAugmentedNamespace(networks$1);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$f, exports);
tslib_1.__exportStar(require$$2$b, exports);
tslib_1.__exportStar(require$$3$a, exports);
tslib_1.__exportStar(require$$4$7, exports);
tslib_1.__exportStar(require$$5$5, exports);

}(constants$8));

var index$3 = /*@__PURE__*/getDefaultExportFromCjs(constants$8);

var constants$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constants$8, {
    'default': index$3
}));

var require$$2$a = /*@__PURE__*/getAugmentedNamespace(constants$7);

var ethereum$1 = {};

Object.defineProperty(ethereum$1, "__esModule", { value: true });

var ethereum = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), ethereum$1, {
    'default': ethereum$1
}));

var require$$3$9 = /*@__PURE__*/getAugmentedNamespace(ethereum);

var events$1 = {};

Object.defineProperty(events$1, "__esModule", { value: true });
var IEvents_1 = events$1.IEvents = void 0;
class IEvents {
}
IEvents_1 = events$1.IEvents = IEvents;

var events = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), events$1, {
    get IEvents () { return IEvents_1; },
    'default': events$1
}));

var require$$4$6 = /*@__PURE__*/getAugmentedNamespace(events);

var jsonrpc$1 = {};

Object.defineProperty(jsonrpc$1, "__esModule", { value: true });

var jsonrpc = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), jsonrpc$1, {
    'default': jsonrpc$1
}));

var require$$5$4 = /*@__PURE__*/getAugmentedNamespace(jsonrpc);

var network$1 = {};

Object.defineProperty(network$1, "__esModule", { value: true });

var network = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), network$1, {
    'default': network$1
}));

var require$$6$4 = /*@__PURE__*/getAugmentedNamespace(network);

var protocol$1 = {};

Object.defineProperty(protocol$1, "__esModule", { value: true });

var protocol = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), protocol$1, {
    'default': protocol$1
}));

var require$$7$3 = /*@__PURE__*/getAugmentedNamespace(protocol);

var qrcode$3 = {};

Object.defineProperty(qrcode$3, "__esModule", { value: true });

var qrcode$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), qrcode$3, {
    'default': qrcode$3
}));

var require$$8$2 = /*@__PURE__*/getAugmentedNamespace(qrcode$2);

var registry$3 = {};

Object.defineProperty(registry$3, "__esModule", { value: true });

var registry$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), registry$3, {
    'default': registry$3
}));

var require$$9$2 = /*@__PURE__*/getAugmentedNamespace(registry$2);

var socket$1 = {};

Object.defineProperty(socket$1, "__esModule", { value: true });

var socket = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), socket$1, {
    'default': socket$1
}));

var require$$10$2 = /*@__PURE__*/getAugmentedNamespace(socket);

var storage$1 = {};

Object.defineProperty(storage$1, "__esModule", { value: true });

var storage = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), storage$1, {
    'default': storage$1
}));

var require$$11$2 = /*@__PURE__*/getAugmentedNamespace(storage);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$g, exports);
tslib_1.__exportStar(require$$2$a, exports);
tslib_1.__exportStar(require$$3$9, exports);
tslib_1.__exportStar(require$$4$6, exports);
tslib_1.__exportStar(require$$5$4, exports);
tslib_1.__exportStar(require$$6$4, exports);
tslib_1.__exportStar(require$$7$3, exports);
tslib_1.__exportStar(require$$8$2, exports);
tslib_1.__exportStar(require$$9$2, exports);
tslib_1.__exportStar(require$$10$2, exports);
tslib_1.__exportStar(require$$11$2, exports);

}(cjs$3));

var index$2 = /*@__PURE__*/getDefaultExportFromCjs(cjs$3);

var cjs$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$3, {
    'default': index$2
}));

var require$$2$9 = /*@__PURE__*/getAugmentedNamespace(cjs$2);

Object.defineProperty(misc$1, "__esModule", { value: true });
var getRpcUrl_1 = misc$1.getRpcUrl = getInfuraRpcUrl_1 = misc$1.getInfuraRpcUrl = logDeprecationWarning_1 = misc$1.logDeprecationWarning = uuid_1 = misc$1.uuid = payloadId = misc$1.payloadId = removeHexLeadingZeros_1 = misc$1.removeHexLeadingZeros = removeHexPrefix_1 = misc$1.removeHexPrefix = addHexPrefix_1 = misc$1.addHexPrefix = sanitizeHex_1 = misc$1.sanitizeHex = void 0;
const tslib_1$3 = require$$0$G;
const encoding$1 = tslib_1$3.__importStar(require$$1$r);
const jsonRpcUtils = tslib_1$3.__importStar(require$$2$g);
const legacy_types_1$2 = require$$2$9;
function sanitizeHex(hex) {
    return encoding$1.sanitizeHex(hex);
}
var sanitizeHex_1 = misc$1.sanitizeHex = sanitizeHex;
function addHexPrefix(hex) {
    return encoding$1.addHexPrefix(hex);
}
var addHexPrefix_1 = misc$1.addHexPrefix = addHexPrefix;
function removeHexPrefix(hex) {
    return encoding$1.removeHexPrefix(hex);
}
var removeHexPrefix_1 = misc$1.removeHexPrefix = removeHexPrefix;
function removeHexLeadingZeros(hex) {
    return encoding$1.removeHexLeadingZeros(encoding$1.addHexPrefix(hex));
}
var removeHexLeadingZeros_1 = misc$1.removeHexLeadingZeros = removeHexLeadingZeros;
var payloadId = misc$1.payloadId = jsonRpcUtils.payloadId;
function uuid() {
    const result = ((a, b) => {
        for (b = a = ""; a++ < 36; b += (a * 51) & 52 ? (a ^ 15 ? 8 ^ (Math.random() * (a ^ 20 ? 16 : 4)) : 4).toString(16) : "-") {
        }
        return b;
    })();
    return result;
}
var uuid_1 = misc$1.uuid = uuid;
function logDeprecationWarning() {
    console.warn("DEPRECATION WARNING: This WalletConnect client library will be deprecated in favor of @walletconnect/client. Please check docs.walletconnect.org to learn more about this migration!");
}
var logDeprecationWarning_1 = misc$1.logDeprecationWarning = logDeprecationWarning;
function getInfuraRpcUrl(chainId, infuraId) {
    let rpcUrl;
    const network = legacy_types_1$2.INFURA_NETWORKS[chainId];
    if (network) {
        rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
    }
    return rpcUrl;
}
var getInfuraRpcUrl_1 = misc$1.getInfuraRpcUrl = getInfuraRpcUrl;
function getRpcUrl(chainId, rpc) {
    let rpcUrl;
    const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
    if (rpc.custom && rpc.custom[chainId]) {
        rpcUrl = rpc.custom[chainId];
    }
    else if (infuraUrl) {
        rpcUrl = infuraUrl;
    }
    return rpcUrl;
}
getRpcUrl_1 = misc$1.getRpcUrl = getRpcUrl;

var misc = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), misc$1, {
    get getRpcUrl () { return getRpcUrl_1; },
    get getInfuraRpcUrl () { return getInfuraRpcUrl_1; },
    get logDeprecationWarning () { return logDeprecationWarning_1; },
    get uuid () { return uuid_1; },
    get payloadId () { return payloadId; },
    get removeHexLeadingZeros () { return removeHexLeadingZeros_1; },
    get removeHexPrefix () { return removeHexPrefix_1; },
    get addHexPrefix () { return addHexPrefix_1; },
    get sanitizeHex () { return sanitizeHex_1; },
    'default': misc$1
}));

var require$$6$3 = /*@__PURE__*/getAugmentedNamespace(misc);

var mobile$1 = {};

Object.defineProperty(mobile$1, "__esModule", { value: true });
var getMobileLinkRegistry_1 = mobile$1.getMobileLinkRegistry = getMobileRegistryEntry_1 = mobile$1.getMobileRegistryEntry = saveMobileLinkInfo_1 = mobile$1.saveMobileLinkInfo = formatIOSMobile_1 = mobile$1.formatIOSMobile = void 0;
const legacy_types_1$1 = require$$2$9;
const local_1 = require$$4$8;
function formatIOSMobile(uri, entry) {
    const encodedUri = encodeURIComponent(uri);
    return entry.universalLink
        ? `${entry.universalLink}/wc?uri=${encodedUri}`
        : entry.deepLink
            ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}`
            : "";
}
var formatIOSMobile_1 = mobile$1.formatIOSMobile = formatIOSMobile;
function saveMobileLinkInfo(data) {
    const focusUri = data.href.split("?")[0];
    local_1.setLocal(legacy_types_1$1.MOBILE_LINK_CHOICE_KEY, Object.assign(Object.assign({}, data), { href: focusUri }));
}
var saveMobileLinkInfo_1 = mobile$1.saveMobileLinkInfo = saveMobileLinkInfo;
function getMobileRegistryEntry(registry, name) {
    return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
}
var getMobileRegistryEntry_1 = mobile$1.getMobileRegistryEntry = getMobileRegistryEntry;
function getMobileLinkRegistry(registry, whitelist) {
    let links = registry;
    if (whitelist) {
        links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
    }
    return links;
}
getMobileLinkRegistry_1 = mobile$1.getMobileLinkRegistry = getMobileLinkRegistry;

var mobile = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), mobile$1, {
    get getMobileLinkRegistry () { return getMobileLinkRegistry_1; },
    get getMobileRegistryEntry () { return getMobileRegistryEntry_1; },
    get saveMobileLinkInfo () { return saveMobileLinkInfo_1; },
    get formatIOSMobile () { return formatIOSMobile_1; },
    'default': mobile$1
}));

var require$$7$2 = /*@__PURE__*/getAugmentedNamespace(mobile);

var payload$1 = {};

Object.defineProperty(payload$1, "__esModule", { value: true });
var formatRpcError_1 = payload$1.formatRpcError = promisify_1 = payload$1.promisify = void 0;
const tslib_1$2 = require$$0$G;
function promisify(originalFn, thisArg) {
    const promisifiedFunction = (...callArgs) => tslib_1$2.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const callback = (err, data) => {
                if (err === null || typeof err === "undefined") {
                    reject(err);
                }
                resolve(data);
            };
            originalFn.apply(thisArg, [...callArgs, callback]);
        });
    });
    return promisifiedFunction;
}
var promisify_1 = payload$1.promisify = promisify;
function formatRpcError(error) {
    const message = error.message || "Failed or Rejected Request";
    let code = -32000;
    if (error && !error.code) {
        switch (message) {
            case "Parse error":
                code = -32700;
                break;
            case "Invalid request":
                code = -32600;
                break;
            case "Method not found":
                code = -32601;
                break;
            case "Invalid params":
                code = -32602;
                break;
            case "Internal error":
                code = -32603;
                break;
            default:
                code = -32000;
                break;
        }
    }
    const result = {
        code,
        message,
    };
    return result;
}
formatRpcError_1 = payload$1.formatRpcError = formatRpcError;

var payload = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), payload$1, {
    get formatRpcError () { return formatRpcError_1; },
    get promisify () { return promisify_1; },
    'default': payload$1
}));

var require$$8$1 = /*@__PURE__*/getAugmentedNamespace(payload);

var registry$1 = {};

Object.defineProperty(registry$1, "__esModule", { value: true });
var formatMobileRegistry_1 = registry$1.formatMobileRegistry = formatMobileRegistryEntry_1 = registry$1.formatMobileRegistryEntry = getAppLogoUrl_1 = registry$1.getAppLogoUrl = getDappRegistryUrl_1 = registry$1.getDappRegistryUrl = getWalletRegistryUrl_1 = registry$1.getWalletRegistryUrl = void 0;
const API_URL = "https://registry.walletconnect.org";
function getWalletRegistryUrl() {
    return API_URL + "/data/wallets.json";
}
var getWalletRegistryUrl_1 = registry$1.getWalletRegistryUrl = getWalletRegistryUrl;
function getDappRegistryUrl() {
    return API_URL + "/data/dapps.json";
}
var getDappRegistryUrl_1 = registry$1.getDappRegistryUrl = getDappRegistryUrl;
function getAppLogoUrl(id) {
    return API_URL + "/logo/sm/" + id + ".jpeg";
}
var getAppLogoUrl_1 = registry$1.getAppLogoUrl = getAppLogoUrl;
function formatMobileRegistryEntry(entry, platform = "mobile") {
    return {
        name: entry.name || "",
        shortName: entry.metadata.shortName || "",
        color: entry.metadata.colors.primary || "",
        logo: entry.id ? getAppLogoUrl(entry.id) : "",
        universalLink: entry[platform].universal || "",
        deepLink: entry[platform].native || "",
    };
}
var formatMobileRegistryEntry_1 = registry$1.formatMobileRegistryEntry = formatMobileRegistryEntry;
function formatMobileRegistry(registry, platform = "mobile") {
    return Object.values(registry)
        .filter(entry => !!entry[platform].universal || !!entry[platform].native)
        .map(entry => formatMobileRegistryEntry(entry, platform));
}
formatMobileRegistry_1 = registry$1.formatMobileRegistry = formatMobileRegistry;

var registry = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), registry$1, {
    get formatMobileRegistry () { return formatMobileRegistry_1; },
    get formatMobileRegistryEntry () { return formatMobileRegistryEntry_1; },
    get getAppLogoUrl () { return getAppLogoUrl_1; },
    get getDappRegistryUrl () { return getDappRegistryUrl_1; },
    get getWalletRegistryUrl () { return getWalletRegistryUrl_1; },
    'default': registry$1
}));

var require$$9$1 = /*@__PURE__*/getAugmentedNamespace(registry);

var session$1 = {};

var url$1 = {};

Object.defineProperty(url$1, "__esModule", { value: true });
var formatQueryString_1 = url$1.formatQueryString = parseQueryString_1 = url$1.parseQueryString = appendToQueryString_1 = url$1.appendToQueryString = getQueryString_1 = url$1.getQueryString = void 0;
const tslib_1$1 = require$$0$G;
const queryStringUtils = tslib_1$1.__importStar(require$$1$s);
function getQueryString(url) {
    const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : undefined;
    const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
    return queryString;
}
var getQueryString_1 = url$1.getQueryString = getQueryString;
function appendToQueryString(queryString, newQueryParams) {
    let queryParams = parseQueryString(queryString);
    queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
    queryString = formatQueryString(queryParams);
    return queryString;
}
var appendToQueryString_1 = url$1.appendToQueryString = appendToQueryString;
function parseQueryString(queryString) {
    return queryStringUtils.parse(queryString);
}
var parseQueryString_1 = url$1.parseQueryString = parseQueryString;
function formatQueryString(queryParams) {
    return queryStringUtils.stringify(queryParams);
}
formatQueryString_1 = url$1.formatQueryString = formatQueryString;

var url = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), url$1, {
    get formatQueryString () { return formatQueryString_1; },
    get parseQueryString () { return parseQueryString_1; },
    get appendToQueryString () { return appendToQueryString_1; },
    get getQueryString () { return getQueryString_1; },
    'default': url$1
}));

var require$$11$1 = /*@__PURE__*/getAugmentedNamespace(url);

Object.defineProperty(session$1, "__esModule", { value: true });
var parseWalletConnectUri_1 = session$1.parseWalletConnectUri = isWalletConnectSession_1 = session$1.isWalletConnectSession = void 0;
const url_1 = require$$11$1;
function isWalletConnectSession(object) {
    return typeof object.bridge !== "undefined";
}
var isWalletConnectSession_1 = session$1.isWalletConnectSession = isWalletConnectSession;
function parseWalletConnectUri(str) {
    const pathStart = str.indexOf(":");
    const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : undefined;
    const protocol = str.substring(0, pathStart);
    const path = str.substring(pathStart + 1, pathEnd);
    function parseRequiredParams(path) {
        const separator = "@";
        const values = path.split(separator);
        const requiredParams = {
            handshakeTopic: values[0],
            version: parseInt(values[1], 10),
        };
        return requiredParams;
    }
    const requiredParams = parseRequiredParams(path);
    const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
    function parseQueryParams(queryString) {
        const result = url_1.parseQueryString(queryString);
        const parameters = {
            key: result.key || "",
            bridge: result.bridge || "",
        };
        return parameters;
    }
    const queryParams = parseQueryParams(queryString);
    const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
    return result;
}
parseWalletConnectUri_1 = session$1.parseWalletConnectUri = parseWalletConnectUri;

var session = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), session$1, {
    get parseWalletConnectUri () { return parseWalletConnectUri_1; },
    get isWalletConnectSession () { return isWalletConnectSession_1; },
    'default': session$1
}));

var require$$10$1 = /*@__PURE__*/getAugmentedNamespace(session);

var validators$1 = {};

Object.defineProperty(validators$1, "__esModule", { value: true });
var isSilentPayload_1 = validators$1.isSilentPayload = isReservedEvent_1 = validators$1.isReservedEvent = isInternalEvent_1 = validators$1.isInternalEvent = isJsonRpcResponseError_1 = validators$1.isJsonRpcResponseError = isJsonRpcResponseSuccess_1 = validators$1.isJsonRpcResponseSuccess = isJsonRpcRequest_1 = validators$1.isJsonRpcRequest = isJsonRpcSubscription_1 = validators$1.isJsonRpcSubscription = isHexString_1 = validators$1.isHexString = getEncoding_1 = validators$1.getEncoding = getType_1 = validators$1.getType = isArrayBuffer_1 = validators$1.isArrayBuffer = isTypedArray_1 = validators$1.isTypedArray = isBuffer_1 = validators$1.isBuffer = isEmptyArray_1 = validators$1.isEmptyArray = isEmptyString_1 = validators$1.isEmptyString = void 0;
const tslib_1 = require$$0$G;
const encoding = tslib_1.__importStar(require$$1$r);
const legacy_types_1 = require$$2$9;
function isEmptyString(value) {
    return value === "" || (typeof value === "string" && value.trim() === "");
}
var isEmptyString_1 = validators$1.isEmptyString = isEmptyString;
function isEmptyArray(array) {
    return !(array && array.length);
}
var isEmptyArray_1 = validators$1.isEmptyArray = isEmptyArray;
function isBuffer(val) {
    return encoding.isBuffer(val);
}
var isBuffer_1 = validators$1.isBuffer = isBuffer;
function isTypedArray(val) {
    return encoding.isTypedArray(val);
}
var isTypedArray_1 = validators$1.isTypedArray = isTypedArray;
function isArrayBuffer$1(val) {
    return encoding.isArrayBuffer(val);
}
var isArrayBuffer_1 = validators$1.isArrayBuffer = isArrayBuffer$1;
function getType(val) {
    return encoding.getType(val);
}
var getType_1 = validators$1.getType = getType;
function getEncoding(val) {
    return encoding.getEncoding(val);
}
var getEncoding_1 = validators$1.getEncoding = getEncoding;
function isHexString(value, length) {
    return encoding.isHexString(value, length);
}
var isHexString_1 = validators$1.isHexString = isHexString;
function isJsonRpcSubscription(object) {
    return typeof object.params === "object";
}
var isJsonRpcSubscription_1 = validators$1.isJsonRpcSubscription = isJsonRpcSubscription;
function isJsonRpcRequest(object) {
    return typeof object.method !== "undefined";
}
var isJsonRpcRequest_1 = validators$1.isJsonRpcRequest = isJsonRpcRequest;
function isJsonRpcResponseSuccess(object) {
    return typeof object.result !== "undefined";
}
var isJsonRpcResponseSuccess_1 = validators$1.isJsonRpcResponseSuccess = isJsonRpcResponseSuccess;
function isJsonRpcResponseError(object) {
    return typeof object.error !== "undefined";
}
var isJsonRpcResponseError_1 = validators$1.isJsonRpcResponseError = isJsonRpcResponseError;
function isInternalEvent(object) {
    return typeof object.event !== "undefined";
}
var isInternalEvent_1 = validators$1.isInternalEvent = isInternalEvent;
function isReservedEvent(event) {
    return legacy_types_1.RESERVED_EVENTS.includes(event) || event.startsWith("wc_");
}
var isReservedEvent_1 = validators$1.isReservedEvent = isReservedEvent;
function isSilentPayload(request) {
    if (request.method.startsWith("wc_")) {
        return true;
    }
    if (legacy_types_1.SIGNING_METHODS.includes(request.method)) {
        return false;
    }
    return true;
}
isSilentPayload_1 = validators$1.isSilentPayload = isSilentPayload;

var validators = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), validators$1, {
    get isSilentPayload () { return isSilentPayload_1; },
    get isReservedEvent () { return isReservedEvent_1; },
    get isInternalEvent () { return isInternalEvent_1; },
    get isJsonRpcResponseError () { return isJsonRpcResponseError_1; },
    get isJsonRpcResponseSuccess () { return isJsonRpcResponseSuccess_1; },
    get isJsonRpcRequest () { return isJsonRpcRequest_1; },
    get isJsonRpcSubscription () { return isJsonRpcSubscription_1; },
    get isHexString () { return isHexString_1; },
    get getEncoding () { return getEncoding_1; },
    get getType () { return getType_1; },
    get isArrayBuffer () { return isArrayBuffer_1; },
    get isTypedArray () { return isTypedArray_1; },
    get isBuffer () { return isBuffer_1; },
    get isEmptyArray () { return isEmptyArray_1; },
    get isEmptyString () { return isEmptyString_1; },
    'default': validators$1
}));

var require$$12$1 = /*@__PURE__*/getAugmentedNamespace(validators);

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require$$0$G;
tslib_1.__exportStar(require$$1$h, exports);
tslib_1.__exportStar(require$$2$c, exports);
tslib_1.__exportStar(require$$3$b, exports);
tslib_1.__exportStar(require$$4$8, exports);
tslib_1.__exportStar(require$$5$6, exports);
tslib_1.__exportStar(require$$6$3, exports);
tslib_1.__exportStar(require$$7$2, exports);
tslib_1.__exportStar(require$$8$1, exports);
tslib_1.__exportStar(require$$9$1, exports);
tslib_1.__exportStar(require$$10$1, exports);
tslib_1.__exportStar(require$$11$1, exports);
tslib_1.__exportStar(require$$12$1, exports);
tslib_1.__exportStar(require$$13$1, exports);

}(cjs$4));

var index$1 = /*@__PURE__*/getDefaultExportFromCjs(cjs$4);

var cjs$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), cjs$4, {
    'default': index$1
}));

var require$$0$a = /*@__PURE__*/getAugmentedNamespace(cjs$1);

var server$1 = {};

// can-promise has a crash in some versions of react native that dont have
// standard global objects
// https://github.com/soldair/node-qrcode/issues/157

var canPromise$2 = function () {
  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
};

var canPromise$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), canPromise$2, {
    'default': canPromise$2
}));

var require$$0$9 = /*@__PURE__*/getAugmentedNamespace(canPromise$3);

var qrcode$1 = {};

var buffer$1 = {};

var hasFullSupport = (function () {
  try {
    if (!Buffer$1.isEncoding('latin1')) {
      return false
    }

    var buf = Buffer$1.alloc ? Buffer$1.alloc(4) : new Buffer$1(4);

    buf.fill('ab', 'ucs2');

    return (buf.toString('hex') === '61006200')
  } catch (_) {
    return false
  }
}());

function isSingleByte (val) {
  return (val.length === 1 && val.charCodeAt(0) < 256)
}

function fillWithNumber (buffer, val, start, end) {
  if (start < 0 || end > buffer.length) {
    throw new RangeError('Out of range index')
  }

  start = start >>> 0;
  end = end === undefined ? buffer.length : end >>> 0;

  if (end > start) {
    buffer.fill(val, start, end);
  }

  return buffer
}

function fillWithBuffer (buffer, val, start, end) {
  if (start < 0 || end > buffer.length) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return buffer
  }

  start = start >>> 0;
  end = end === undefined ? buffer.length : end >>> 0;

  var pos = start;
  var len = val.length;
  while (pos <= (end - len)) {
    val.copy(buffer, pos);
    pos += len;
  }

  if (pos !== end) {
    val.copy(buffer, pos, 0, end - pos);
  }

  return buffer
}

function fill (buffer, val, start, end, encoding) {
  if (hasFullSupport) {
    return buffer.fill(val, start, end, encoding)
  }

  if (typeof val === 'number') {
    return fillWithNumber(buffer, val, start, end)
  }

  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = buffer.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = buffer.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }

    if (encoding === 'latin1') {
      encoding = 'binary';
    }

    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }

    if (val === '') {
      return fillWithNumber(buffer, 0, start, end)
    }

    if (isSingleByte(val)) {
      return fillWithNumber(buffer, val.charCodeAt(0), start, end)
    }

    val = new Buffer$1(val, encoding);
  }

  if (Buffer$1.isBuffer(val)) {
    return fillWithBuffer(buffer, val, start, end)
  }

  // Other values (e.g. undefined, boolean, object) results in zero-fill
  return fillWithNumber(buffer, 0, start, end)
}

var bufferFill$1 = fill;

var bufferFill$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bufferFill$1, {
    'default': bufferFill$1
}));

var require$$0$8 = /*@__PURE__*/getAugmentedNamespace(bufferFill$2);

function allocUnsafe$1 (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  }

  if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }

  if (Buffer$1.allocUnsafe) {
    return Buffer$1.allocUnsafe(size)
  } else {
    return new Buffer$1(size)
  }
}

var bufferAllocUnsafe = allocUnsafe$1;

var bufferAllocUnsafe$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bufferAllocUnsafe, {
    'default': bufferAllocUnsafe
}));

var require$$1$e = /*@__PURE__*/getAugmentedNamespace(bufferAllocUnsafe$1);

var bufferFill = require$$0$8;
var allocUnsafe = require$$1$e;

var bufferAlloc = function alloc (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  }

  if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }

  if (Buffer$1.alloc) {
    return Buffer$1.alloc(size, fill, encoding)
  }

  var buffer = allocUnsafe(size);

  if (size === 0) {
    return buffer
  }

  if (fill === undefined) {
    return bufferFill(buffer, 0)
  }

  if (typeof encoding !== 'string') {
    encoding = undefined;
  }

  return bufferFill(buffer, fill, encoding)
};

var bufferAlloc$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bufferAlloc, {
    'default': bufferAlloc
}));

var require$$0$7 = /*@__PURE__*/getAugmentedNamespace(bufferAlloc$1);

var toString$3 = Object.prototype.toString;

var isModern = (
  typeof Buffer$1 !== 'undefined' &&
  typeof Buffer$1.alloc === 'function' &&
  typeof Buffer$1.allocUnsafe === 'function' &&
  typeof Buffer$1.from === 'function'
);

function isArrayBuffer (input) {
  return toString$3.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0;

  var maxLength = obj.byteLength - byteOffset;

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength;
  } else {
    length >>>= 0;

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer$1.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer$1(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer$1.from(string, encoding)
    : new Buffer$1(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer$1.from(value)
    : new Buffer$1(value)
}

var bufferFrom_1 = bufferFrom;

var bufferFrom$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bufferFrom_1, {
    'default': bufferFrom_1
}));

var require$$1$d = /*@__PURE__*/getAugmentedNamespace(bufferFrom$1);

var alloc = buffer$1.alloc = require$$0$7;
var from = buffer$1.from = require$$1$d;

var buffer = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), buffer$1, {
    'default': buffer$1,
    alloc: alloc,
    from: from
}));

var require$$0$6 = /*@__PURE__*/getAugmentedNamespace(buffer);

var utils$3 = {};

var toSJISFunction;
var CODEWORDS_COUNT = [
  0, // Not used
  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
];

/**
 * Returns the QR Code size for the specified version
 *
 * @param  {Number} version QR Code version
 * @return {Number}         size of QR code
 */
var getSymbolSize$1 = utils$3.getSymbolSize = function getSymbolSize (version) {
  if (!version) throw new Error('"version" cannot be null or undefined')
  if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
  return version * 4 + 17
};

/**
 * Returns the total number of codewords used to store data and EC information.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Data length in bits
 */
var getSymbolTotalCodewords = utils$3.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {
  return CODEWORDS_COUNT[version]
};

/**
 * Encode data with Bose-Chaudhuri-Hocquenghem
 *
 * @param  {Number} data Value to encode
 * @return {Number}      Encoded value
 */
var getBCHDigit = utils$3.getBCHDigit = function (data) {
  var digit = 0;

  while (data !== 0) {
    digit++;
    data >>>= 1;
  }

  return digit
};

var setToSJISFunction = utils$3.setToSJISFunction = function setToSJISFunction (f) {
  if (typeof f !== 'function') {
    throw new Error('"toSJISFunc" is not a valid function.')
  }

  toSJISFunction = f;
};

var isKanjiModeEnabled = utils$3.isKanjiModeEnabled = function () {
  return typeof toSJISFunction !== 'undefined'
};

var toSJIS = utils$3.toSJIS = function toSJIS (kanji) {
  return toSJISFunction(kanji)
};

var utils$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), utils$3, {
    'default': utils$3,
    getSymbolSize: getSymbolSize$1,
    getSymbolTotalCodewords: getSymbolTotalCodewords,
    getBCHDigit: getBCHDigit,
    setToSJISFunction: setToSJISFunction,
    isKanjiModeEnabled: isKanjiModeEnabled,
    toSJIS: toSJIS
}));

var require$$1$c = /*@__PURE__*/getAugmentedNamespace(utils$2);

var errorCorrectionLevel$1 = {};

(function (exports) {
exports.L = { bit: 1 };
exports.M = { bit: 0 };
exports.Q = { bit: 3 };
exports.H = { bit: 2 };

function fromString (string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string')
  }

  var lcStr = string.toLowerCase();

  switch (lcStr) {
    case 'l':
    case 'low':
      return exports.L

    case 'm':
    case 'medium':
      return exports.M

    case 'q':
    case 'quartile':
      return exports.Q

    case 'h':
    case 'high':
      return exports.H

    default:
      throw new Error('Unknown EC Level: ' + string)
  }
}

exports.isValid = function isValid (level) {
  return level && typeof level.bit !== 'undefined' &&
    level.bit >= 0 && level.bit < 4
};

exports.from = function from (value, defaultValue) {
  if (exports.isValid(value)) {
    return value
  }

  try {
    return fromString(value)
  } catch (e) {
    return defaultValue
  }
};
}(errorCorrectionLevel$1));

var errorCorrectionLevel = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), errorCorrectionLevel$1, {
    'default': errorCorrectionLevel$1
}));

var require$$2$8 = /*@__PURE__*/getAugmentedNamespace(errorCorrectionLevel);

function BitBuffer$1 () {
  this.buffer = [];
  this.length = 0;
}

BitBuffer$1.prototype = {

  get: function (index) {
    var bufIndex = Math.floor(index / 8);
    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
  },

  put: function (num, length) {
    for (var i = 0; i < length; i++) {
      this.putBit(((num >>> (length - i - 1)) & 1) === 1);
    }
  },

  getLengthInBits: function () {
    return this.length
  },

  putBit: function (bit) {
    var bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }

    if (bit) {
      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
    }

    this.length++;
  }
};

var bitBuffer = BitBuffer$1;

var bitBuffer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bitBuffer, {
    'default': bitBuffer
}));

var require$$3$8 = /*@__PURE__*/getAugmentedNamespace(bitBuffer$1);

var BufferUtil$4 = require$$0$6;

/**
 * Helper class to handle QR Code symbol modules
 *
 * @param {Number} size Symbol size
 */
function BitMatrix$1 (size) {
  if (!size || size < 1) {
    throw new Error('BitMatrix size must be defined and greater than 0')
  }

  this.size = size;
  this.data = BufferUtil$4.alloc(size * size);
  this.reservedBit = BufferUtil$4.alloc(size * size);
}

/**
 * Set bit value at specified location
 * If reserved flag is set, this bit will be ignored during masking process
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 * @param {Boolean} reserved
 */
BitMatrix$1.prototype.set = function (row, col, value, reserved) {
  var index = row * this.size + col;
  this.data[index] = value;
  if (reserved) this.reservedBit[index] = true;
};

/**
 * Returns bit value at specified location
 *
 * @param  {Number}  row
 * @param  {Number}  col
 * @return {Boolean}
 */
BitMatrix$1.prototype.get = function (row, col) {
  return this.data[row * this.size + col]
};

/**
 * Applies xor operator at specified location
 * (used during masking process)
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 */
BitMatrix$1.prototype.xor = function (row, col, value) {
  this.data[row * this.size + col] ^= value;
};

/**
 * Check if bit at specified location is reserved
 *
 * @param {Number}   row
 * @param {Number}   col
 * @return {Boolean}
 */
BitMatrix$1.prototype.isReserved = function (row, col) {
  return this.reservedBit[row * this.size + col]
};

var bitMatrix = BitMatrix$1;

var bitMatrix$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bitMatrix, {
    'default': bitMatrix
}));

var require$$4$5 = /*@__PURE__*/getAugmentedNamespace(bitMatrix$1);

var alignmentPattern$1 = {};

/**
 * Alignment pattern are fixed reference pattern in defined positions
 * in a matrix symbology, which enables the decode software to re-synchronise
 * the coordinate mapping of the image modules in the event of moderate amounts
 * of distortion of the image.
 *
 * Alignment patterns are present only in QR Code symbols of version 2 or larger
 * and their number depends on the symbol version.
 */

(function (exports) {
var getSymbolSize = require$$1$c.getSymbolSize;

/**
 * Calculate the row/column coordinates of the center module of each alignment pattern
 * for the specified QR Code version.
 *
 * The alignment patterns are positioned symmetrically on either side of the diagonal
 * running from the top left corner of the symbol to the bottom right corner.
 *
 * Since positions are simmetrical only half of the coordinates are returned.
 * Each item of the array will represent in turn the x and y coordinate.
 * @see {@link getPositions}
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinate
 */
exports.getRowColCoords = function getRowColCoords (version) {
  if (version === 1) return []

  var posCount = Math.floor(version / 7) + 2;
  var size = getSymbolSize(version);
  var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
  var positions = [size - 7]; // Last coord is always (size - 7)

  for (var i = 1; i < posCount - 1; i++) {
    positions[i] = positions[i - 1] - intervals;
  }

  positions.push(6); // First coord is always 6

  return positions.reverse()
};

/**
 * Returns an array containing the positions of each alignment pattern.
 * Each array's element represent the center point of the pattern as (x, y) coordinates
 *
 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
 * and filtering out the items that overlaps with finder pattern
 *
 * @example
 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
 * The alignment patterns, therefore, are to be centered on (row, column)
 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
 * and are not therefore used for alignment patterns.
 *
 * var pos = getPositions(7)
 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
exports.getPositions = function getPositions (version) {
  var coords = [];
  var pos = exports.getRowColCoords(version);
  var posLength = pos.length;

  for (var i = 0; i < posLength; i++) {
    for (var j = 0; j < posLength; j++) {
      // Skip if position is occupied by finder patterns
      if ((i === 0 && j === 0) ||             // top-left
          (i === 0 && j === posLength - 1) || // bottom-left
          (i === posLength - 1 && j === 0)) { // top-right
        continue
      }

      coords.push([pos[i], pos[j]]);
    }
  }

  return coords
};
}(alignmentPattern$1));

var alignmentPattern = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), alignmentPattern$1, {
    'default': alignmentPattern$1
}));

var require$$5$3 = /*@__PURE__*/getAugmentedNamespace(alignmentPattern);

var finderPattern$1 = {};

var getSymbolSize = require$$1$c.getSymbolSize;
var FINDER_PATTERN_SIZE = 7;

/**
 * Returns an array containing the positions of each finder pattern.
 * Each array's element represent the top-left point of the pattern as (x, y) coordinates
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
var getPositions = finderPattern$1.getPositions = function getPositions (version) {
  var size = getSymbolSize(version);

  return [
    // top-left
    [0, 0],
    // top-right
    [size - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size - FINDER_PATTERN_SIZE]
  ]
};

var finderPattern = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), finderPattern$1, {
    'default': finderPattern$1,
    getPositions: getPositions
}));

var require$$6$2 = /*@__PURE__*/getAugmentedNamespace(finderPattern);

var maskPattern$1 = {};

/**
 * Data mask pattern reference
 * @type {Object}
 */

(function (exports) {
exports.Patterns = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
};

/**
 * Weighted penalty scores for the undesirable features
 * @type {Object}
 */
var PenaltyScores = {
  N1: 3,
  N2: 3,
  N3: 40,
  N4: 10
};

/**
 * Check if mask pattern value is valid
 *
 * @param  {Number}  mask    Mask pattern
 * @return {Boolean}         true if valid, false otherwise
 */
exports.isValid = function isValid (mask) {
  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
};

/**
 * Returns mask pattern from a value.
 * If value is not valid, returns undefined
 *
 * @param  {Number|String} value        Mask pattern value
 * @return {Number}                     Valid mask pattern or undefined
 */
exports.from = function from (value) {
  return exports.isValid(value) ? parseInt(value, 10) : undefined
};

/**
* Find adjacent modules in row/column with the same color
* and assign a penalty value.
*
* Points: N1 + i
* i is the amount by which the number of adjacent modules of the same color exceeds 5
*/
exports.getPenaltyN1 = function getPenaltyN1 (data) {
  var size = data.size;
  var points = 0;
  var sameCountCol = 0;
  var sameCountRow = 0;
  var lastCol = null;
  var lastRow = null;

  for (var row = 0; row < size; row++) {
    sameCountCol = sameCountRow = 0;
    lastCol = lastRow = null;

    for (var col = 0; col < size; col++) {
      var module = data.get(row, col);
      if (module === lastCol) {
        sameCountCol++;
      } else {
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        lastCol = module;
        sameCountCol = 1;
      }

      module = data.get(col, row);
      if (module === lastRow) {
        sameCountRow++;
      } else {
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
        lastRow = module;
        sameCountRow = 1;
      }
    }

    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
  }

  return points
};

/**
 * Find 2x2 blocks with the same color and assign a penalty value
 *
 * Points: N2 * (m - 1) * (n - 1)
 */
exports.getPenaltyN2 = function getPenaltyN2 (data) {
  var size = data.size;
  var points = 0;

  for (var row = 0; row < size - 1; row++) {
    for (var col = 0; col < size - 1; col++) {
      var last = data.get(row, col) +
        data.get(row, col + 1) +
        data.get(row + 1, col) +
        data.get(row + 1, col + 1);

      if (last === 4 || last === 0) points++;
    }
  }

  return points * PenaltyScores.N2
};

/**
 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
 * preceded or followed by light area 4 modules wide
 *
 * Points: N3 * number of pattern found
 */
exports.getPenaltyN3 = function getPenaltyN3 (data) {
  var size = data.size;
  var points = 0;
  var bitsCol = 0;
  var bitsRow = 0;

  for (var row = 0; row < size; row++) {
    bitsCol = bitsRow = 0;
    for (var col = 0; col < size; col++) {
      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);
      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;

      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);
      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
    }
  }

  return points * PenaltyScores.N3
};

/**
 * Calculate proportion of dark modules in entire symbol
 *
 * Points: N4 * k
 *
 * k is the rating of the deviation of the proportion of dark modules
 * in the symbol from 50% in steps of 5%
 */
exports.getPenaltyN4 = function getPenaltyN4 (data) {
  var darkCount = 0;
  var modulesCount = data.data.length;

  for (var i = 0; i < modulesCount; i++) darkCount += data.data[i];

  var k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);

  return k * PenaltyScores.N4
};

/**
 * Return mask value at given position
 *
 * @param  {Number} maskPattern Pattern reference value
 * @param  {Number} i           Row
 * @param  {Number} j           Column
 * @return {Boolean}            Mask value
 */
function getMaskAt (maskPattern, i, j) {
  switch (maskPattern) {
    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0
    case exports.Patterns.PATTERN001: return i % 2 === 0
    case exports.Patterns.PATTERN010: return j % 3 === 0
    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0
    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0
    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0
    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0

    default: throw new Error('bad maskPattern:' + maskPattern)
  }
}

/**
 * Apply a mask pattern to a BitMatrix
 *
 * @param  {Number}    pattern Pattern reference number
 * @param  {BitMatrix} data    BitMatrix data
 */
exports.applyMask = function applyMask (pattern, data) {
  var size = data.size;

  for (var col = 0; col < size; col++) {
    for (var row = 0; row < size; row++) {
      if (data.isReserved(row, col)) continue
      data.xor(row, col, getMaskAt(pattern, row, col));
    }
  }
};

/**
 * Returns the best mask pattern for data
 *
 * @param  {BitMatrix} data
 * @return {Number} Mask pattern reference number
 */
exports.getBestMask = function getBestMask (data, setupFormatFunc) {
  var numPatterns = Object.keys(exports.Patterns).length;
  var bestPattern = 0;
  var lowerPenalty = Infinity;

  for (var p = 0; p < numPatterns; p++) {
    setupFormatFunc(p);
    exports.applyMask(p, data);

    // Calculate penalty
    var penalty =
      exports.getPenaltyN1(data) +
      exports.getPenaltyN2(data) +
      exports.getPenaltyN3(data) +
      exports.getPenaltyN4(data);

    // Undo previously applied mask
    exports.applyMask(p, data);

    if (penalty < lowerPenalty) {
      lowerPenalty = penalty;
      bestPattern = p;
    }
  }

  return bestPattern
};
}(maskPattern$1));

var maskPattern = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), maskPattern$1, {
    'default': maskPattern$1
}));

var require$$7$1 = /*@__PURE__*/getAugmentedNamespace(maskPattern);

var errorCorrectionCode$1 = {};

var ECLevel$1 = require$$2$8;

var EC_BLOCKS_TABLE = [
// L  M  Q  H
  1, 1, 1, 1,
  1, 1, 1, 1,
  1, 1, 2, 2,
  1, 2, 2, 4,
  1, 2, 4, 4,
  2, 4, 4, 4,
  2, 4, 6, 5,
  2, 4, 6, 6,
  2, 5, 8, 8,
  4, 5, 8, 8,
  4, 5, 8, 11,
  4, 8, 10, 11,
  4, 9, 12, 16,
  4, 9, 16, 16,
  6, 10, 12, 18,
  6, 10, 17, 16,
  6, 11, 16, 19,
  6, 13, 18, 21,
  7, 14, 21, 25,
  8, 16, 20, 25,
  8, 17, 23, 25,
  9, 17, 23, 34,
  9, 18, 25, 30,
  10, 20, 27, 32,
  12, 21, 29, 35,
  12, 23, 34, 37,
  12, 25, 34, 40,
  13, 26, 35, 42,
  14, 28, 38, 45,
  15, 29, 40, 48,
  16, 31, 43, 51,
  17, 33, 45, 54,
  18, 35, 48, 57,
  19, 37, 51, 60,
  19, 38, 53, 63,
  20, 40, 56, 66,
  21, 43, 59, 70,
  22, 45, 62, 74,
  24, 47, 65, 77,
  25, 49, 68, 81
];

var EC_CODEWORDS_TABLE = [
// L  M  Q  H
  7, 10, 13, 17,
  10, 16, 22, 28,
  15, 26, 36, 44,
  20, 36, 52, 64,
  26, 48, 72, 88,
  36, 64, 96, 112,
  40, 72, 108, 130,
  48, 88, 132, 156,
  60, 110, 160, 192,
  72, 130, 192, 224,
  80, 150, 224, 264,
  96, 176, 260, 308,
  104, 198, 288, 352,
  120, 216, 320, 384,
  132, 240, 360, 432,
  144, 280, 408, 480,
  168, 308, 448, 532,
  180, 338, 504, 588,
  196, 364, 546, 650,
  224, 416, 600, 700,
  224, 442, 644, 750,
  252, 476, 690, 816,
  270, 504, 750, 900,
  300, 560, 810, 960,
  312, 588, 870, 1050,
  336, 644, 952, 1110,
  360, 700, 1020, 1200,
  390, 728, 1050, 1260,
  420, 784, 1140, 1350,
  450, 812, 1200, 1440,
  480, 868, 1290, 1530,
  510, 924, 1350, 1620,
  540, 980, 1440, 1710,
  570, 1036, 1530, 1800,
  570, 1064, 1590, 1890,
  600, 1120, 1680, 1980,
  630, 1204, 1770, 2100,
  660, 1260, 1860, 2220,
  720, 1316, 1950, 2310,
  750, 1372, 2040, 2430
];

/**
 * Returns the number of error correction block that the QR Code should contain
 * for the specified version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction blocks
 */
var getBlocksCount = errorCorrectionCode$1.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
};

/**
 * Returns the number of error correction codewords to use for the specified
 * version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction codewords
 */
var getTotalCodewordsCount = errorCorrectionCode$1.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
};

var errorCorrectionCode = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), errorCorrectionCode$1, {
    'default': errorCorrectionCode$1,
    getBlocksCount: getBlocksCount,
    getTotalCodewordsCount: getTotalCodewordsCount
}));

var require$$8 = /*@__PURE__*/getAugmentedNamespace(errorCorrectionCode);

var polynomial$1 = {};

var galoisField$1 = {};

var BufferUtil$3 = require$$0$6;

var EXP_TABLE = BufferUtil$3.alloc(512);
var LOG_TABLE = BufferUtil$3.alloc(256)
/**
 * Precompute the log and anti-log tables for faster computation later
 *
 * For each possible value in the galois field 2^8, we will pre-compute
 * the logarithm and anti-logarithm (exponential) of this value
 *
 * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
 */
;(function initTables () {
  var x = 1;
  for (var i = 0; i < 255; i++) {
    EXP_TABLE[i] = x;
    LOG_TABLE[x] = i;

    x <<= 1; // multiply by 2

    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
    // This means that when a number is 256 or larger, it should be XORed with 0x11D.
    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
      x ^= 0x11D;
    }
  }

  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
  // stay inside the bounds (because we will mainly use this table for the multiplication of
  // two GF numbers, no more).
  // @see {@link mul}
  for (i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255];
  }
}());

/**
 * Returns log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
var log = galoisField$1.log = function log (n) {
  if (n < 1) throw new Error('log(' + n + ')')
  return LOG_TABLE[n]
};

/**
 * Returns anti-log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
var exp = galoisField$1.exp = function exp (n) {
  return EXP_TABLE[n]
};

/**
 * Multiplies two number inside Galois Field
 *
 * @param  {Number} x
 * @param  {Number} y
 * @return {Number}
 */
var mul = galoisField$1.mul = function mul (x, y) {
  if (x === 0 || y === 0) return 0

  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
  // @see {@link initTables}
  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
};

var galoisField = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), galoisField$1, {
    'default': galoisField$1,
    log: log,
    exp: exp,
    mul: mul
}));

var require$$1$b = /*@__PURE__*/getAugmentedNamespace(galoisField);

(function (exports) {
var BufferUtil = require$$0$6;
var GF = require$$1$b;

/**
 * Multiplies two polynomials inside Galois Field
 *
 * @param  {Buffer} p1 Polynomial
 * @param  {Buffer} p2 Polynomial
 * @return {Buffer}    Product of p1 and p2
 */
exports.mul = function mul (p1, p2) {
  var coeff = BufferUtil.alloc(p1.length + p2.length - 1);

  for (var i = 0; i < p1.length; i++) {
    for (var j = 0; j < p2.length; j++) {
      coeff[i + j] ^= GF.mul(p1[i], p2[j]);
    }
  }

  return coeff
};

/**
 * Calculate the remainder of polynomials division
 *
 * @param  {Buffer} divident Polynomial
 * @param  {Buffer} divisor  Polynomial
 * @return {Buffer}          Remainder
 */
exports.mod = function mod (divident, divisor) {
  var result = BufferUtil.from(divident);

  while ((result.length - divisor.length) >= 0) {
    var coeff = result[0];

    for (var i = 0; i < divisor.length; i++) {
      result[i] ^= GF.mul(divisor[i], coeff);
    }

    // remove all zeros from buffer head
    var offset = 0;
    while (offset < result.length && result[offset] === 0) offset++;
    result = result.slice(offset);
  }

  return result
};

/**
 * Generate an irreducible generator polynomial of specified degree
 * (used by Reed-Solomon encoder)
 *
 * @param  {Number} degree Degree of the generator polynomial
 * @return {Buffer}        Buffer containing polynomial coefficients
 */
exports.generateECPolynomial = function generateECPolynomial (degree) {
  var poly = BufferUtil.from([1]);
  for (var i = 0; i < degree; i++) {
    poly = exports.mul(poly, [1, GF.exp(i)]);
  }

  return poly
};
}(polynomial$1));

var polynomial = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), polynomial$1, {
    'default': polynomial$1
}));

var require$$1$a = /*@__PURE__*/getAugmentedNamespace(polynomial);

var BufferUtil$2 = require$$0$6;
var Polynomial = require$$1$a;
var Buffer = require$$0$Z.Buffer;

function ReedSolomonEncoder$1 (degree) {
  this.genPoly = undefined;
  this.degree = degree;

  if (this.degree) this.initialize(this.degree);
}

/**
 * Initialize the encoder.
 * The input param should correspond to the number of error correction codewords.
 *
 * @param  {Number} degree
 */
ReedSolomonEncoder$1.prototype.initialize = function initialize (degree) {
  // create an irreducible generator polynomial
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};

/**
 * Encodes a chunk of data
 *
 * @param  {Buffer} data Buffer containing input data
 * @return {Buffer}      Buffer containing encoded data
 */
ReedSolomonEncoder$1.prototype.encode = function encode (data) {
  if (!this.genPoly) {
    throw new Error('Encoder not initialized')
  }

  // Calculate EC for this data block
  // extends data size to data+genPoly size
  var pad = BufferUtil$2.alloc(this.degree);
  var paddedData = Buffer.concat([data, pad], data.length + this.degree);

  // The error correction codewords are the remainder after dividing the data codewords
  // by a generator polynomial
  var remainder = Polynomial.mod(paddedData, this.genPoly);

  // return EC data blocks (last n byte, where n is the degree of genPoly)
  // If coefficients number in remainder are less than genPoly degree,
  // pad with 0s to the left to reach the needed number of coefficients
  var start = this.degree - remainder.length;
  if (start > 0) {
    var buff = BufferUtil$2.alloc(this.degree);
    remainder.copy(buff, start);

    return buff
  }

  return remainder
};

var reedSolomonEncoder = ReedSolomonEncoder$1;

var reedSolomonEncoder$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), reedSolomonEncoder, {
    'default': reedSolomonEncoder
}));

var require$$9 = /*@__PURE__*/getAugmentedNamespace(reedSolomonEncoder$1);

var version$1 = {};

var mode$1 = {};

var versionCheck$1 = {};

/**
 * Check if QR Code version is valid
 *
 * @param  {Number}  version QR Code version
 * @return {Boolean}         true if valid version, false otherwise
 */

var isValid = versionCheck$1.isValid = function isValid (version) {
  return !isNaN(version) && version >= 1 && version <= 40
};

var versionCheck = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), versionCheck$1, {
    'default': versionCheck$1,
    isValid: isValid
}));

var require$$4$4 = /*@__PURE__*/getAugmentedNamespace(versionCheck);

var regex$1 = {};

var numeric = '[0-9]+';
var alphanumeric = '[A-Z $%*+\\-./:]+';
var kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
kanji = kanji.replace(/u/g, '\\u');

var byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';

var KANJI = regex$1.KANJI = new RegExp(kanji, 'g');
var BYTE_KANJI = regex$1.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
var BYTE = regex$1.BYTE = new RegExp(byte, 'g');
var NUMERIC = regex$1.NUMERIC = new RegExp(numeric, 'g');
var ALPHANUMERIC = regex$1.ALPHANUMERIC = new RegExp(alphanumeric, 'g');

var TEST_KANJI = new RegExp('^' + kanji + '$');
var TEST_NUMERIC = new RegExp('^' + numeric + '$');
var TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');

var testKanji = regex$1.testKanji = function testKanji (str) {
  return TEST_KANJI.test(str)
};

var testNumeric = regex$1.testNumeric = function testNumeric (str) {
  return TEST_NUMERIC.test(str)
};

var testAlphanumeric = regex$1.testAlphanumeric = function testAlphanumeric (str) {
  return TEST_ALPHANUMERIC.test(str)
};

var regex = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), regex$1, {
    'default': regex$1,
    KANJI: KANJI,
    BYTE_KANJI: BYTE_KANJI,
    BYTE: BYTE,
    NUMERIC: NUMERIC,
    ALPHANUMERIC: ALPHANUMERIC,
    testKanji: testKanji,
    testNumeric: testNumeric,
    testAlphanumeric: testAlphanumeric
}));

var require$$5$2 = /*@__PURE__*/getAugmentedNamespace(regex);

(function (exports) {
var VersionCheck = require$$4$4;
var Regex = require$$5$2;

/**
 * Numeric mode encodes data from the decimal digit set (0 - 9)
 * (byte values 30HEX to 39HEX).
 * Normally, 3 data characters are represented by 10 bits.
 *
 * @type {Object}
 */
exports.NUMERIC = {
  id: 'Numeric',
  bit: 1 << 0,
  ccBits: [10, 12, 14]
};

/**
 * Alphanumeric mode encodes data from a set of 45 characters,
 * i.e. 10 numeric digits (0 - 9),
 *      26 alphabetic characters (A - Z),
 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
 * Normally, two input characters are represented by 11 bits.
 *
 * @type {Object}
 */
exports.ALPHANUMERIC = {
  id: 'Alphanumeric',
  bit: 1 << 1,
  ccBits: [9, 11, 13]
};

/**
 * In byte mode, data is encoded at 8 bits per character.
 *
 * @type {Object}
 */
exports.BYTE = {
  id: 'Byte',
  bit: 1 << 2,
  ccBits: [8, 16, 16]
};

/**
 * The Kanji mode efficiently encodes Kanji characters in accordance with
 * the Shift JIS system based on JIS X 0208.
 * The Shift JIS values are shifted from the JIS X 0208 values.
 * JIS X 0208 gives details of the shift coded representation.
 * Each two-byte character value is compacted to a 13-bit binary codeword.
 *
 * @type {Object}
 */
exports.KANJI = {
  id: 'Kanji',
  bit: 1 << 3,
  ccBits: [8, 10, 12]
};

/**
 * Mixed mode will contain a sequences of data in a combination of any of
 * the modes described above
 *
 * @type {Object}
 */
exports.MIXED = {
  bit: -1
};

/**
 * Returns the number of bits needed to store the data length
 * according to QR Code specifications.
 *
 * @param  {Mode}   mode    Data mode
 * @param  {Number} version QR Code version
 * @return {Number}         Number of bits
 */
exports.getCharCountIndicator = function getCharCountIndicator (mode, version) {
  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

  if (!VersionCheck.isValid(version)) {
    throw new Error('Invalid version: ' + version)
  }

  if (version >= 1 && version < 10) return mode.ccBits[0]
  else if (version < 27) return mode.ccBits[1]
  return mode.ccBits[2]
};

/**
 * Returns the most efficient mode to store the specified data
 *
 * @param  {String} dataStr Input data string
 * @return {Mode}           Best mode
 */
exports.getBestModeForData = function getBestModeForData (dataStr) {
  if (Regex.testNumeric(dataStr)) return exports.NUMERIC
  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
  else if (Regex.testKanji(dataStr)) return exports.KANJI
  else return exports.BYTE
};

/**
 * Return mode name as string
 *
 * @param {Mode} mode Mode object
 * @returns {String}  Mode name
 */
exports.toString = function toString (mode) {
  if (mode && mode.id) return mode.id
  throw new Error('Invalid mode')
};

/**
 * Check if input param is a valid mode object
 *
 * @param   {Mode}    mode Mode object
 * @returns {Boolean} True if valid mode, false otherwise
 */
exports.isValid = function isValid (mode) {
  return mode && mode.bit && mode.ccBits
};

/**
 * Get mode object from its name
 *
 * @param   {String} string Mode name
 * @returns {Mode}          Mode object
 */
function fromString (string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string')
  }

  var lcStr = string.toLowerCase();

  switch (lcStr) {
    case 'numeric':
      return exports.NUMERIC
    case 'alphanumeric':
      return exports.ALPHANUMERIC
    case 'kanji':
      return exports.KANJI
    case 'byte':
      return exports.BYTE
    default:
      throw new Error('Unknown mode: ' + string)
  }
}

/**
 * Returns mode from a value.
 * If value is not a valid mode, returns defaultValue
 *
 * @param  {Mode|String} value        Encoding mode
 * @param  {Mode}        defaultValue Fallback value
 * @return {Mode}                     Encoding mode
 */
exports.from = function from (value, defaultValue) {
  if (exports.isValid(value)) {
    return value
  }

  try {
    return fromString(value)
  } catch (e) {
    return defaultValue
  }
};
}(mode$1));

var mode = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), mode$1, {
    'default': mode$1
}));

var require$$12 = /*@__PURE__*/getAugmentedNamespace(mode);

var toString$2 = {}.toString;

var isarray = Array.isArray || function (arr) {
  return toString$2.call(arr) == '[object Array]';
};

var isarray$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), isarray, {
    'default': isarray
}));

var require$$14 = /*@__PURE__*/getAugmentedNamespace(isarray$1);

(function (exports) {
var Utils = require$$1$c;
var ECCode = require$$8;
var ECLevel = require$$2$8;
var Mode = require$$12;
var VersionCheck = require$$4$4;
var isArray = require$$14;

// Generator polynomial used to encode version information
var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
var G18_BCH = Utils.getBCHDigit(G18);

function getBestVersionForDataLength (mode, length, errorCorrectionLevel) {
  for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
      return currentVersion
    }
  }

  return undefined
}

function getReservedBitsCount (mode, version) {
  // Character count indicator + mode indicator bits
  return Mode.getCharCountIndicator(mode, version) + 4
}

function getTotalBitsFromDataArray (segments, version) {
  var totalBits = 0;

  segments.forEach(function (data) {
    var reservedBits = getReservedBitsCount(data.mode, version);
    totalBits += reservedBits + data.getBitsLength();
  });

  return totalBits
}

function getBestVersionForMixedData (segments, errorCorrectionLevel) {
  for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
    var length = getTotalBitsFromDataArray(segments, currentVersion);
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
      return currentVersion
    }
  }

  return undefined
}

/**
 * Returns version number from a value.
 * If value is not a valid version, returns defaultValue
 *
 * @param  {Number|String} value        QR Code version
 * @param  {Number}        defaultValue Fallback value
 * @return {Number}                     QR Code version number
 */
exports.from = function from (value, defaultValue) {
  if (VersionCheck.isValid(value)) {
    return parseInt(value, 10)
  }

  return defaultValue
};

/**
 * Returns how much data can be stored with the specified QR code version
 * and error correction level
 *
 * @param  {Number} version              QR Code version (1-40)
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Mode}   mode                 Data mode
 * @return {Number}                      Quantity of storable data
 */
exports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {
  if (!VersionCheck.isValid(version)) {
    throw new Error('Invalid QR Code version')
  }

  // Use Byte mode as default
  if (typeof mode === 'undefined') mode = Mode.BYTE;

  // Total codewords for this QR code version (Data + Error correction)
  var totalCodewords = Utils.getSymbolTotalCodewords(version);

  // Total number of error correction codewords
  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);

  // Total number of data codewords
  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

  if (mode === Mode.MIXED) return dataTotalCodewordsBits

  var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);

  // Return max number of storable codewords
  switch (mode) {
    case Mode.NUMERIC:
      return Math.floor((usableBits / 10) * 3)

    case Mode.ALPHANUMERIC:
      return Math.floor((usableBits / 11) * 2)

    case Mode.KANJI:
      return Math.floor(usableBits / 13)

    case Mode.BYTE:
    default:
      return Math.floor(usableBits / 8)
  }
};

/**
 * Returns the minimum version needed to contain the amount of data
 *
 * @param  {Segment} data                    Segment of data
 * @param  {Number} [errorCorrectionLevel=H] Error correction level
 * @param  {Mode} mode                       Data mode
 * @return {Number}                          QR Code version
 */
exports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {
  var seg;

  var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);

  if (isArray(data)) {
    if (data.length > 1) {
      return getBestVersionForMixedData(data, ecl)
    }

    if (data.length === 0) {
      return 1
    }

    seg = data[0];
  } else {
    seg = data;
  }

  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
};

/**
 * Returns version information with relative error correction bits
 *
 * The version information is included in QR Code symbols of version 7 or larger.
 * It consists of an 18-bit sequence containing 6 data bits,
 * with 12 error correction bits calculated using the (18, 6) Golay code.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Encoded version info bits
 */
exports.getEncodedBits = function getEncodedBits (version) {
  if (!VersionCheck.isValid(version) || version < 7) {
    throw new Error('Invalid QR Code version')
  }

  var d = version << 12;

  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH));
  }

  return (version << 12) | d
};
}(version$1));

var version = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), version$1, {
    'default': version$1
}));

var require$$10 = /*@__PURE__*/getAugmentedNamespace(version);

var formatInfo$1 = {};

var Utils$3 = require$$1$c;

var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
var G15_BCH = Utils$3.getBCHDigit(G15);

/**
 * Returns format information with relative error correction bits
 *
 * The format information is a 15-bit sequence containing 5 data bits,
 * with 10 error correction bits calculated using the (15, 5) BCH code.
 *
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Number} mask                 Mask pattern
 * @return {Number}                      Encoded format information bits
 */
var getEncodedBits = formatInfo$1.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {
  var data = ((errorCorrectionLevel.bit << 3) | mask);
  var d = data << 10;

  while (Utils$3.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= (G15 << (Utils$3.getBCHDigit(d) - G15_BCH));
  }

  // xor final data with mask pattern in order to ensure that
  // no combination of Error Correction Level and data mask pattern
  // will result in an all-zero data string
  return ((data << 10) | d) ^ G15_MASK
};

var formatInfo = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), formatInfo$1, {
    'default': formatInfo$1,
    getEncodedBits: getEncodedBits
}));

var require$$11 = /*@__PURE__*/getAugmentedNamespace(formatInfo);

var segments$1 = {};

var Mode$4 = require$$12;

function NumericData (data) {
  this.mode = Mode$4.NUMERIC;
  this.data = data.toString();
}

NumericData.getBitsLength = function getBitsLength (length) {
  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
};

NumericData.prototype.getLength = function getLength () {
  return this.data.length
};

NumericData.prototype.getBitsLength = function getBitsLength () {
  return NumericData.getBitsLength(this.data.length)
};

NumericData.prototype.write = function write (bitBuffer) {
  var i, group, value;

  // The input data string is divided into groups of three digits,
  // and each group is converted to its 10-bit binary equivalent.
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3);
    value = parseInt(group, 10);

    bitBuffer.put(value, 10);
  }

  // If the number of input digits is not an exact multiple of three,
  // the final one or two digits are converted to 4 or 7 bits respectively.
  var remainingNum = this.data.length - i;
  if (remainingNum > 0) {
    group = this.data.substr(i);
    value = parseInt(group, 10);

    bitBuffer.put(value, remainingNum * 3 + 1);
  }
};

var numericData = NumericData;

var numericData$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), numericData, {
    'default': numericData
}));

var require$$1$9 = /*@__PURE__*/getAugmentedNamespace(numericData$1);

var Mode$3 = require$$12;

/**
 * Array of characters available in alphanumeric mode
 *
 * As per QR Code specification, to each character
 * is assigned a value from 0 to 44 which in this case coincides
 * with the array index
 *
 * @type {Array}
 */
var ALPHA_NUM_CHARS = [
  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  ' ', '$', '%', '*', '+', '-', '.', '/', ':'
];

function AlphanumericData (data) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data;
}

AlphanumericData.getBitsLength = function getBitsLength (length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2)
};

AlphanumericData.prototype.getLength = function getLength () {
  return this.data.length
};

AlphanumericData.prototype.getBitsLength = function getBitsLength () {
  return AlphanumericData.getBitsLength(this.data.length)
};

AlphanumericData.prototype.write = function write (bitBuffer) {
  var i;

  // Input data characters are divided into groups of two characters
  // and encoded as 11-bit binary codes.
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    // The character value of the first character is multiplied by 45
    var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;

    // The character value of the second digit is added to the product
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);

    // The sum is then stored as 11-bit binary number
    bitBuffer.put(value, 11);
  }

  // If the number of input data characters is not a multiple of two,
  // the character value of the final character is encoded as a 6-bit binary number.
  if (this.data.length % 2) {
    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
  }
};

var alphanumericData = AlphanumericData;

var alphanumericData$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), alphanumericData, {
    'default': alphanumericData
}));

var require$$2$7 = /*@__PURE__*/getAugmentedNamespace(alphanumericData$1);

var BufferUtil$1 = require$$0$6;
var Mode$2 = require$$12;

function ByteData (data) {
  this.mode = Mode$2.BYTE;
  this.data = BufferUtil$1.from(data);
}

ByteData.getBitsLength = function getBitsLength (length) {
  return length * 8
};

ByteData.prototype.getLength = function getLength () {
  return this.data.length
};

ByteData.prototype.getBitsLength = function getBitsLength () {
  return ByteData.getBitsLength(this.data.length)
};

ByteData.prototype.write = function (bitBuffer) {
  for (var i = 0, l = this.data.length; i < l; i++) {
    bitBuffer.put(this.data[i], 8);
  }
};

var byteData = ByteData;

var byteData$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), byteData, {
    'default': byteData
}));

var require$$3$7 = /*@__PURE__*/getAugmentedNamespace(byteData$1);

var Mode$1 = require$$12;
var Utils$2 = require$$1$c;

function KanjiData (data) {
  this.mode = Mode$1.KANJI;
  this.data = data;
}

KanjiData.getBitsLength = function getBitsLength (length) {
  return length * 13
};

KanjiData.prototype.getLength = function getLength () {
  return this.data.length
};

KanjiData.prototype.getBitsLength = function getBitsLength () {
  return KanjiData.getBitsLength(this.data.length)
};

KanjiData.prototype.write = function (bitBuffer) {
  var i;

  // In the Shift JIS system, Kanji characters are represented by a two byte combination.
  // These byte values are shifted from the JIS X 0208 values.
  // JIS X 0208 gives details of the shift coded representation.
  for (i = 0; i < this.data.length; i++) {
    var value = Utils$2.toSJIS(this.data[i]);

    // For characters with Shift JIS values from 0x8140 to 0x9FFC:
    if (value >= 0x8140 && value <= 0x9FFC) {
      // Subtract 0x8140 from Shift JIS value
      value -= 0x8140;

    // For characters with Shift JIS values from 0xE040 to 0xEBBF
    } else if (value >= 0xE040 && value <= 0xEBBF) {
      // Subtract 0xC140 from Shift JIS value
      value -= 0xC140;
    } else {
      throw new Error(
        'Invalid SJIS character: ' + this.data[i] + '\n' +
        'Make sure your charset is UTF-8')
    }

    // Multiply most significant byte of result by 0xC0
    // and add least significant byte to product
    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);

    // Convert result to a 13-bit binary string
    bitBuffer.put(value, 13);
  }
};

var kanjiData = KanjiData;

var kanjiData$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), kanjiData, {
    'default': kanjiData
}));

var require$$4$3 = /*@__PURE__*/getAugmentedNamespace(kanjiData$1);

var dijkstra$1 = {exports: {}};

(function (module) {

/******************************************************************************
 * Created 2008-08-19.
 *
 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
 *
 * Copyright (C) 2008
 *   Wyatt Baldwin <self@wyattbaldwin.com>
 *   All rights reserved
 *
 * Licensed under the MIT license.
 *
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *****************************************************************************/
var dijkstra = {
  single_source_shortest_paths: function(graph, s, d) {
    // Predecessor map for each node that has been encountered.
    // node ID => predecessor node ID
    var predecessors = {};

    // Costs of shortest paths from s to all nodes encountered.
    // node ID => cost
    var costs = {};
    costs[s] = 0;

    // Costs of shortest paths from s to all nodes encountered; differs from
    // `costs` in that it provides easy access to the node that currently has
    // the known shortest path from s.
    // XXX: Do we actually need both `costs` and `open`?
    var open = dijkstra.PriorityQueue.make();
    open.push(s, 0);

    var closest,
        u, v,
        cost_of_s_to_u,
        adjacent_nodes,
        cost_of_e,
        cost_of_s_to_u_plus_cost_of_e,
        cost_of_s_to_v,
        first_visit;
    while (!open.empty()) {
      // In the nodes remaining in graph that have a known cost from s,
      // find the node, u, that currently has the shortest path from s.
      closest = open.pop();
      u = closest.value;
      cost_of_s_to_u = closest.cost;

      // Get nodes adjacent to u...
      adjacent_nodes = graph[u] || {};

      // ...and explore the edges that connect u to those nodes, updating
      // the cost of the shortest paths to any or all of those nodes as
      // necessary. v is the node across the current edge from u.
      for (v in adjacent_nodes) {
        if (adjacent_nodes.hasOwnProperty(v)) {
          // Get the cost of the edge running from u to v.
          cost_of_e = adjacent_nodes[v];

          // Cost of s to u plus the cost of u to v across e--this is *a*
          // cost from s to v that may or may not be less than the current
          // known cost to v.
          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

          // If we haven't visited v yet OR if the current known cost from s to
          // v is greater than the new cost we just found (cost of s to u plus
          // cost of u to v across e), update v's cost in the cost list and
          // update v's predecessor in the predecessor list (it's now u).
          cost_of_s_to_v = costs[v];
          first_visit = (typeof costs[v] === 'undefined');
          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
            costs[v] = cost_of_s_to_u_plus_cost_of_e;
            open.push(v, cost_of_s_to_u_plus_cost_of_e);
            predecessors[v] = u;
          }
        }
      }
    }

    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
      throw new Error(msg);
    }

    return predecessors;
  },

  extract_shortest_path_from_predecessor_list: function(predecessors, d) {
    var nodes = [];
    var u = d;
    while (u) {
      nodes.push(u);
      u = predecessors[u];
    }
    nodes.reverse();
    return nodes;
  },

  find_path: function(graph, s, d) {
    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
    return dijkstra.extract_shortest_path_from_predecessor_list(
      predecessors, d);
  },

  /**
   * A very naive priority queue implementation.
   */
  PriorityQueue: {
    make: function (opts) {
      var T = dijkstra.PriorityQueue,
          t = {},
          key;
      opts = opts || {};
      for (key in T) {
        if (T.hasOwnProperty(key)) {
          t[key] = T[key];
        }
      }
      t.queue = [];
      t.sorter = opts.sorter || T.default_sorter;
      return t;
    },

    default_sorter: function (a, b) {
      return a.cost - b.cost;
    },

    /**
     * Add a new item to the queue and ensure the highest priority element
     * is at the front of the queue.
     */
    push: function (value, cost) {
      var item = {value: value, cost: cost};
      this.queue.push(item);
      this.queue.sort(this.sorter);
    },

    /**
     * Return the highest priority element in the queue.
     */
    pop: function () {
      return this.queue.shift();
    },

    empty: function () {
      return this.queue.length === 0;
    }
  }
};


// node.js module exports
{
  module.exports = dijkstra;
}
}(dijkstra$1));

var dijkstra_1 = dijkstra$1.exports;

var dijkstra = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), dijkstra$1.exports, {
    'default': dijkstra_1
}));

var require$$7 = /*@__PURE__*/getAugmentedNamespace(dijkstra);

(function (exports) {
var Mode = require$$12;
var NumericData = require$$1$9;
var AlphanumericData = require$$2$7;
var ByteData = require$$3$7;
var KanjiData = require$$4$3;
var Regex = require$$5$2;
var Utils = require$$1$c;
var dijkstra = require$$7;

/**
 * Returns UTF8 byte length
 *
 * @param  {String} str Input string
 * @return {Number}     Number of byte
 */
function getStringByteLength (str) {
  return unescape(encodeURIComponent(str)).length
}

/**
 * Get a list of segments of the specified mode
 * from a string
 *
 * @param  {Mode}   mode Segment mode
 * @param  {String} str  String to process
 * @return {Array}       Array of object with segments data
 */
function getSegments (regex, mode, str) {
  var segments = [];
  var result;

  while ((result = regex.exec(str)) !== null) {
    segments.push({
      data: result[0],
      index: result.index,
      mode: mode,
      length: result[0].length
    });
  }

  return segments
}

/**
 * Extracts a series of segments with the appropriate
 * modes from a string
 *
 * @param  {String} dataStr Input string
 * @return {Array}          Array of object with segments data
 */
function getSegmentsFromString (dataStr) {
  var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
  var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
  var byteSegs;
  var kanjiSegs;

  if (Utils.isKanjiModeEnabled()) {
    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
  } else {
    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
    kanjiSegs = [];
  }

  var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);

  return segs
    .sort(function (s1, s2) {
      return s1.index - s2.index
    })
    .map(function (obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      }
    })
}

/**
 * Returns how many bits are needed to encode a string of
 * specified length with the specified mode
 *
 * @param  {Number} length String length
 * @param  {Mode} mode     Segment mode
 * @return {Number}        Bit length
 */
function getSegmentBitsLength (length, mode) {
  switch (mode) {
    case Mode.NUMERIC:
      return NumericData.getBitsLength(length)
    case Mode.ALPHANUMERIC:
      return AlphanumericData.getBitsLength(length)
    case Mode.KANJI:
      return KanjiData.getBitsLength(length)
    case Mode.BYTE:
      return ByteData.getBitsLength(length)
  }
}

/**
 * Merges adjacent segments which have the same mode
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */
function mergeSegments (segs) {
  return segs.reduce(function (acc, curr) {
    var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
    if (prevSeg && prevSeg.mode === curr.mode) {
      acc[acc.length - 1].data += curr.data;
      return acc
    }

    acc.push(curr);
    return acc
  }, [])
}

/**
 * Generates a list of all possible nodes combination which
 * will be used to build a segments graph.
 *
 * Nodes are divided by groups. Each group will contain a list of all the modes
 * in which is possible to encode the given text.
 *
 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
 * The group for '12345' will contain then 3 objects, one for each
 * possible encoding mode.
 *
 * Each node represents a possible segment.
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */
function buildNodes (segs) {
  var nodes = [];
  for (var i = 0; i < segs.length; i++) {
    var seg = segs[i];

    switch (seg.mode) {
      case Mode.NUMERIC:
        nodes.push([seg,
          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
          { data: seg.data, mode: Mode.BYTE, length: seg.length }
        ]);
        break
      case Mode.ALPHANUMERIC:
        nodes.push([seg,
          { data: seg.data, mode: Mode.BYTE, length: seg.length }
        ]);
        break
      case Mode.KANJI:
        nodes.push([seg,
          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
        ]);
        break
      case Mode.BYTE:
        nodes.push([
          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
        ]);
    }
  }

  return nodes
}

/**
 * Builds a graph from a list of nodes.
 * All segments in each node group will be connected with all the segments of
 * the next group and so on.
 *
 * At each connection will be assigned a weight depending on the
 * segment's byte length.
 *
 * @param  {Array} nodes    Array of object with segments data
 * @param  {Number} version QR Code version
 * @return {Object}         Graph of all possible segments
 */
function buildGraph (nodes, version) {
  var table = {};
  var graph = {'start': {}};
  var prevNodeIds = ['start'];

  for (var i = 0; i < nodes.length; i++) {
    var nodeGroup = nodes[i];
    var currentNodeIds = [];

    for (var j = 0; j < nodeGroup.length; j++) {
      var node = nodeGroup[j];
      var key = '' + i + j;

      currentNodeIds.push(key);
      table[key] = { node: node, lastCount: 0 };
      graph[key] = {};

      for (var n = 0; n < prevNodeIds.length; n++) {
        var prevNodeId = prevNodeIds[n];

        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
          graph[prevNodeId][key] =
            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);

          table[prevNodeId].lastCount += node.length;
        } else {
          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;

          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
            4 + Mode.getCharCountIndicator(node.mode, version); // switch cost
        }
      }
    }

    prevNodeIds = currentNodeIds;
  }

  for (n = 0; n < prevNodeIds.length; n++) {
    graph[prevNodeIds[n]]['end'] = 0;
  }

  return { map: graph, table: table }
}

/**
 * Builds a segment from a specified data and mode.
 * If a mode is not specified, the more suitable will be used.
 *
 * @param  {String} data             Input data
 * @param  {Mode | String} modesHint Data mode
 * @return {Segment}                 Segment
 */
function buildSingleSegment (data, modesHint) {
  var mode;
  var bestMode = Mode.getBestModeForData(data);

  mode = Mode.from(modesHint, bestMode);

  // Make sure data can be encoded
  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
    throw new Error('"' + data + '"' +
      ' cannot be encoded with mode ' + Mode.toString(mode) +
      '.\n Suggested mode is: ' + Mode.toString(bestMode))
  }

  // Use Mode.BYTE if Kanji support is disabled
  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
    mode = Mode.BYTE;
  }

  switch (mode) {
    case Mode.NUMERIC:
      return new NumericData(data)

    case Mode.ALPHANUMERIC:
      return new AlphanumericData(data)

    case Mode.KANJI:
      return new KanjiData(data)

    case Mode.BYTE:
      return new ByteData(data)
  }
}

/**
 * Builds a list of segments from an array.
 * Array can contain Strings or Objects with segment's info.
 *
 * For each item which is a string, will be generated a segment with the given
 * string and the more appropriate encoding mode.
 *
 * For each item which is an object, will be generated a segment with the given
 * data and mode.
 * Objects must contain at least the property "data".
 * If property "mode" is not present, the more suitable mode will be used.
 *
 * @param  {Array} array Array of objects with segments data
 * @return {Array}       Array of Segments
 */
exports.fromArray = function fromArray (array) {
  return array.reduce(function (acc, seg) {
    if (typeof seg === 'string') {
      acc.push(buildSingleSegment(seg, null));
    } else if (seg.data) {
      acc.push(buildSingleSegment(seg.data, seg.mode));
    }

    return acc
  }, [])
};

/**
 * Builds an optimized sequence of segments from a string,
 * which will produce the shortest possible bitstream.
 *
 * @param  {String} data    Input string
 * @param  {Number} version QR Code version
 * @return {Array}          Array of segments
 */
exports.fromString = function fromString (data, version) {
  var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());

  var nodes = buildNodes(segs);
  var graph = buildGraph(nodes, version);
  var path = dijkstra.find_path(graph.map, 'start', 'end');

  var optimizedSegs = [];
  for (var i = 1; i < path.length - 1; i++) {
    optimizedSegs.push(graph.table[path[i]].node);
  }

  return exports.fromArray(mergeSegments(optimizedSegs))
};

/**
 * Splits a string in various segments with the modes which
 * best represent their content.
 * The produced segments are far from being optimized.
 * The output of this function is only used to estimate a QR Code version
 * which may contain the data.
 *
 * @param  {string} data Input string
 * @return {Array}       Array of segments
 */
exports.rawSplit = function rawSplit (data) {
  return exports.fromArray(
    getSegmentsFromString(data, Utils.isKanjiModeEnabled())
  )
};
}(segments$1));

var segments = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), segments$1, {
    'default': segments$1
}));

var require$$13 = /*@__PURE__*/getAugmentedNamespace(segments);

var BufferUtil = require$$0$6;
var Utils$1 = require$$1$c;
var ECLevel = require$$2$8;
var BitBuffer = require$$3$8;
var BitMatrix = require$$4$5;
var AlignmentPattern = require$$5$3;
var FinderPattern = require$$6$2;
var MaskPattern = require$$7$1;
var ECCode = require$$8;
var ReedSolomonEncoder = require$$9;
var Version = require$$10;
var FormatInfo = require$$11;
var Mode = require$$12;
var Segments = require$$13;
var isArray = require$$14;

/**
 * QRCode for JavaScript
 *
 * modified by Ryan Day for nodejs support
 * Copyright (c) 2011 Ryan Day
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
//---------------------------------------------------------------------
// QRCode for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//   http://www.opensource.org/licenses/mit-license.php
//
// The word "QR Code" is registered trademark of
// DENSO WAVE INCORPORATED
//   http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------
*/

/**
 * Add finder patterns bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupFinderPattern (matrix, version) {
  var size = matrix.size;
  var pos = FinderPattern.getPositions(version);

  for (var i = 0; i < pos.length; i++) {
    var row = pos[i][0];
    var col = pos[i][1];

    for (var r = -1; r <= 7; r++) {
      if (row + r <= -1 || size <= row + r) continue

      for (var c = -1; c <= 7; c++) {
        if (col + c <= -1 || size <= col + c) continue

        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
          matrix.set(row + r, col + c, true, true);
        } else {
          matrix.set(row + r, col + c, false, true);
        }
      }
    }
  }
}

/**
 * Add timing pattern bits to matrix
 *
 * Note: this function must be called before {@link setupAlignmentPattern}
 *
 * @param  {BitMatrix} matrix Modules matrix
 */
function setupTimingPattern (matrix) {
  var size = matrix.size;

  for (var r = 8; r < size - 8; r++) {
    var value = r % 2 === 0;
    matrix.set(r, 6, value, true);
    matrix.set(6, r, value, true);
  }
}

/**
 * Add alignment patterns bits to matrix
 *
 * Note: this function must be called after {@link setupTimingPattern}
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupAlignmentPattern (matrix, version) {
  var pos = AlignmentPattern.getPositions(version);

  for (var i = 0; i < pos.length; i++) {
    var row = pos[i][0];
    var col = pos[i][1];

    for (var r = -2; r <= 2; r++) {
      for (var c = -2; c <= 2; c++) {
        if (r === -2 || r === 2 || c === -2 || c === 2 ||
          (r === 0 && c === 0)) {
          matrix.set(row + r, col + c, true, true);
        } else {
          matrix.set(row + r, col + c, false, true);
        }
      }
    }
  }
}

/**
 * Add version info bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupVersionInfo (matrix, version) {
  var size = matrix.size;
  var bits = Version.getEncodedBits(version);
  var row, col, mod;

  for (var i = 0; i < 18; i++) {
    row = Math.floor(i / 3);
    col = i % 3 + size - 8 - 3;
    mod = ((bits >> i) & 1) === 1;

    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}

/**
 * Add format info bits to matrix
 *
 * @param  {BitMatrix} matrix               Modules matrix
 * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
 * @param  {Number}    maskPattern          Mask pattern reference value
 */
function setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {
  var size = matrix.size;
  var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
  var i, mod;

  for (i = 0; i < 15; i++) {
    mod = ((bits >> i) & 1) === 1;

    // vertical
    if (i < 6) {
      matrix.set(i, 8, mod, true);
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true);
    } else {
      matrix.set(size - 15 + i, 8, mod, true);
    }

    // horizontal
    if (i < 8) {
      matrix.set(8, size - i - 1, mod, true);
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i - 1, mod, true);
    }
  }

  // fixed module
  matrix.set(size - 8, 8, 1, true);
}

/**
 * Add encoded data bits to matrix
 *
 * @param  {BitMatrix} matrix Modules matrix
 * @param  {Buffer}    data   Data codewords
 */
function setupData (matrix, data) {
  var size = matrix.size;
  var inc = -1;
  var row = size - 1;
  var bitIndex = 7;
  var byteIndex = 0;

  for (var col = size - 1; col > 0; col -= 2) {
    if (col === 6) col--;

    while (true) {
      for (var c = 0; c < 2; c++) {
        if (!matrix.isReserved(row, col - c)) {
          var dark = false;

          if (byteIndex < data.length) {
            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
          }

          matrix.set(row, col - c, dark);
          bitIndex--;

          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }

      row += inc;

      if (row < 0 || size <= row) {
        row -= inc;
        inc = -inc;
        break
      }
    }
  }
}

/**
 * Create encoded codewords from data input
 *
 * @param  {Number}   version              QR Code version
 * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
 * @param  {ByteData} data                 Data input
 * @return {Buffer}                        Buffer containing encoded codewords
 */
function createData (version, errorCorrectionLevel, segments) {
  // Prepare data buffer
  var buffer = new BitBuffer();

  segments.forEach(function (data) {
    // prefix data with mode indicator (4 bits)
    buffer.put(data.mode.bit, 4);

    // Prefix data with character count indicator.
    // The character count indicator is a string of bits that represents the
    // number of characters that are being encoded.
    // The character count indicator must be placed after the mode indicator
    // and must be a certain number of bits long, depending on the QR version
    // and data mode
    // @see {@link Mode.getCharCountIndicator}.
    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));

    // add binary data sequence to buffer
    data.write(buffer);
  });

  // Calculate required number of bits
  var totalCodewords = Utils$1.getSymbolTotalCodewords(version);
  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

  // Add a terminator.
  // If the bit string is shorter than the total number of required bits,
  // a terminator of up to four 0s must be added to the right side of the string.
  // If the bit string is more than four bits shorter than the required number of bits,
  // add four 0s to the end.
  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer.put(0, 4);
  }

  // If the bit string is fewer than four bits shorter, add only the number of 0s that
  // are needed to reach the required number of bits.

  // After adding the terminator, if the number of bits in the string is not a multiple of 8,
  // pad the string on the right with 0s to make the string's length a multiple of 8.
  while (buffer.getLengthInBits() % 8 !== 0) {
    buffer.putBit(0);
  }

  // Add pad bytes if the string is still shorter than the total number of required bits.
  // Extend the buffer to fill the data capacity of the symbol corresponding to
  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
  // and 00010001 (0x11) alternately.
  var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
  for (var i = 0; i < remainingByte; i++) {
    buffer.put(i % 2 ? 0x11 : 0xEC, 8);
  }

  return createCodewords(buffer, version, errorCorrectionLevel)
}

/**
 * Encode input data with Reed-Solomon and return codewords with
 * relative error correction bits
 *
 * @param  {BitBuffer} bitBuffer            Data to encode
 * @param  {Number}    version              QR Code version
 * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
 * @return {Buffer}                         Buffer containing encoded codewords
 */
function createCodewords (bitBuffer, version, errorCorrectionLevel) {
  // Total codewords for this QR code version (Data + Error correction)
  var totalCodewords = Utils$1.getSymbolTotalCodewords(version);

  // Total number of error correction codewords
  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);

  // Total number of data codewords
  var dataTotalCodewords = totalCodewords - ecTotalCodewords;

  // Total number of blocks
  var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);

  // Calculate how many blocks each group should contain
  var blocksInGroup2 = totalCodewords % ecTotalBlocks;
  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;

  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);

  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;

  // Number of EC codewords is the same for both groups
  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;

  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
  var rs = new ReedSolomonEncoder(ecCount);

  var offset = 0;
  var dcData = new Array(ecTotalBlocks);
  var ecData = new Array(ecTotalBlocks);
  var maxDataSize = 0;
  var buffer = BufferUtil.from(bitBuffer.buffer);

  // Divide the buffer into the required number of blocks
  for (var b = 0; b < ecTotalBlocks; b++) {
    var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;

    // extract a block of data from buffer
    dcData[b] = buffer.slice(offset, offset + dataSize);

    // Calculate EC codewords for this data block
    ecData[b] = rs.encode(dcData[b]);

    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }

  // Create final data
  // Interleave the data and error correction codewords from each block
  var data = BufferUtil.alloc(totalCodewords);
  var index = 0;
  var i, r;

  // Add data codewords
  for (i = 0; i < maxDataSize; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      if (i < dcData[r].length) {
        data[index++] = dcData[r][i];
      }
    }
  }

  // Apped EC codewords
  for (i = 0; i < ecCount; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      data[index++] = ecData[r][i];
    }
  }

  return data
}

/**
 * Build QR Code symbol
 *
 * @param  {String} data                 Input string
 * @param  {Number} version              QR Code version
 * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
 * @param  {MaskPattern} maskPattern     Mask pattern
 * @return {Object}                      Object containing symbol data
 */
function createSymbol (data, version, errorCorrectionLevel, maskPattern) {
  var segments;

  if (isArray(data)) {
    segments = Segments.fromArray(data);
  } else if (typeof data === 'string') {
    var estimatedVersion = version;

    if (!estimatedVersion) {
      var rawSegments = Segments.rawSplit(data);

      // Estimate best version that can contain raw splitted segments
      estimatedVersion = Version.getBestVersionForData(rawSegments,
        errorCorrectionLevel);
    }

    // Build optimized segments
    // If estimated version is undefined, try with the highest version
    segments = Segments.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error('Invalid data')
  }

  // Get the min version that can contain data
  var bestVersion = Version.getBestVersionForData(segments,
      errorCorrectionLevel);

  // If no version is found, data cannot be stored
  if (!bestVersion) {
    throw new Error('The amount of data is too big to be stored in a QR Code')
  }

  // If not specified, use min version as default
  if (!version) {
    version = bestVersion;

  // Check if the specified version can contain the data
  } else if (version < bestVersion) {
    throw new Error('\n' +
      'The chosen QR Code version cannot contain this amount of data.\n' +
      'Minimum version required to store current data is: ' + bestVersion + '.\n'
    )
  }

  var dataBits = createData(version, errorCorrectionLevel, segments);

  // Allocate matrix buffer
  var moduleCount = Utils$1.getSymbolSize(version);
  var modules = new BitMatrix(moduleCount);

  // Add function modules
  setupFinderPattern(modules, version);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version);

  // Add temporary dummy bits for format info just to set them as reserved.
  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
  // since the masking operation must be performed only on the encoding region.
  // These blocks will be replaced with correct values later in code.
  setupFormatInfo(modules, errorCorrectionLevel, 0);

  if (version >= 7) {
    setupVersionInfo(modules, version);
  }

  // Add data codewords
  setupData(modules, dataBits);

  if (isNaN(maskPattern)) {
    // Find best mask pattern
    maskPattern = MaskPattern.getBestMask(modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel));
  }

  // Apply mask pattern
  MaskPattern.applyMask(maskPattern, modules);

  // Replace format info bits with correct values
  setupFormatInfo(modules, errorCorrectionLevel, maskPattern);

  return {
    modules: modules,
    version: version,
    errorCorrectionLevel: errorCorrectionLevel,
    maskPattern: maskPattern,
    segments: segments
  }
}

/**
 * QR Code
 *
 * @param {String | Array} data                 Input data
 * @param {Object} options                      Optional configurations
 * @param {Number} options.version              QR Code version
 * @param {String} options.errorCorrectionLevel Error correction level
 * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
 */
var create$2 = qrcode$1.create = function create (data, options) {
  if (typeof data === 'undefined' || data === '') {
    throw new Error('No input text')
  }

  var errorCorrectionLevel = ECLevel.M;
  var version;
  var mask;

  if (typeof options !== 'undefined') {
    // Use higher error correction level as default
    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version = Version.from(options.version);
    mask = MaskPattern.from(options.maskPattern);

    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }

  return createSymbol(data, version, errorCorrectionLevel, mask)
};

var qrcode = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), qrcode$1, {
    'default': qrcode$1,
    create: create$2
}));

var require$$1$8 = /*@__PURE__*/getAugmentedNamespace(qrcode);

var png$3 = {};

var png$2 = {};

var parserAsync$2 = {exports: {}};

var chunkstream$2 = {exports: {}};

var util$4 = require$$0$10;
var Stream$2 = require$$1$1b;


var ChunkStream$2 = chunkstream$2.exports = function() {
  Stream$2.call(this);

  this._buffers = [];
  this._buffered = 0;

  this._reads = [];
  this._paused = false;

  this._encoding = 'utf8';
  this.writable = true;
};
util$4.inherits(ChunkStream$2, Stream$2);


ChunkStream$2.prototype.read = function(length, callback) {

  this._reads.push({
    length: Math.abs(length), // if length < 0 then at most this length
    allowLess: length < 0,
    func: callback
  });

  browser$1$1.nextTick(function() {
    this._process();

    // its paused and there is not enought data then ask for more
    if (this._paused && this._reads.length > 0) {
      this._paused = false;

      this.emit('drain');
    }
  }.bind(this));
};

ChunkStream$2.prototype.write = function(data, encoding) {

  if (!this.writable) {
    this.emit('error', new Error('Stream not writable'));
    return false;
  }

  var dataBuffer;
  if (Buffer$1.isBuffer(data)) {
    dataBuffer = data;
  }
  else {
    dataBuffer = new Buffer$1(data, encoding || this._encoding);
  }

  this._buffers.push(dataBuffer);
  this._buffered += dataBuffer.length;

  this._process();

  // ok if there are no more read requests
  if (this._reads && this._reads.length === 0) {
    this._paused = true;
  }

  return this.writable && !this._paused;
};

ChunkStream$2.prototype.end = function(data, encoding) {

  if (data) {
    this.write(data, encoding);
  }

  this.writable = false;

  // already destroyed
  if (!this._buffers) {
    return;
  }

  // enqueue or handle end
  if (this._buffers.length === 0) {
    this._end();
  }
  else {
    this._buffers.push(null);
    this._process();
  }
};

ChunkStream$2.prototype.destroySoon = ChunkStream$2.prototype.end;

ChunkStream$2.prototype._end = function() {

  if (this._reads.length > 0) {
    this.emit('error',
      new Error('Unexpected end of input')
    );
  }

  this.destroy();
};

ChunkStream$2.prototype.destroy = function() {

  if (!this._buffers) {
    return;
  }

  this.writable = false;
  this._reads = null;
  this._buffers = null;

  this.emit('close');
};

ChunkStream$2.prototype._processReadAllowingLess = function(read) {
  // ok there is any data so that we can satisfy this request
  this._reads.shift(); // == read

  // first we need to peek into first buffer
  var smallerBuf = this._buffers[0];

  // ok there is more data than we need
  if (smallerBuf.length > read.length) {

    this._buffered -= read.length;
    this._buffers[0] = smallerBuf.slice(read.length);

    read.func.call(this, smallerBuf.slice(0, read.length));

  }
  else {
    // ok this is less than maximum length so use it all
    this._buffered -= smallerBuf.length;
    this._buffers.shift(); // == smallerBuf

    read.func.call(this, smallerBuf);
  }
};

ChunkStream$2.prototype._processRead = function(read) {
  this._reads.shift(); // == read

  var pos = 0;
  var count = 0;
  var data = new Buffer$1(read.length);

  // create buffer for all data
  while (pos < read.length) {

    var buf = this._buffers[count++];
    var len = Math.min(buf.length, read.length - pos);

    buf.copy(data, pos, 0, len);
    pos += len;

    // last buffer wasn't used all so just slice it and leave
    if (len !== buf.length) {
      this._buffers[--count] = buf.slice(len);
    }
  }

  // remove all used buffers
  if (count > 0) {
    this._buffers.splice(0, count);
  }

  this._buffered -= read.length;

  read.func.call(this, data);
};

ChunkStream$2.prototype._process = function() {

  try {
    // as long as there is any data and read requests
    while (this._buffered > 0 && this._reads && this._reads.length > 0) {

      var read = this._reads[0];

      // read any data (but no more than length)
      if (read.allowLess) {
        this._processReadAllowingLess(read);

      }
      else if (this._buffered >= read.length) {
        // ok we can meet some expectations

        this._processRead(read);
      }
      else {
        // not enought data to satisfy first request in queue
        // so we need to wait for more
        break;
      }
    }

    if (this._buffers && !this.writable) {
      this._end();
    }
  }
  catch (ex) {
    this.emit('error', ex);
  }
};

var chunkstream = chunkstream$2.exports;

var chunkstream$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), chunkstream$2.exports, {
    'default': chunkstream
}));

var require$$2$6 = /*@__PURE__*/getAugmentedNamespace(chunkstream$1);

var filterParseAsync$2 = {exports: {}};

var filterParse$2 = {exports: {}};

var interlace$1 = {};

// Adam 7
//   0 1 2 3 4 5 6 7
// 0 x 6 4 6 x 6 4 6
// 1 7 7 7 7 7 7 7 7
// 2 5 6 5 6 5 6 5 6
// 3 7 7 7 7 7 7 7 7
// 4 3 6 4 6 3 6 4 6
// 5 7 7 7 7 7 7 7 7
// 6 5 6 5 6 5 6 5 6
// 7 7 7 7 7 7 7 7 7


var imagePasses = [
  { // pass 1 - 1px
    x: [0],
    y: [0]
  },
  { // pass 2 - 1px
    x: [4],
    y: [0]
  },
  { // pass 3 - 2px
    x: [0, 4],
    y: [4]
  },
  { // pass 4 - 4px
    x: [2, 6],
    y: [0, 4]
  },
  { // pass 5 - 8px
    x: [0, 2, 4, 6],
    y: [2, 6]
  },
  { // pass 6 - 16px
    x: [1, 3, 5, 7],
    y: [0, 2, 4, 6]
  },
  { // pass 7 - 32px
    x: [0, 1, 2, 3, 4, 5, 6, 7],
    y: [1, 3, 5, 7]
  }
];

var getImagePasses = interlace$1.getImagePasses = function(width, height) {
  var images = [];
  var xLeftOver = width % 8;
  var yLeftOver = height % 8;
  var xRepeats = (width - xLeftOver) / 8;
  var yRepeats = (height - yLeftOver) / 8;
  for (var i = 0; i < imagePasses.length; i++) {
    var pass = imagePasses[i];
    var passWidth = xRepeats * pass.x.length;
    var passHeight = yRepeats * pass.y.length;
    for (var j = 0; j < pass.x.length; j++) {
      if (pass.x[j] < xLeftOver) {
        passWidth++;
      }
      else {
        break;
      }
    }
    for (j = 0; j < pass.y.length; j++) {
      if (pass.y[j] < yLeftOver) {
        passHeight++;
      }
      else {
        break;
      }
    }
    if (passWidth > 0 && passHeight > 0) {
      images.push({ width: passWidth, height: passHeight, index: i });
    }
  }
  return images;
};

var getInterlaceIterator = interlace$1.getInterlaceIterator = function(width) {
  return function(x, y, pass) {
    var outerXLeftOver = x % imagePasses[pass].x.length;
    var outerX = (((x - outerXLeftOver) / imagePasses[pass].x.length) * 8) + imagePasses[pass].x[outerXLeftOver];
    var outerYLeftOver = y % imagePasses[pass].y.length;
    var outerY = (((y - outerYLeftOver) / imagePasses[pass].y.length) * 8) + imagePasses[pass].y[outerYLeftOver];
    return (outerX * 4) + (outerY * width * 4);
  };
};

var interlace = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), interlace$1, {
    'default': interlace$1,
    getImagePasses: getImagePasses,
    getInterlaceIterator: getInterlaceIterator
}));

var require$$0$5 = /*@__PURE__*/getAugmentedNamespace(interlace);

var paethPredictor$2 = function paethPredictor(left, above, upLeft) {

  var paeth = left + above - upLeft;
  var pLeft = Math.abs(paeth - left);
  var pAbove = Math.abs(paeth - above);
  var pUpLeft = Math.abs(paeth - upLeft);

  if (pLeft <= pAbove && pLeft <= pUpLeft) {
    return left;
  }
  if (pAbove <= pUpLeft) {
    return above;
  }
  return upLeft;
};

var paethPredictor$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), paethPredictor$2, {
    'default': paethPredictor$2
}));

var require$$0$4 = /*@__PURE__*/getAugmentedNamespace(paethPredictor$3);

var interlaceUtils$1 = require$$0$5;
var paethPredictor$1 = require$$0$4;

function getByteWidth(width, bpp, depth) {
  var byteWidth = width * bpp;
  if (depth !== 8) {
    byteWidth = Math.ceil(byteWidth / (8 / depth));
  }
  return byteWidth;
}

var Filter$2 = filterParse$2.exports = function(bitmapInfo, dependencies) {

  var width = bitmapInfo.width;
  var height = bitmapInfo.height;
  var interlace = bitmapInfo.interlace;
  var bpp = bitmapInfo.bpp;
  var depth = bitmapInfo.depth;

  this.read = dependencies.read;
  this.write = dependencies.write;
  this.complete = dependencies.complete;

  this._imageIndex = 0;
  this._images = [];
  if (interlace) {
    var passes = interlaceUtils$1.getImagePasses(width, height);
    for (var i = 0; i < passes.length; i++) {
      this._images.push({
        byteWidth: getByteWidth(passes[i].width, bpp, depth),
        height: passes[i].height,
        lineIndex: 0
      });
    }
  }
  else {
    this._images.push({
      byteWidth: getByteWidth(width, bpp, depth),
      height: height,
      lineIndex: 0
    });
  }

  // when filtering the line we look at the pixel to the left
  // the spec also says it is done on a byte level regardless of the number of pixels
  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back
  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.
  if (depth === 8) {
    this._xComparison = bpp;
  }
  else if (depth === 16) {
    this._xComparison = bpp * 2;
  }
  else {
    this._xComparison = 1;
  }
};

Filter$2.prototype.start = function() {
  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
};

Filter$2.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {

  var xComparison = this._xComparison;
  var xBiggerThan = xComparison - 1;

  for (var x = 0; x < byteWidth; x++) {
    var rawByte = rawData[1 + x];
    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    unfilteredLine[x] = rawByte + f1Left;
  }
};

Filter$2.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {

  var lastLine = this._lastLine;

  for (var x = 0; x < byteWidth; x++) {
    var rawByte = rawData[1 + x];
    var f2Up = lastLine ? lastLine[x] : 0;
    unfilteredLine[x] = rawByte + f2Up;
  }
};

Filter$2.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {

  var xComparison = this._xComparison;
  var xBiggerThan = xComparison - 1;
  var lastLine = this._lastLine;

  for (var x = 0; x < byteWidth; x++) {
    var rawByte = rawData[1 + x];
    var f3Up = lastLine ? lastLine[x] : 0;
    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    var f3Add = Math.floor((f3Left + f3Up) / 2);
    unfilteredLine[x] = rawByte + f3Add;
  }
};

Filter$2.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {

  var xComparison = this._xComparison;
  var xBiggerThan = xComparison - 1;
  var lastLine = this._lastLine;

  for (var x = 0; x < byteWidth; x++) {
    var rawByte = rawData[1 + x];
    var f4Up = lastLine ? lastLine[x] : 0;
    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
    var f4Add = paethPredictor$1(f4Left, f4Up, f4UpLeft);
    unfilteredLine[x] = rawByte + f4Add;
  }
};

Filter$2.prototype._reverseFilterLine = function(rawData) {

  var filter = rawData[0];
  var unfilteredLine;
  var currentImage = this._images[this._imageIndex];
  var byteWidth = currentImage.byteWidth;

  if (filter === 0) {
    unfilteredLine = rawData.slice(1, byteWidth + 1);
  }
  else {

    unfilteredLine = new Buffer$1(byteWidth);

    switch (filter) {
      case 1:
        this._unFilterType1(rawData, unfilteredLine, byteWidth);
        break;
      case 2:
        this._unFilterType2(rawData, unfilteredLine, byteWidth);
        break;
      case 3:
        this._unFilterType3(rawData, unfilteredLine, byteWidth);
        break;
      case 4:
        this._unFilterType4(rawData, unfilteredLine, byteWidth);
        break;
      default:
        throw new Error('Unrecognised filter type - ' + filter);
    }
  }

  this.write(unfilteredLine);

  currentImage.lineIndex++;
  if (currentImage.lineIndex >= currentImage.height) {
    this._lastLine = null;
    this._imageIndex++;
    currentImage = this._images[this._imageIndex];
  }
  else {
    this._lastLine = unfilteredLine;
  }

  if (currentImage) {
    // read, using the byte width that may be from the new current image
    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
  }
  else {
    this._lastLine = null;
    this.complete();
  }
};

var filterParse = filterParse$2.exports;

var filterParse$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), filterParse$2.exports, {
    'default': filterParse
}));

var require$$1$7 = /*@__PURE__*/getAugmentedNamespace(filterParse$1);

var util$3 = require$$0$10;
var ChunkStream$1 = require$$2$6;
var Filter$1 = require$$1$7;


var FilterAsync$1 = filterParseAsync$2.exports = function(bitmapInfo) {
  ChunkStream$1.call(this);

  var buffers = [];
  var that = this;
  this._filter = new Filter$1(bitmapInfo, {
    read: this.read.bind(this),
    write: function(buffer) {
      buffers.push(buffer);
    },
    complete: function() {
      that.emit('complete', Buffer$1.concat(buffers));
    }
  });

  this._filter.start();
};
util$3.inherits(FilterAsync$1, ChunkStream$1);

var filterParseAsync = filterParseAsync$2.exports;

var filterParseAsync$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), filterParseAsync$2.exports, {
    'default': filterParseAsync
}));

var require$$3$6 = /*@__PURE__*/getAugmentedNamespace(filterParseAsync$1);

var parser$2 = {exports: {}};

var constants$5 = {

  PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],

  TYPE_IHDR: 0x49484452,
  TYPE_IEND: 0x49454e44,
  TYPE_IDAT: 0x49444154,
  TYPE_PLTE: 0x504c5445,
  TYPE_tRNS: 0x74524e53, // eslint-disable-line camelcase
  TYPE_gAMA: 0x67414d41, // eslint-disable-line camelcase

  // color-type bits
  COLORTYPE_GRAYSCALE: 0,
  COLORTYPE_PALETTE: 1,
  COLORTYPE_COLOR: 2,
  COLORTYPE_ALPHA: 4, // e.g. grayscale and alpha

  // color-type combinations
  COLORTYPE_PALETTE_COLOR: 3,
  COLORTYPE_COLOR_ALPHA: 6,

  COLORTYPE_TO_BPP_MAP: {
    0: 1,
    2: 3,
    3: 1,
    4: 2,
    6: 4
  },

  GAMMA_DIVISION: 100000
};

var constants$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), constants$5, {
    'default': constants$5
}));

var require$$1$6 = /*@__PURE__*/getAugmentedNamespace(constants$6);

var crc$2 = {exports: {}};

var crcTable = [];

(function() {
  for (var i = 0; i < 256; i++) {
    var currentCrc = i;
    for (var j = 0; j < 8; j++) {
      if (currentCrc & 1) {
        currentCrc = 0xedb88320 ^ (currentCrc >>> 1);
      }
      else {
        currentCrc = currentCrc >>> 1;
      }
    }
    crcTable[i] = currentCrc;
  }
}());

var CrcCalculator$1 = crc$2.exports = function() {
  this._crc = -1;
};

CrcCalculator$1.prototype.write = function(data) {

  for (var i = 0; i < data.length; i++) {
    this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);
  }
  return true;
};

CrcCalculator$1.prototype.crc32 = function() {
  return this._crc ^ -1;
};


CrcCalculator$1.crc32 = function(buf) {

  var crc = -1;
  for (var i = 0; i < buf.length; i++) {
    crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);
  }
  return crc ^ -1;
};

var crc = crc$2.exports;

var crc$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), crc$2.exports, {
    'default': crc
}));

var require$$1$5 = /*@__PURE__*/getAugmentedNamespace(crc$1);

var constants$4 = require$$1$6;
var CrcCalculator = require$$1$5;


var Parser$3 = parser$2.exports = function(options, dependencies) {

  this._options = options;
  options.checkCRC = options.checkCRC !== false;

  this._hasIHDR = false;
  this._hasIEND = false;
  this._emittedHeadersFinished = false;

  // input flags/metadata
  this._palette = [];
  this._colorType = 0;

  this._chunks = {};
  this._chunks[constants$4.TYPE_IHDR] = this._handleIHDR.bind(this);
  this._chunks[constants$4.TYPE_IEND] = this._handleIEND.bind(this);
  this._chunks[constants$4.TYPE_IDAT] = this._handleIDAT.bind(this);
  this._chunks[constants$4.TYPE_PLTE] = this._handlePLTE.bind(this);
  this._chunks[constants$4.TYPE_tRNS] = this._handleTRNS.bind(this);
  this._chunks[constants$4.TYPE_gAMA] = this._handleGAMA.bind(this);

  this.read = dependencies.read;
  this.error = dependencies.error;
  this.metadata = dependencies.metadata;
  this.gamma = dependencies.gamma;
  this.transColor = dependencies.transColor;
  this.palette = dependencies.palette;
  this.parsed = dependencies.parsed;
  this.inflateData = dependencies.inflateData;
  this.finished = dependencies.finished;
  this.simpleTransparency = dependencies.simpleTransparency;
  this.headersFinished = dependencies.headersFinished || function() {};
};

Parser$3.prototype.start = function() {
  this.read(constants$4.PNG_SIGNATURE.length,
    this._parseSignature.bind(this)
  );
};

Parser$3.prototype._parseSignature = function(data) {

  var signature = constants$4.PNG_SIGNATURE;

  for (var i = 0; i < signature.length; i++) {
    if (data[i] !== signature[i]) {
      this.error(new Error('Invalid file signature'));
      return;
    }
  }
  this.read(8, this._parseChunkBegin.bind(this));
};

Parser$3.prototype._parseChunkBegin = function(data) {

  // chunk content length
  var length = data.readUInt32BE(0);

  // chunk type
  var type = data.readUInt32BE(4);
  var name = '';
  for (var i = 4; i < 8; i++) {
    name += String.fromCharCode(data[i]);
  }

  //console.log('chunk ', name, length);

  // chunk flags
  var ancillary = Boolean(data[4] & 0x20); // or critical
  //    priv = Boolean(data[5] & 0x20), // or public
  //    safeToCopy = Boolean(data[7] & 0x20); // or unsafe

  if (!this._hasIHDR && type !== constants$4.TYPE_IHDR) {
    this.error(new Error('Expected IHDR on beggining'));
    return;
  }

  this._crc = new CrcCalculator();
  this._crc.write(new Buffer$1(name));

  if (this._chunks[type]) {
    return this._chunks[type](length);
  }

  if (!ancillary) {
    this.error(new Error('Unsupported critical chunk type ' + name));
    return;
  }

  this.read(length + 4, this._skipChunk.bind(this));
};

Parser$3.prototype._skipChunk = function(/*data*/) {
  this.read(8, this._parseChunkBegin.bind(this));
};

Parser$3.prototype._handleChunkEnd = function() {
  this.read(4, this._parseChunkEnd.bind(this));
};

Parser$3.prototype._parseChunkEnd = function(data) {

  var fileCrc = data.readInt32BE(0);
  var calcCrc = this._crc.crc32();

  // check CRC
  if (this._options.checkCRC && calcCrc !== fileCrc) {
    this.error(new Error('Crc error - ' + fileCrc + ' - ' + calcCrc));
    return;
  }

  if (!this._hasIEND) {
    this.read(8, this._parseChunkBegin.bind(this));
  }
};

Parser$3.prototype._handleIHDR = function(length) {
  this.read(length, this._parseIHDR.bind(this));
};
Parser$3.prototype._parseIHDR = function(data) {

  this._crc.write(data);

  var width = data.readUInt32BE(0);
  var height = data.readUInt32BE(4);
  var depth = data[8];
  var colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha
  var compr = data[10];
  var filter = data[11];
  var interlace = data[12];

  // console.log('    width', width, 'height', height,
  //     'depth', depth, 'colorType', colorType,
  //     'compr', compr, 'filter', filter, 'interlace', interlace
  // );

  if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
    this.error(new Error('Unsupported bit depth ' + depth));
    return;
  }
  if (!(colorType in constants$4.COLORTYPE_TO_BPP_MAP)) {
    this.error(new Error('Unsupported color type'));
    return;
  }
  if (compr !== 0) {
    this.error(new Error('Unsupported compression method'));
    return;
  }
  if (filter !== 0) {
    this.error(new Error('Unsupported filter method'));
    return;
  }
  if (interlace !== 0 && interlace !== 1) {
    this.error(new Error('Unsupported interlace method'));
    return;
  }

  this._colorType = colorType;

  var bpp = constants$4.COLORTYPE_TO_BPP_MAP[this._colorType];

  this._hasIHDR = true;

  this.metadata({
    width: width,
    height: height,
    depth: depth,
    interlace: Boolean(interlace),
    palette: Boolean(colorType & constants$4.COLORTYPE_PALETTE),
    color: Boolean(colorType & constants$4.COLORTYPE_COLOR),
    alpha: Boolean(colorType & constants$4.COLORTYPE_ALPHA),
    bpp: bpp,
    colorType: colorType
  });

  this._handleChunkEnd();
};


Parser$3.prototype._handlePLTE = function(length) {
  this.read(length, this._parsePLTE.bind(this));
};
Parser$3.prototype._parsePLTE = function(data) {

  this._crc.write(data);

  var entries = Math.floor(data.length / 3);
  // console.log('Palette:', entries);

  for (var i = 0; i < entries; i++) {
    this._palette.push([
      data[i * 3],
      data[i * 3 + 1],
      data[i * 3 + 2],
      0xff
    ]);
  }

  this.palette(this._palette);

  this._handleChunkEnd();
};

Parser$3.prototype._handleTRNS = function(length) {
  this.simpleTransparency();
  this.read(length, this._parseTRNS.bind(this));
};
Parser$3.prototype._parseTRNS = function(data) {

  this._crc.write(data);

  // palette
  if (this._colorType === constants$4.COLORTYPE_PALETTE_COLOR) {
    if (this._palette.length === 0) {
      this.error(new Error('Transparency chunk must be after palette'));
      return;
    }
    if (data.length > this._palette.length) {
      this.error(new Error('More transparent colors than palette size'));
      return;
    }
    for (var i = 0; i < data.length; i++) {
      this._palette[i][3] = data[i];
    }
    this.palette(this._palette);
  }

  // for colorType 0 (grayscale) and 2 (rgb)
  // there might be one gray/color defined as transparent
  if (this._colorType === constants$4.COLORTYPE_GRAYSCALE) {
    // grey, 2 bytes
    this.transColor([data.readUInt16BE(0)]);
  }
  if (this._colorType === constants$4.COLORTYPE_COLOR) {
    this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
  }

  this._handleChunkEnd();
};

Parser$3.prototype._handleGAMA = function(length) {
  this.read(length, this._parseGAMA.bind(this));
};
Parser$3.prototype._parseGAMA = function(data) {

  this._crc.write(data);
  this.gamma(data.readUInt32BE(0) / constants$4.GAMMA_DIVISION);

  this._handleChunkEnd();
};

Parser$3.prototype._handleIDAT = function(length) {
  if (!this._emittedHeadersFinished) {
    this._emittedHeadersFinished = true;
    this.headersFinished();
  }
  this.read(-length, this._parseIDAT.bind(this, length));
};
Parser$3.prototype._parseIDAT = function(length, data) {

  this._crc.write(data);

  if (this._colorType === constants$4.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
    throw new Error('Expected palette not found');
  }

  this.inflateData(data);
  var leftOverLength = length - data.length;

  if (leftOverLength > 0) {
    this._handleIDAT(leftOverLength);
  }
  else {
    this._handleChunkEnd();
  }
};

Parser$3.prototype._handleIEND = function(length) {
  this.read(length, this._parseIEND.bind(this));
};
Parser$3.prototype._parseIEND = function(data) {

  this._crc.write(data);

  this._hasIEND = true;
  this._handleChunkEnd();

  if (this.finished) {
    this.finished();
  }
};

var parser = parser$2.exports;

var parser$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), parser$2.exports, {
    'default': parser
}));

var require$$4$2 = /*@__PURE__*/getAugmentedNamespace(parser$1);

var bitmapper$3 = {};

var interlaceUtils = require$$0$5;

var pixelBppMapper = [
  // 0 - dummy entry
  function() {},

  // 1 - L
  // 0: 0, 1: 0, 2: 0, 3: 0xff
  function(pxData, data, pxPos, rawPos) {
    if (rawPos === data.length) {
      throw new Error('Ran out of data');
    }

    var pixel = data[rawPos];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = 0xff;
  },

  // 2 - LA
  // 0: 0, 1: 0, 2: 0, 3: 1
  function(pxData, data, pxPos, rawPos) {
    if (rawPos + 1 >= data.length) {
      throw new Error('Ran out of data');
    }

    var pixel = data[rawPos];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = data[rawPos + 1];
  },

  // 3 - RGB
  // 0: 0, 1: 1, 2: 2, 3: 0xff
  function(pxData, data, pxPos, rawPos) {
    if (rawPos + 2 >= data.length) {
      throw new Error('Ran out of data');
    }

    pxData[pxPos] = data[rawPos];
    pxData[pxPos + 1] = data[rawPos + 1];
    pxData[pxPos + 2] = data[rawPos + 2];
    pxData[pxPos + 3] = 0xff;
  },

  // 4 - RGBA
  // 0: 0, 1: 1, 2: 2, 3: 3
  function(pxData, data, pxPos, rawPos) {
    if (rawPos + 3 >= data.length) {
      throw new Error('Ran out of data');
    }

    pxData[pxPos] = data[rawPos];
    pxData[pxPos + 1] = data[rawPos + 1];
    pxData[pxPos + 2] = data[rawPos + 2];
    pxData[pxPos + 3] = data[rawPos + 3];
  }
];

var pixelBppCustomMapper = [
  // 0 - dummy entry
  function() {},

  // 1 - L
  // 0: 0, 1: 0, 2: 0, 3: 0xff
  function(pxData, pixelData, pxPos, maxBit) {
    var pixel = pixelData[0];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = maxBit;
  },

  // 2 - LA
  // 0: 0, 1: 0, 2: 0, 3: 1
  function(pxData, pixelData, pxPos) {
    var pixel = pixelData[0];
    pxData[pxPos] = pixel;
    pxData[pxPos + 1] = pixel;
    pxData[pxPos + 2] = pixel;
    pxData[pxPos + 3] = pixelData[1];
  },

  // 3 - RGB
  // 0: 0, 1: 1, 2: 2, 3: 0xff
  function(pxData, pixelData, pxPos, maxBit) {
    pxData[pxPos] = pixelData[0];
    pxData[pxPos + 1] = pixelData[1];
    pxData[pxPos + 2] = pixelData[2];
    pxData[pxPos + 3] = maxBit;
  },

  // 4 - RGBA
  // 0: 0, 1: 1, 2: 2, 3: 3
  function(pxData, pixelData, pxPos) {
    pxData[pxPos] = pixelData[0];
    pxData[pxPos + 1] = pixelData[1];
    pxData[pxPos + 2] = pixelData[2];
    pxData[pxPos + 3] = pixelData[3];
  }
];

function bitRetriever(data, depth) {

  var leftOver = [];
  var i = 0;

  function split() {
    if (i === data.length) {
      throw new Error('Ran out of data');
    }
    var byte = data[i];
    i++;
    var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
    switch (depth) {
      default:
        throw new Error('unrecognised depth');
      case 16:
        byte2 = data[i];
        i++;
        leftOver.push(((byte << 8) + byte2));
        break;
      case 4:
        byte2 = byte & 0x0f;
        byte1 = byte >> 4;
        leftOver.push(byte1, byte2);
        break;
      case 2:
        byte4 = byte & 3;
        byte3 = byte >> 2 & 3;
        byte2 = byte >> 4 & 3;
        byte1 = byte >> 6 & 3;
        leftOver.push(byte1, byte2, byte3, byte4);
        break;
      case 1:
        byte8 = byte & 1;
        byte7 = byte >> 1 & 1;
        byte6 = byte >> 2 & 1;
        byte5 = byte >> 3 & 1;
        byte4 = byte >> 4 & 1;
        byte3 = byte >> 5 & 1;
        byte2 = byte >> 6 & 1;
        byte1 = byte >> 7 & 1;
        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
        break;
    }
  }

  return {
    get: function(count) {
      while (leftOver.length < count) {
        split();
      }
      var returner = leftOver.slice(0, count);
      leftOver = leftOver.slice(count);
      return returner;
    },
    resetAfterLine: function() {
      leftOver.length = 0;
    },
    end: function() {
      if (i !== data.length) {
        throw new Error('extra data found');
      }
    }
  };
}

function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) { // eslint-disable-line max-params
  var imageWidth = image.width;
  var imageHeight = image.height;
  var imagePass = image.index;
  for (var y = 0; y < imageHeight; y++) {
    for (var x = 0; x < imageWidth; x++) {
      var pxPos = getPxPos(x, y, imagePass);
      pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
      rawPos += bpp; //eslint-disable-line no-param-reassign
    }
  }
  return rawPos;
}

function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) { // eslint-disable-line max-params
  var imageWidth = image.width;
  var imageHeight = image.height;
  var imagePass = image.index;
  for (var y = 0; y < imageHeight; y++) {
    for (var x = 0; x < imageWidth; x++) {
      var pixelData = bits.get(bpp);
      var pxPos = getPxPos(x, y, imagePass);
      pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
    }
    bits.resetAfterLine();
  }
}

var dataToBitMap = bitmapper$3.dataToBitMap = function(data, bitmapInfo) {

  var width = bitmapInfo.width;
  var height = bitmapInfo.height;
  var depth = bitmapInfo.depth;
  var bpp = bitmapInfo.bpp;
  var interlace = bitmapInfo.interlace;

  if (depth !== 8) {
    var bits = bitRetriever(data, depth);
  }
  var pxData;
  if (depth <= 8) {
    pxData = new Buffer$1(width * height * 4);
  }
  else {
    pxData = new Uint16Array(width * height * 4);
  }
  var maxBit = Math.pow(2, depth) - 1;
  var rawPos = 0;
  var images;
  var getPxPos;

  if (interlace) {
    images = interlaceUtils.getImagePasses(width, height);
    getPxPos = interlaceUtils.getInterlaceIterator(width, height);
  }
  else {
    var nonInterlacedPxPos = 0;
    getPxPos = function() {
      var returner = nonInterlacedPxPos;
      nonInterlacedPxPos += 4;
      return returner;
    };
    images = [{ width: width, height: height }];
  }

  for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
    if (depth === 8) {
      rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
    }
    else {
      mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
    }
  }
  if (depth === 8) {
    if (rawPos !== data.length) {
      throw new Error('extra data found');
    }
  }
  else {
    bits.end();
  }

  return pxData;
};

var bitmapper$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bitmapper$3, {
    'default': bitmapper$3,
    dataToBitMap: dataToBitMap
}));

var require$$5$1 = /*@__PURE__*/getAugmentedNamespace(bitmapper$2);

function dePalette(indata, outdata, width, height, palette) {
  var pxPos = 0;
  // use values from palette
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var color = palette[indata[pxPos]];

      if (!color) {
        throw new Error('index ' + indata[pxPos] + ' not in palette');
      }

      for (var i = 0; i < 4; i++) {
        outdata[pxPos + i] = color[i];
      }
      pxPos += 4;
    }
  }
}

function replaceTransparentColor(indata, outdata, width, height, transColor) {
  var pxPos = 0;
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var makeTrans = false;

      if (transColor.length === 1) {
        if (transColor[0] === indata[pxPos]) {
          makeTrans = true;
        }
      }
      else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
        makeTrans = true;
      }
      if (makeTrans) {
        for (var i = 0; i < 4; i++) {
          outdata[pxPos + i] = 0;
        }
      }
      pxPos += 4;
    }
  }
}

function scaleDepth(indata, outdata, width, height, depth) {
  var maxOutSample = 255;
  var maxInSample = Math.pow(2, depth) - 1;
  var pxPos = 0;

  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      for (var i = 0; i < 4; i++) {
        outdata[pxPos + i] = Math.floor((indata[pxPos + i] * maxOutSample) / maxInSample + 0.5);
      }
      pxPos += 4;
    }
  }
}

var formatNormaliser$2 = function(indata, imageData) {

  var depth = imageData.depth;
  var width = imageData.width;
  var height = imageData.height;
  var colorType = imageData.colorType;
  var transColor = imageData.transColor;
  var palette = imageData.palette;

  var outdata = indata; // only different for 16 bits

  if (colorType === 3) { // paletted
    dePalette(indata, outdata, width, height, palette);
  }
  else {
    if (transColor) {
      replaceTransparentColor(indata, outdata, width, height, transColor);
    }
    // if it needs scaling
    if (depth !== 8) {
      // if we need to change the buffer size
      if (depth === 16) {
        outdata = new Buffer$1(width * height * 4);
      }
      scaleDepth(indata, outdata, width, height, depth);
    }
  }
  return outdata;
};

var formatNormaliser$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), formatNormaliser$2, {
    'default': formatNormaliser$2
}));

var require$$6$1 = /*@__PURE__*/getAugmentedNamespace(formatNormaliser$3);

var util$2 = require$$0$10;
var zlib$3 = require$$0$_;
var ChunkStream = require$$2$6;
var FilterAsync = require$$3$6;
var Parser$2 = require$$4$2;
var bitmapper$1 = require$$5$1;
var formatNormaliser$1 = require$$6$1;

var ParserAsync = parserAsync$2.exports = function(options) {
  ChunkStream.call(this);

  this._parser = new Parser$2(options, {
    read: this.read.bind(this),
    error: this._handleError.bind(this),
    metadata: this._handleMetaData.bind(this),
    gamma: this.emit.bind(this, 'gamma'),
    palette: this._handlePalette.bind(this),
    transColor: this._handleTransColor.bind(this),
    finished: this._finished.bind(this),
    inflateData: this._inflateData.bind(this),
    simpleTransparency: this._simpleTransparency.bind(this),
    headersFinished: this._headersFinished.bind(this)
  });
  this._options = options;
  this.writable = true;

  this._parser.start();
};
util$2.inherits(ParserAsync, ChunkStream);


ParserAsync.prototype._handleError = function(err) {

  this.emit('error', err);

  this.writable = false;

  this.destroy();

  if (this._inflate && this._inflate.destroy) {
    this._inflate.destroy();
  }

  if (this._filter) {
    this._filter.destroy();
    // For backward compatibility with Node 7 and below.
    // Suppress errors due to _inflate calling write() even after
    // it's destroy()'ed.
    this._filter.on('error', function() {});
  }

  this.errord = true;
};

ParserAsync.prototype._inflateData = function(data) {
  if (!this._inflate) {
    if (this._bitmapInfo.interlace) {
      this._inflate = zlib$3.createInflate();

      this._inflate.on('error', this.emit.bind(this, 'error'));
      this._filter.on('complete', this._complete.bind(this));

      this._inflate.pipe(this._filter);
    }
    else {
      var rowSize = ((this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7) >> 3) + 1;
      var imageSize = rowSize * this._bitmapInfo.height;
      var chunkSize = Math.max(imageSize, zlib$3.Z_MIN_CHUNK);

      this._inflate = zlib$3.createInflate({ chunkSize: chunkSize });
      var leftToInflate = imageSize;

      var emitError = this.emit.bind(this, 'error');
      this._inflate.on('error', function(err) {
        if (!leftToInflate) {
          return;
        }

        emitError(err);
      });
      this._filter.on('complete', this._complete.bind(this));

      var filterWrite = this._filter.write.bind(this._filter);
      this._inflate.on('data', function(chunk) {
        if (!leftToInflate) {
          return;
        }

        if (chunk.length > leftToInflate) {
          chunk = chunk.slice(0, leftToInflate);
        }

        leftToInflate -= chunk.length;

        filterWrite(chunk);
      });

      this._inflate.on('end', this._filter.end.bind(this._filter));
    }
  }
  this._inflate.write(data);
};

ParserAsync.prototype._handleMetaData = function(metaData) {
  this._metaData = metaData;
  this._bitmapInfo = Object.create(metaData);

  this._filter = new FilterAsync(this._bitmapInfo);
};

ParserAsync.prototype._handleTransColor = function(transColor) {
  this._bitmapInfo.transColor = transColor;
};

ParserAsync.prototype._handlePalette = function(palette) {
  this._bitmapInfo.palette = palette;
};

ParserAsync.prototype._simpleTransparency = function() {
  this._metaData.alpha = true;
};

ParserAsync.prototype._headersFinished = function() {
  // Up until this point, we don't know if we have a tRNS chunk (alpha)
  // so we can't emit metadata any earlier
  this.emit('metadata', this._metaData);
};

ParserAsync.prototype._finished = function() {
  if (this.errord) {
    return;
  }

  if (!this._inflate) {
    this.emit('error', 'No Inflate block');
  }
  else {
    // no more data to inflate
    this._inflate.end();
  }
  this.destroySoon();
};

ParserAsync.prototype._complete = function(filteredData) {

  if (this.errord) {
    return;
  }

  try {
    var bitmapData = bitmapper$1.dataToBitMap(filteredData, this._bitmapInfo);

    var normalisedBitmapData = formatNormaliser$1(bitmapData, this._bitmapInfo);
    bitmapData = null;
  }
  catch (ex) {
    this._handleError(ex);
    return;
  }

  this.emit('parsed', normalisedBitmapData);
};

var parserAsync = parserAsync$2.exports;

var parserAsync$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), parserAsync$2.exports, {
    'default': parserAsync
}));

var require$$2$5 = /*@__PURE__*/getAugmentedNamespace(parserAsync$1);

var packerAsync$2 = {exports: {}};

var packer$2 = {exports: {}};

var constants$3 = require$$1$6;

var bitpacker = function(dataIn, width, height, options) {
  var outHasAlpha = [constants$3.COLORTYPE_COLOR_ALPHA, constants$3.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
  if (options.colorType === options.inputColorType) {
    var bigEndian = (function() {
      var buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
      // Int16Array uses the platform's endianness.
      return new Int16Array(buffer)[0] !== 256;
    })();
    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route
    if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)) {
      return dataIn;
    }
  }

  // map to a UInt16 array if data is 16bit, fix endianness below
  var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);

  var maxValue = 255;
  var inBpp = constants$3.COLORTYPE_TO_BPP_MAP[options.inputColorType];
  if (inBpp === 4 && !options.inputHasAlpha) {
    inBpp = 3;
  }
  var outBpp = constants$3.COLORTYPE_TO_BPP_MAP[options.colorType];
  if (options.bitDepth === 16) {
    maxValue = 65535;
    outBpp *= 2;
  }
  var outData = new Buffer$1(width * height * outBpp);

  var inIndex = 0;
  var outIndex = 0;

  var bgColor = options.bgColor || {};
  if (bgColor.red === undefined) {
    bgColor.red = maxValue;
  }
  if (bgColor.green === undefined) {
    bgColor.green = maxValue;
  }
  if (bgColor.blue === undefined) {
    bgColor.blue = maxValue;
  }

  function getRGBA() {
    var red;
    var green;
    var blue;
    var alpha = maxValue;
    switch (options.inputColorType) {
      case constants$3.COLORTYPE_COLOR_ALPHA:
        alpha = data[inIndex + 3];
        red = data[inIndex];
        green = data[inIndex + 1];
        blue = data[inIndex + 2];
        break;
      case constants$3.COLORTYPE_COLOR:
        red = data[inIndex];
        green = data[inIndex + 1];
        blue = data[inIndex + 2];
        break;
      case constants$3.COLORTYPE_ALPHA:
        alpha = data[inIndex + 1];
        red = data[inIndex];
        green = red;
        blue = red;
        break;
      case constants$3.COLORTYPE_GRAYSCALE:
        red = data[inIndex];
        green = red;
        blue = red;
        break;
      default:
        throw new Error('input color type:' + options.inputColorType + ' is not supported at present');
    }

    if (options.inputHasAlpha) {
      if (!outHasAlpha) {
        alpha /= maxValue;
        red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
        green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
        blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
      }
    }
    return { red: red, green: green, blue: blue, alpha: alpha };
  }

  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var rgba = getRGBA();

      switch (options.colorType) {
        case constants$3.COLORTYPE_COLOR_ALPHA:
        case constants$3.COLORTYPE_COLOR:
          if (options.bitDepth === 8) {
            outData[outIndex] = rgba.red;
            outData[outIndex + 1] = rgba.green;
            outData[outIndex + 2] = rgba.blue;
            if (outHasAlpha) {
              outData[outIndex + 3] = rgba.alpha;
            }
          }
          else {
            outData.writeUInt16BE(rgba.red, outIndex);
            outData.writeUInt16BE(rgba.green, outIndex + 2);
            outData.writeUInt16BE(rgba.blue, outIndex + 4);
            if (outHasAlpha) {
              outData.writeUInt16BE(rgba.alpha, outIndex + 6);
            }
          }
          break;
        case constants$3.COLORTYPE_ALPHA:
        case constants$3.COLORTYPE_GRAYSCALE:
          // Convert to grayscale and alpha
          var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
          if (options.bitDepth === 8) {
            outData[outIndex] = grayscale;
            if (outHasAlpha) {
              outData[outIndex + 1] = rgba.alpha;
            }
          }
          else {
            outData.writeUInt16BE(grayscale, outIndex);
            if (outHasAlpha) {
              outData.writeUInt16BE(rgba.alpha, outIndex + 2);
            }
          }
          break;
        default:
          throw new Error('unrecognised color Type ' + options.colorType);
      }

      inIndex += inBpp;
      outIndex += outBpp;
    }
  }

  return outData;
};

var bitpacker$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), bitpacker, {
    'default': bitpacker
}));

var require$$2$4 = /*@__PURE__*/getAugmentedNamespace(bitpacker$1);

var paethPredictor = require$$0$4;

function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {

  for (var x = 0; x < byteWidth; x++) {
    rawData[rawPos + x] = pxData[pxPos + x];
  }
}

function filterSumNone(pxData, pxPos, byteWidth) {

  var sum = 0;
  var length = pxPos + byteWidth;

  for (var i = pxPos; i < length; i++) {
    sum += Math.abs(pxData[i]);
  }
  return sum;
}

function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {

  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var val = pxData[pxPos + x] - left;

    rawData[rawPos + x] = val;
  }
}

function filterSumSub(pxData, pxPos, byteWidth, bpp) {

  var sum = 0;
  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var val = pxData[pxPos + x] - left;

    sum += Math.abs(val);
  }

  return sum;
}

function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {

  for (var x = 0; x < byteWidth; x++) {

    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var val = pxData[pxPos + x] - up;

    rawData[rawPos + x] = val;
  }
}

function filterSumUp(pxData, pxPos, byteWidth) {

  var sum = 0;
  var length = pxPos + byteWidth;
  for (var x = pxPos; x < length; x++) {

    var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
    var val = pxData[x] - up;

    sum += Math.abs(val);
  }

  return sum;
}

function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {

  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var val = pxData[pxPos + x] - ((left + up) >> 1);

    rawData[rawPos + x] = val;
  }
}

function filterSumAvg(pxData, pxPos, byteWidth, bpp) {

  var sum = 0;
  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var val = pxData[pxPos + x] - ((left + up) >> 1);

    sum += Math.abs(val);
  }

  return sum;
}

function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {

  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
    var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

    rawData[rawPos + x] = val;
  }
}

function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
  var sum = 0;
  for (var x = 0; x < byteWidth; x++) {

    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
    var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
    var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

    sum += Math.abs(val);
  }

  return sum;
}

var filters = {
  0: filterNone,
  1: filterSub,
  2: filterUp,
  3: filterAvg,
  4: filterPaeth
};

var filterSums = {
  0: filterSumNone,
  1: filterSumSub,
  2: filterSumUp,
  3: filterSumAvg,
  4: filterSumPaeth
};

var filterPack = function(pxData, width, height, options, bpp) {

  var filterTypes;
  if (!('filterType' in options) || options.filterType === -1) {
    filterTypes = [0, 1, 2, 3, 4];
  }
  else if (typeof options.filterType === 'number') {
    filterTypes = [options.filterType];
  }
  else {
    throw new Error('unrecognised filter types');
  }

  if (options.bitDepth === 16) {
    bpp *= 2;
  }
  var byteWidth = width * bpp;
  var rawPos = 0;
  var pxPos = 0;
  var rawData = new Buffer$1((byteWidth + 1) * height);

  var sel = filterTypes[0];

  for (var y = 0; y < height; y++) {

    if (filterTypes.length > 1) {
      // find best filter for this line (with lowest sum of values)
      var min = Infinity;

      for (var i = 0; i < filterTypes.length; i++) {
        var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
        if (sum < min) {
          sel = filterTypes[i];
          min = sum;
        }
      }
    }

    rawData[rawPos] = sel;
    rawPos++;
    filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
    rawPos += byteWidth;
    pxPos += byteWidth;
  }
  return rawData;
};

var filterPack$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), filterPack, {
    'default': filterPack
}));

var require$$3$5 = /*@__PURE__*/getAugmentedNamespace(filterPack$1);

var constants$2 = require$$1$6;
var CrcStream = require$$1$5;
var bitPacker = require$$2$4;
var filter = require$$3$5;
var zlib$2 = require$$0$_;

var Packer$3 = packer$2.exports = function(options) {
  this._options = options;

  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
  options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
  options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
  options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
  options.deflateFactory = options.deflateFactory || zlib$2.createDeflate;
  options.bitDepth = options.bitDepth || 8;
  // This is outputColorType
  options.colorType = (typeof options.colorType === 'number') ? options.colorType : constants$2.COLORTYPE_COLOR_ALPHA;
  options.inputColorType = (typeof options.inputColorType === 'number') ? options.inputColorType : constants$2.COLORTYPE_COLOR_ALPHA;

  if ([
    constants$2.COLORTYPE_GRAYSCALE,
    constants$2.COLORTYPE_COLOR,
    constants$2.COLORTYPE_COLOR_ALPHA,
    constants$2.COLORTYPE_ALPHA
  ].indexOf(options.colorType) === -1) {
    throw new Error('option color type:' + options.colorType + ' is not supported at present');
  }
  if ([
    constants$2.COLORTYPE_GRAYSCALE,
    constants$2.COLORTYPE_COLOR,
    constants$2.COLORTYPE_COLOR_ALPHA,
    constants$2.COLORTYPE_ALPHA
  ].indexOf(options.inputColorType) === -1) {
    throw new Error('option input color type:' + options.inputColorType + ' is not supported at present');
  }
  if (options.bitDepth !== 8 && options.bitDepth !== 16) {
    throw new Error('option bit depth:' + options.bitDepth + ' is not supported at present');
  }
};

Packer$3.prototype.getDeflateOptions = function() {
  return {
    chunkSize: this._options.deflateChunkSize,
    level: this._options.deflateLevel,
    strategy: this._options.deflateStrategy
  };
};

Packer$3.prototype.createDeflate = function() {
  return this._options.deflateFactory(this.getDeflateOptions());
};

Packer$3.prototype.filterData = function(data, width, height) {
  // convert to correct format for filtering (e.g. right bpp and bit depth)
  var packedData = bitPacker(data, width, height, this._options);

  // filter pixel data
  var bpp = constants$2.COLORTYPE_TO_BPP_MAP[this._options.colorType];
  var filteredData = filter(packedData, width, height, this._options, bpp);
  return filteredData;
};

Packer$3.prototype._packChunk = function(type, data) {

  var len = (data ? data.length : 0);
  var buf = new Buffer$1(len + 12);

  buf.writeUInt32BE(len, 0);
  buf.writeUInt32BE(type, 4);

  if (data) {
    data.copy(buf, 8);
  }

  buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
  return buf;
};

Packer$3.prototype.packGAMA = function(gamma) {
  var buf = new Buffer$1(4);
  buf.writeUInt32BE(Math.floor(gamma * constants$2.GAMMA_DIVISION), 0);
  return this._packChunk(constants$2.TYPE_gAMA, buf);
};

Packer$3.prototype.packIHDR = function(width, height) {

  var buf = new Buffer$1(13);
  buf.writeUInt32BE(width, 0);
  buf.writeUInt32BE(height, 4);
  buf[8] = this._options.bitDepth; // Bit depth
  buf[9] = this._options.colorType; // colorType
  buf[10] = 0; // compression
  buf[11] = 0; // filter
  buf[12] = 0; // interlace

  return this._packChunk(constants$2.TYPE_IHDR, buf);
};

Packer$3.prototype.packIDAT = function(data) {
  return this._packChunk(constants$2.TYPE_IDAT, data);
};

Packer$3.prototype.packIEND = function() {
  return this._packChunk(constants$2.TYPE_IEND, null);
};

var packer = packer$2.exports;

var packer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), packer$2.exports, {
    'default': packer
}));

var require$$2$3 = /*@__PURE__*/getAugmentedNamespace(packer$1);

var util$1 = require$$0$10;
var Stream$1 = require$$1$1b;
var constants$1 = require$$1$6;
var Packer$2 = require$$2$3;

var PackerAsync = packerAsync$2.exports = function(opt) {
  Stream$1.call(this);

  var options = opt || {};

  this._packer = new Packer$2(options);
  this._deflate = this._packer.createDeflate();

  this.readable = true;
};
util$1.inherits(PackerAsync, Stream$1);


PackerAsync.prototype.pack = function(data, width, height, gamma) {
  // Signature
  this.emit('data', new Buffer$1(constants$1.PNG_SIGNATURE));
  this.emit('data', this._packer.packIHDR(width, height));

  if (gamma) {
    this.emit('data', this._packer.packGAMA(gamma));
  }

  var filteredData = this._packer.filterData(data, width, height);

  // compress it
  this._deflate.on('error', this.emit.bind(this, 'error'));

  this._deflate.on('data', function(compressedData) {
    this.emit('data', this._packer.packIDAT(compressedData));
  }.bind(this));

  this._deflate.on('end', function() {
    this.emit('data', this._packer.packIEND());
    this.emit('end');
  }.bind(this));

  this._deflate.end(filteredData);
};

var packerAsync = packerAsync$2.exports;

var packerAsync$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), packerAsync$2.exports, {
    'default': packerAsync
}));

var require$$3$4 = /*@__PURE__*/getAugmentedNamespace(packerAsync$1);

var pngSync$1 = {};

var syncInflate$2 = {exports: {}};

(function (module, exports) {

var assert = require$$0$14.ok;
var zlib = require$$0$_;
var util = require$$0$10;

var kMaxLength = require$$0$Z.kMaxLength;

function Inflate(opts) {
  if (!(this instanceof Inflate)) {
    return new Inflate(opts);
  }

  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
    opts.chunkSize = zlib.Z_MIN_CHUNK;
  }

  zlib.Inflate.call(this, opts);

  // Node 8 --> 9 compatibility check
  this._offset = this._offset === undefined ? this._outOffset : this._offset;
  this._buffer = this._buffer || this._outBuffer;

  if (opts && opts.maxLength != null) {
    this._maxLength = opts.maxLength;
  }
}

function createInflate(opts) {
  return new Inflate(opts);
}

function _close(engine, callback) {
  if (callback) {
    browser$1$1.nextTick(callback);
  }

  // Caller may invoke .close after a zlib error (which will null _handle).
  if (!engine._handle) {
    return;
  }

  engine._handle.close();
  engine._handle = null;
}

Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
  if (typeof asyncCb === 'function') {
    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
  }

  var self = this;

  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var leftToInflate = this._maxLength;
  var inOff = 0;

  var buffers = [];
  var nread = 0;

  var error;
  this.on('error', function(err) {
    error = err;
  });

  function handleChunk(availInAfter, availOutAfter) {
    if (self._hadError) {
      return;
    }

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;

      if (out.length > leftToInflate) {
        out = out.slice(0, leftToInflate);
      }

      buffers.push(out);
      nread += out.length;
      leftToInflate -= out.length;

      if (leftToInflate === 0) {
        return false;
      }
    }

    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer$1.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      return true;
    }

    return false;
  }

  assert(this._handle, 'zlib binding closed');
  do {
    var res = this._handle.writeSync(flushFlag,
      chunk, // in
      inOff, // in_off
      availInBefore, // in_len
      this._buffer, // out
      this._offset, //out_off
      availOutBefore); // out_len
    // Node 8 --> 9 compatibility check
    res = res || this._writeState;
  } while (!this._hadError && handleChunk(res[0], res[1]));

  if (this._hadError) {
    throw error;
  }

  if (nread >= kMaxLength) {
    _close(this);
    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');
  }

  var buf = Buffer$1.concat(buffers, nread);
  _close(this);

  return buf;
};

util.inherits(Inflate, zlib.Inflate);

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string') {
    buffer = Buffer$1.from(buffer);
  }
  if (!(buffer instanceof Buffer$1)) {
    throw new TypeError('Not a string or buffer');
  }

  var flushFlag = engine._finishFlushFlag;
  if (flushFlag == null) {
    flushFlag = zlib.Z_FINISH;
  }

  return engine._processChunk(buffer, flushFlag);
}

function inflateSync(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
}

module.exports = exports = inflateSync;
exports.Inflate = Inflate;
exports.createInflate = createInflate;
exports.inflateSync = inflateSync;
}(syncInflate$2, syncInflate$2.exports));

var syncInflate = syncInflate$2.exports;

var syncInflate$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), syncInflate$2.exports, {
    'default': syncInflate
}));

var require$$1$4 = /*@__PURE__*/getAugmentedNamespace(syncInflate$1);

var syncReader$2 = {exports: {}};

var SyncReader$2 = syncReader$2.exports = function(buffer) {

  this._buffer = buffer;
  this._reads = [];
};

SyncReader$2.prototype.read = function(length, callback) {

  this._reads.push({
    length: Math.abs(length), // if length < 0 then at most this length
    allowLess: length < 0,
    func: callback
  });
};

SyncReader$2.prototype.process = function() {

  // as long as there is any data and read requests
  while (this._reads.length > 0 && this._buffer.length) {

    var read = this._reads[0];

    if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {

      // ok there is any data so that we can satisfy this request
      this._reads.shift(); // == read

      var buf = this._buffer;

      this._buffer = buf.slice(read.length);

      read.func.call(this, buf.slice(0, read.length));

    }
    else {
      break;
    }

  }

  if (this._reads.length > 0) {
    return new Error('There are some read requests waitng on finished stream');
  }

  if (this._buffer.length > 0) {
    return new Error('unrecognised content at end of stream');
  }

};

var syncReader = syncReader$2.exports;

var syncReader$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), syncReader$2.exports, {
    'default': syncReader
}));

var require$$2$2 = /*@__PURE__*/getAugmentedNamespace(syncReader$1);

var filterParseSync$1 = {};

var SyncReader$1 = require$$2$2;
var Filter = require$$1$7;


var process = filterParseSync$1.process = function(inBuffer, bitmapInfo) {

  var outBuffers = [];
  var reader = new SyncReader$1(inBuffer);
  var filter = new Filter(bitmapInfo, {
    read: reader.read.bind(reader),
    write: function(bufferPart) {
      outBuffers.push(bufferPart);
    },
    complete: function() {
    }
  });

  filter.start();
  reader.process();

  return Buffer$1.concat(outBuffers);
};

var filterParseSync = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), filterParseSync$1, {
    'default': filterParseSync$1,
    process: process
}));

var require$$3$3 = /*@__PURE__*/getAugmentedNamespace(filterParseSync);

var hasSyncZlib$1 = true;
var zlib$1 = require$$0$_;
var inflateSync = require$$1$4;
if (!zlib$1.deflateSync) {
  hasSyncZlib$1 = false;
}
var SyncReader = require$$2$2;
var FilterSync = require$$3$3;
var Parser$1 = require$$4$2;
var bitmapper = require$$5$1;
var formatNormaliser = require$$6$1;


var parserSync = function(buffer, options) {

  if (!hasSyncZlib$1) {
    throw new Error('To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0');
  }

  var err;
  function handleError(_err_) {
    err = _err_;
  }

  var metaData;
  function handleMetaData(_metaData_) {
    metaData = _metaData_;
  }

  function handleTransColor(transColor) {
    metaData.transColor = transColor;
  }

  function handlePalette(palette) {
    metaData.palette = palette;
  }

  function handleSimpleTransparency() {
    metaData.alpha = true;
  }

  var gamma;
  function handleGamma(_gamma_) {
    gamma = _gamma_;
  }

  var inflateDataList = [];
  function handleInflateData(inflatedData) {
    inflateDataList.push(inflatedData);
  }

  var reader = new SyncReader(buffer);

  var parser = new Parser$1(options, {
    read: reader.read.bind(reader),
    error: handleError,
    metadata: handleMetaData,
    gamma: handleGamma,
    palette: handlePalette,
    transColor: handleTransColor,
    inflateData: handleInflateData,
    simpleTransparency: handleSimpleTransparency
  });

  parser.start();
  reader.process();

  if (err) {
    throw err;
  }

  //join together the inflate datas
  var inflateData = Buffer$1.concat(inflateDataList);
  inflateDataList.length = 0;

  var inflatedData;
  if (metaData.interlace) {
    inflatedData = zlib$1.inflateSync(inflateData);
  }
  else {
    var rowSize = ((metaData.width * metaData.bpp * metaData.depth + 7) >> 3) + 1;
    var imageSize = rowSize * metaData.height;
    inflatedData = inflateSync(inflateData, { chunkSize: imageSize, maxLength: imageSize });
  }
  inflateData = null;

  if (!inflatedData || !inflatedData.length) {
    throw new Error('bad png - invalid inflate data response');
  }

  var unfilteredData = FilterSync.process(inflatedData, metaData);
  inflateData = null;

  var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
  unfilteredData = null;

  var normalisedBitmapData = formatNormaliser(bitmapData, metaData);

  metaData.data = normalisedBitmapData;
  metaData.gamma = gamma || 0;

  return metaData;
};

var parserSync$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), parserSync, {
    'default': parserSync
}));

var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(parserSync$1);

var hasSyncZlib = true;
var zlib = require$$0$_;
if (!zlib.deflateSync) {
  hasSyncZlib = false;
}
var constants = require$$1$6;
var Packer$1 = require$$2$3;

var packerSync = function(metaData, opt) {

  if (!hasSyncZlib) {
    throw new Error('To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0');
  }

  var options = opt || {};

  var packer = new Packer$1(options);

  var chunks = [];

  // Signature
  chunks.push(new Buffer$1(constants.PNG_SIGNATURE));

  // Header
  chunks.push(packer.packIHDR(metaData.width, metaData.height));

  if (metaData.gamma) {
    chunks.push(packer.packGAMA(metaData.gamma));
  }

  var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);

  // compress it
  var compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
  filteredData = null;

  if (!compressedData || !compressedData.length) {
    throw new Error('bad png - invalid compressed data response');
  }
  chunks.push(packer.packIDAT(compressedData));

  // End
  chunks.push(packer.packIEND());

  return Buffer$1.concat(chunks);
};

var packerSync$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), packerSync, {
    'default': packerSync
}));

var require$$1$3 = /*@__PURE__*/getAugmentedNamespace(packerSync$1);

var parse = require$$0$3;
var pack = require$$1$3;


var read = pngSync$1.read = function(buffer, options) {

  return parse(buffer, options || {});
};

var write = pngSync$1.write = function(png, options) {

  return pack(png, options);
};

var pngSync = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), pngSync$1, {
    'default': pngSync$1,
    read: read,
    write: write
}));

var require$$4$1 = /*@__PURE__*/getAugmentedNamespace(pngSync);

var PNG_1;

var util = require$$0$10;
var Stream = require$$1$1b;
var Parser = require$$2$5;
var Packer = require$$3$4;
var PNGSync = require$$4$1;


var PNG = PNG_1 = png$2.PNG = function(options) {
  Stream.call(this);

  options = options || {}; // eslint-disable-line no-param-reassign

  // coerce pixel dimensions to integers (also coerces undefined -> 0):
  this.width = options.width | 0;
  this.height = options.height | 0;

  this.data = this.width > 0 && this.height > 0 ?
    new Buffer$1(4 * this.width * this.height) : null;

  if (options.fill && this.data) {
    this.data.fill(0);
  }

  this.gamma = 0;
  this.readable = this.writable = true;

  this._parser = new Parser(options);

  this._parser.on('error', this.emit.bind(this, 'error'));
  this._parser.on('close', this._handleClose.bind(this));
  this._parser.on('metadata', this._metadata.bind(this));
  this._parser.on('gamma', this._gamma.bind(this));
  this._parser.on('parsed', function(data) {
    this.data = data;
    this.emit('parsed', data);
  }.bind(this));

  this._packer = new Packer(options);
  this._packer.on('data', this.emit.bind(this, 'data'));
  this._packer.on('end', this.emit.bind(this, 'end'));
  this._parser.on('close', this._handleClose.bind(this));
  this._packer.on('error', this.emit.bind(this, 'error'));

};
util.inherits(PNG, Stream);

PNG.sync = PNGSync;

PNG.prototype.pack = function() {

  if (!this.data || !this.data.length) {
    this.emit('error', 'No data provided');
    return this;
  }

  browser$1$1.nextTick(function() {
    this._packer.pack(this.data, this.width, this.height, this.gamma);
  }.bind(this));

  return this;
};


PNG.prototype.parse = function(data, callback) {

  if (callback) {
    var onParsed, onError;

    onParsed = function(parsedData) {
      this.removeListener('error', onError);

      this.data = parsedData;
      callback(null, this);
    }.bind(this);

    onError = function(err) {
      this.removeListener('parsed', onParsed);

      callback(err, null);
    }.bind(this);

    this.once('parsed', onParsed);
    this.once('error', onError);
  }

  this.end(data);
  return this;
};

PNG.prototype.write = function(data) {
  this._parser.write(data);
  return true;
};

PNG.prototype.end = function(data) {
  this._parser.end(data);
};

PNG.prototype._metadata = function(metadata) {
  this.width = metadata.width;
  this.height = metadata.height;

  this.emit('metadata', metadata);
};

PNG.prototype._gamma = function(gamma) {
  this.gamma = gamma;
};

PNG.prototype._handleClose = function() {
  if (!this._parser.writable && !this._packer.readable) {
    this.emit('close');
  }
};


PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params
  // coerce pixel dimensions to integers (also coerces undefined -> 0):
  /* eslint-disable no-param-reassign */
  srcX |= 0;
  srcY |= 0;
  width |= 0;
  height |= 0;
  deltaX |= 0;
  deltaY |= 0;
  /* eslint-enable no-param-reassign */

  if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
    throw new Error('bitblt reading outside image');
  }

  if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
    throw new Error('bitblt writing outside image');
  }

  for (var y = 0; y < height; y++) {
    src.data.copy(dst.data,
      ((deltaY + y) * dst.width + deltaX) << 2,
      ((srcY + y) * src.width + srcX) << 2,
      ((srcY + y) * src.width + srcX + width) << 2
    );
  }
};


PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params

  PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
  return this;
};

PNG.adjustGamma = function(src) {
  if (src.gamma) {
    for (var y = 0; y < src.height; y++) {
      for (var x = 0; x < src.width; x++) {
        var idx = (src.width * y + x) << 2;

        for (var i = 0; i < 3; i++) {
          var sample = src.data[idx + i] / 255;
          sample = Math.pow(sample, 1 / 2.2 / src.gamma);
          src.data[idx + i] = Math.round(sample * 255);
        }
      }
    }
    src.gamma = 0;
  }
};

PNG.prototype.adjustGamma = function() {
  PNG.adjustGamma(this);
};

var png$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), png$2, {
    'default': png$2,
    get PNG () { return PNG_1; }
}));

var require$$1$2 = /*@__PURE__*/getAugmentedNamespace(png$1);

var utils$1 = {};

(function (exports) {
function hex2rgba (hex) {
  if (typeof hex === 'number') {
    hex = hex.toString();
  }

  if (typeof hex !== 'string') {
    throw new Error('Color should be defined as hex string')
  }

  var hexCode = hex.slice().replace('#', '').split('');
  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
    throw new Error('Invalid hex color: ' + hex)
  }

  // Convert from short to long form (fff -> ffffff)
  if (hexCode.length === 3 || hexCode.length === 4) {
    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
      return [c, c]
    }));
  }

  // Add default alpha value
  if (hexCode.length === 6) hexCode.push('F', 'F');

  var hexValue = parseInt(hexCode.join(''), 16);

  return {
    r: (hexValue >> 24) & 255,
    g: (hexValue >> 16) & 255,
    b: (hexValue >> 8) & 255,
    a: hexValue & 255,
    hex: '#' + hexCode.slice(0, 6).join('')
  }
}

exports.getOptions = function getOptions (options) {
  if (!options) options = {};
  if (!options.color) options.color = {};

  var margin = typeof options.margin === 'undefined' ||
    options.margin === null ||
    options.margin < 0 ? 4 : options.margin;

  var width = options.width && options.width >= 21 ? options.width : undefined;
  var scale = options.scale || 4;

  return {
    width: width,
    scale: width ? 4 : scale,
    margin: margin,
    color: {
      dark: hex2rgba(options.color.dark || '#000000ff'),
      light: hex2rgba(options.color.light || '#ffffffff')
    },
    type: options.type,
    rendererOpts: options.rendererOpts || {}
  }
};

exports.getScale = function getScale (qrSize, opts) {
  return opts.width && opts.width >= qrSize + opts.margin * 2
    ? opts.width / (qrSize + opts.margin * 2)
    : opts.scale
};

exports.getImageWidth = function getImageWidth (qrSize, opts) {
  var scale = exports.getScale(qrSize, opts);
  return Math.floor((qrSize + opts.margin * 2) * scale)
};

exports.qrToImageData = function qrToImageData (imgData, qr, opts) {
  var size = qr.modules.size;
  var data = qr.modules.data;
  var scale = exports.getScale(size, opts);
  var symbolSize = Math.floor((size + opts.margin * 2) * scale);
  var scaledMargin = opts.margin * scale;
  var palette = [opts.color.light, opts.color.dark];

  for (var i = 0; i < symbolSize; i++) {
    for (var j = 0; j < symbolSize; j++) {
      var posDst = (i * symbolSize + j) * 4;
      var pxColor = opts.color.light;

      if (i >= scaledMargin && j >= scaledMargin &&
        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
        var iSrc = Math.floor((i - scaledMargin) / scale);
        var jSrc = Math.floor((j - scaledMargin) / scale);
        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
      }

      imgData[posDst++] = pxColor.r;
      imgData[posDst++] = pxColor.g;
      imgData[posDst++] = pxColor.b;
      imgData[posDst] = pxColor.a;
    }
  }
};
}(utils$1));

var utils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), utils$1, {
    'default': utils$1
}));

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(utils);

(function (exports) {
var fs = require$$0$11;
var PNG = require$$1$2.PNG;
var Utils = require$$0$2;

exports.render = function render (qrData, options) {
  var opts = Utils.getOptions(options);
  var pngOpts = opts.rendererOpts;
  var size = Utils.getImageWidth(qrData.modules.size, opts);

  pngOpts.width = size;
  pngOpts.height = size;

  var pngImage = new PNG(pngOpts);
  Utils.qrToImageData(pngImage.data, qrData, opts);

  return pngImage
};

exports.renderToDataURL = function renderToDataURL (qrData, options, cb) {
  if (typeof cb === 'undefined') {
    cb = options;
    options = undefined;
  }

  exports.renderToBuffer(qrData, options, function (err, output) {
    if (err) cb(err);
    var url = 'data:image/png;base64,';
    url += output.toString('base64');
    cb(null, url);
  });
};

exports.renderToBuffer = function renderToBuffer (qrData, options, cb) {
  if (typeof cb === 'undefined') {
    cb = options;
    options = undefined;
  }

  var png = exports.render(qrData, options);
  var buffer = [];

  png.on('error', cb);

  png.on('data', function (data) {
    buffer.push(data);
  });

  png.on('end', function () {
    cb(null, Buffer$1.concat(buffer));
  });

  png.pack();
};

exports.renderToFile = function renderToFile (path, qrData, options, cb) {
  if (typeof cb === 'undefined') {
    cb = options;
    options = undefined;
  }

  var stream = fs.createWriteStream(path);
  stream.on('error', cb);
  stream.on('close', cb);

  exports.renderToFileStream(stream, qrData, options);
};

exports.renderToFileStream = function renderToFileStream (stream, qrData, options) {
  var png = exports.render(qrData, options);
  png.pack().pipe(stream);
};
}(png$3));

var png = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), png$3, {
    'default': png$3
}));

var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(png);

var utf8$1 = {};

(function (exports) {
var Utils = require$$0$2;

var BLOCK_CHAR = {
  WW: ' ',
  WB: '▄',
  BB: '█',
  BW: '▀'
};

var INVERTED_BLOCK_CHAR = {
  BB: ' ',
  BW: '▄',
  WW: '█',
  WB: '▀'
};

function getBlockChar (top, bottom, blocks) {
  if (top && bottom) return blocks.BB
  if (top && !bottom) return blocks.BW
  if (!top && bottom) return blocks.WB
  return blocks.WW
}

exports.render = function (qrData, options, cb) {
  var opts = Utils.getOptions(options);
  var blocks = BLOCK_CHAR;
  if (opts.color.dark.hex === '#ffffff' || opts.color.light.hex === '#000000') {
    blocks = INVERTED_BLOCK_CHAR;
  }

  var size = qrData.modules.size;
  var data = qrData.modules.data;

  var output = '';
  var hMargin = Array(size + (opts.margin * 2) + 1).join(blocks.WW);
  hMargin = Array((opts.margin / 2) + 1).join(hMargin + '\n');

  var vMargin = Array(opts.margin + 1).join(blocks.WW);

  output += hMargin;
  for (var i = 0; i < size; i += 2) {
    output += vMargin;
    for (var j = 0; j < size; j++) {
      var topModule = data[i * size + j];
      var bottomModule = data[(i + 1) * size + j];

      output += getBlockChar(topModule, bottomModule, blocks);
    }

    output += vMargin + '\n';
  }

  output += hMargin.slice(0, -1);

  if (typeof cb === 'function') {
    cb(null, output);
  }

  return output
};

exports.renderToFile = function renderToFile (path, qrData, options, cb) {
  if (typeof cb === 'undefined') {
    cb = options;
    options = undefined;
  }

  var fs = require$$0$11;
  var utf8 = exports.render(qrData, options);
  fs.writeFile(path, utf8, cb);
};
}(utf8$1));

var utf8 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), utf8$1, {
    'default': utf8$1
}));

var require$$3$2 = /*@__PURE__*/getAugmentedNamespace(utf8);

var terminal$1 = {};

// var Utils = require('./utils')

var render$3 = terminal$1.render = function (qrData, options, cb) {
  var size = qrData.modules.size;
  var data = qrData.modules.data;

  // var opts = Utils.getOptions(options)

  // use same scheme as https://github.com/gtanner/qrcode-terminal because it actually works! =)
  var black = '\x1b[40m  \x1b[0m';
  var white = '\x1b[47m  \x1b[0m';

  var output = '';
  var hMargin = Array(size + 3).join(white);
  var vMargin = Array(2).join(white);

  output += hMargin + '\n';
  for (var i = 0; i < size; ++i) {
    output += white;
    for (var j = 0; j < size; j++) {
      // var topModule = data[i * size + j]
      // var bottomModule = data[(i + 1) * size + j]

      output += data[i * size + j] ? black : white;// getBlockChar(topModule, bottomModule)
    }
    // output += white+'\n'
    output += vMargin + '\n';
  }

  output += hMargin + '\n';

  if (typeof cb === 'function') {
    cb(null, output);
  }

  return output
};

var terminal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), terminal$1, {
    'default': terminal$1,
    render: render$3
}));

var require$$4 = /*@__PURE__*/getAugmentedNamespace(terminal);

var svg$1 = {};

var svgTag$1 = {};

var Utils = require$$0$2;

function getColorAttrib (color, attrib) {
  var alpha = color.a / 255;
  var str = attrib + '="' + color.hex + '"';

  return alpha < 1
    ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
    : str
}

function svgCmd (cmd, x, y) {
  var str = cmd + x;
  if (typeof y !== 'undefined') str += ' ' + y;

  return str
}

function qrToPath (data, size, margin) {
  var path = '';
  var moveBy = 0;
  var newRow = false;
  var lineLength = 0;

  for (var i = 0; i < data.length; i++) {
    var col = Math.floor(i % size);
    var row = Math.floor(i / size);

    if (!col && !newRow) newRow = true;

    if (data[i]) {
      lineLength++;

      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow
          ? svgCmd('M', col + margin, 0.5 + row + margin)
          : svgCmd('m', moveBy, 0);

        moveBy = 0;
        newRow = false;
      }

      if (!(col + 1 < size && data[i + 1])) {
        path += svgCmd('h', lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }

  return path
}

var render$2 = svgTag$1.render = function render (qrData, options, cb) {
  var opts = Utils.getOptions(options);
  var size = qrData.modules.size;
  var data = qrData.modules.data;
  var qrcodesize = size + opts.margin * 2;

  var bg = !opts.color.light.a
    ? ''
    : '<path ' + getColorAttrib(opts.color.light, 'fill') +
      ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';

  var path =
    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
    ' d="' + qrToPath(data, size, opts.margin) + '"/>';

  var viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';

  var width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';

  var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';

  if (typeof cb === 'function') {
    cb(null, svgTag);
  }

  return svgTag
};

var svgTag = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), svgTag$1, {
    'default': svgTag$1,
    render: render$2
}));

var require$$3$1 = /*@__PURE__*/getAugmentedNamespace(svgTag);

(function (exports) {
var svgTagRenderer = require$$3$1;

exports.render = svgTagRenderer.render;

exports.renderToFile = function renderToFile (path, qrData, options, cb) {
  if (typeof cb === 'undefined') {
    cb = options;
    options = undefined;
  }

  var fs = require$$0$11;
  var svgTag = exports.render(qrData, options);

  var xmlStr = '<?xml version="1.0" encoding="utf-8"?>' +
    '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' +
    svgTag;

  fs.writeFile(path, xmlStr, cb);
};
}(svg$1));

var svg = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), svg$1, {
    'default': svg$1
}));

var require$$5 = /*@__PURE__*/getAugmentedNamespace(svg);

var browser$1 = {};

var canvas$1 = {};

(function (exports) {
var Utils = require$$0$2;

function clearCanvas (ctx, canvas, size) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!canvas.style) canvas.style = {};
  canvas.height = size;
  canvas.width = size;
  canvas.style.height = size + 'px';
  canvas.style.width = size + 'px';
}

function getCanvasElement () {
  try {
    return document.createElement('canvas')
  } catch (e) {
    throw new Error('You need to specify a canvas element')
  }
}

exports.render = function render (qrData, canvas, options) {
  var opts = options;
  var canvasEl = canvas;

  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas;
    canvas = undefined;
  }

  if (!canvas) {
    canvasEl = getCanvasElement();
  }

  opts = Utils.getOptions(opts);
  var size = Utils.getImageWidth(qrData.modules.size, opts);

  var ctx = canvasEl.getContext('2d');
  var image = ctx.createImageData(size, size);
  Utils.qrToImageData(image.data, qrData, opts);

  clearCanvas(ctx, canvasEl, size);
  ctx.putImageData(image, 0, 0);

  return canvasEl
};

exports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {
  var opts = options;

  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas;
    canvas = undefined;
  }

  if (!opts) opts = {};

  var canvasEl = exports.render(qrData, canvas, opts);

  var type = opts.type || 'image/png';
  var rendererOpts = opts.rendererOpts || {};

  return canvasEl.toDataURL(type, rendererOpts.quality)
};
}(canvas$1));

var canvas = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), canvas$1, {
    'default': canvas$1
}));

var require$$2 = /*@__PURE__*/getAugmentedNamespace(canvas);

var canPromise$1 = require$$0$9;

var QRCode$2 = require$$1$8;
var CanvasRenderer = require$$2;
var SvgRenderer$1 = require$$3$1;

function renderCanvas (renderFunc, canvas, text, opts, cb) {
  var args = [].slice.call(arguments, 1);
  var argsNum = args.length;
  var isLastArgCb = typeof args[argsNum - 1] === 'function';

  if (!isLastArgCb && !canPromise$1()) {
    throw new Error('Callback required as last argument')
  }

  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 2) {
      cb = text;
      text = canvas;
      canvas = opts = undefined;
    } else if (argsNum === 3) {
      if (canvas.getContext && typeof cb === 'undefined') {
        cb = opts;
        opts = undefined;
      } else {
        cb = opts;
        opts = text;
        text = canvas;
        canvas = undefined;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 1) {
      text = canvas;
      canvas = opts = undefined;
    } else if (argsNum === 2 && !canvas.getContext) {
      opts = text;
      text = canvas;
      canvas = undefined;
    }

    return new Promise(function (resolve, reject) {
      try {
        var data = QRCode$2.create(text, opts);
        resolve(renderFunc(data, canvas, opts));
      } catch (e) {
        reject(e);
      }
    })
  }

  try {
    var data = QRCode$2.create(text, opts);
    cb(null, renderFunc(data, canvas, opts));
  } catch (e) {
    cb(e);
  }
}

var create$1 = browser$1.create = QRCode$2.create;
var toCanvas$1 = browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
var toDataURL$1 = browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);

// only svg for now.
var toString$1 = browser$1.toString = renderCanvas.bind(null, function (data, _, opts) {
  return SvgRenderer$1.render(data, opts)
});

var browser = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), browser$1, {
    'default': browser$1,
    create: create$1,
    toCanvas: toCanvas$1,
    toDataURL: toDataURL$1,
    toString: toString$1
}));

var require$$6 = /*@__PURE__*/getAugmentedNamespace(browser);

var canPromise = require$$0$9;
var QRCode$1 = require$$1$8;
var PngRenderer = require$$2$1;
var Utf8Renderer = require$$3$2;
var TerminalRenderer = require$$4;
var SvgRenderer = require$$5;

function checkParams (text, opts, cb) {
  if (typeof text === 'undefined') {
    throw new Error('String required as first argument')
  }

  if (typeof cb === 'undefined') {
    cb = opts;
    opts = {};
  }

  if (typeof cb !== 'function') {
    if (!canPromise()) {
      throw new Error('Callback required as last argument')
    } else {
      opts = cb || {};
      cb = null;
    }
  }

  return {
    opts: opts,
    cb: cb
  }
}

function getTypeFromFilename (path) {
  return path.slice((path.lastIndexOf('.') - 1 >>> 0) + 2).toLowerCase()
}

function getRendererFromType (type) {
  switch (type) {
    case 'svg':
      return SvgRenderer

    case 'txt':
    case 'utf8':
      return Utf8Renderer

    case 'png':
    case 'image/png':
    default:
      return PngRenderer
  }
}

function getStringRendererFromType (type) {
  switch (type) {
    case 'svg':
      return SvgRenderer

    case 'terminal':
      return TerminalRenderer

    case 'utf8':
    default:
      return Utf8Renderer
  }
}

function render$1 (renderFunc, text, params) {
  if (!params.cb) {
    return new Promise(function (resolve, reject) {
      try {
        var data = QRCode$1.create(text, params.opts);
        return renderFunc(data, params.opts, function (err, data) {
          return err ? reject(err) : resolve(data)
        })
      } catch (e) {
        reject(e);
      }
    })
  }

  try {
    var data = QRCode$1.create(text, params.opts);
    return renderFunc(data, params.opts, params.cb)
  } catch (e) {
    params.cb(e);
  }
}

var create = server$1.create = QRCode$1.create;

var toCanvas = server$1.toCanvas = require$$6.toCanvas;

var toString = server$1.toString = function toString (text, opts, cb) {
  var params = checkParams(text, opts, cb);
  var renderer = getStringRendererFromType(params.opts.type);
  return render$1(renderer.render, text, params)
};

var toDataURL = server$1.toDataURL = function toDataURL (text, opts, cb) {
  var params = checkParams(text, opts, cb);
  var renderer = getRendererFromType(params.opts.type);
  return render$1(renderer.renderToDataURL, text, params)
};

var toBuffer = server$1.toBuffer = function toBuffer (text, opts, cb) {
  var params = checkParams(text, opts, cb);
  var renderer = getRendererFromType(params.opts.type);
  return render$1(renderer.renderToBuffer, text, params)
};

var toFile = server$1.toFile = function toFile (path, text, opts, cb) {
  if (typeof path !== 'string' || !(typeof text === 'string' || typeof text === 'object')) {
    throw new Error('Invalid argument')
  }

  if ((arguments.length < 3) && !canPromise()) {
    throw new Error('Too few arguments provided')
  }

  var params = checkParams(text, opts, cb);
  var type = params.opts.type || getTypeFromFilename(path);
  var renderer = getRendererFromType(type);
  var renderToFile = renderer.renderToFile.bind(null, path);

  return render$1(renderToFile, text, params)
};

var toFileStream = server$1.toFileStream = function toFileStream (stream, text, opts) {
  if (arguments.length < 2) {
    throw new Error('Too few arguments provided')
  }

  var params = checkParams(text, opts, stream.emit.bind(stream, 'error'));
  var renderer = getRendererFromType('png'); // Only png support for now
  var renderToFileStream = renderer.renderToFileStream.bind(null, stream);
  render$1(renderToFileStream, text, params);
};

var server = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), server$1, {
    'default': server$1,
    create: create,
    toCanvas: toCanvas,
    toString: toString,
    toDataURL: toDataURL,
    toBuffer: toBuffer,
    toFile: toFile,
    toFileStream: toFileStream
}));

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(server);

/*
*copyright Ryan Day 2012
*
* Licensed under the MIT license:
*   http://www.opensource.org/licenses/mit-license.php
*
* this is the main server side application file for node-qrcode.
* these exports use serverside canvas api methods for file IO and buffers
*
*/

var lib = require$$0$1;

var lib$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), lib, {
    'default': lib
}));

var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(lib$1);

var compat$1 = {};

var hooks$1 = {};

var preact$1 = {};

var options;
var _e;
var toChildArray;
var createContext;
var cloneElement;
var Component;
var isValidElement;
var createRef;
var Fragment;
var h_1;
var createElement;
var hydrate;
var render;
var n$1,l$1,u$1,t$1,i$1,r$1,o$1,f$1,e$1={},c$1=[],s$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;function a$1(n,l){for(var u in l)n[u]=l[u];return n}function p$1(n){var l=n.parentNode;l&&l.removeChild(n);}function v$1(n,l,u){var t,i=arguments,r={};for(t in l)"key"!==t&&"ref"!==t&&(r[t]=l[t]);if(arguments.length>3)for(u=[u],t=3;t<arguments.length;t++)u.push(i[t]);if(null!=u&&(r.children=u),"function"==typeof n&&null!=n.defaultProps)for(t in n.defaultProps)void 0===r[t]&&(r[t]=n.defaultProps[t]);return h$1(n,r,l&&l.key,l&&l.ref,null)}function h$1(l,u,t,i,r){var o={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:r};return null==r&&(o.__v=o),n$1.vnode&&n$1.vnode(o),o}function y$1(n){return n.children}function d$1(n,l){this.props=n,this.context=l;}function x$1(n,l){if(null==l)return n.__?x$1(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?x$1(n):null}function m$1(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return m$1(n)}}function w(l){(!l.__d&&(l.__d=!0)&&u$1.push(l)&&!t$1++||r$1!==n$1.debounceRendering)&&((r$1=n$1.debounceRendering)||i$1)(k);}function k(){for(var n;t$1=u$1.length;)n=u$1.sort(function(n,l){return n.__v.__b-l.__v.__b}),u$1=[],n.some(function(n){var l,u,t,i,r,o,f;n.__d&&(o=(r=(l=n).__v).__e,(f=l.__P)&&(u=[],(t=a$1({},r)).__v=t,i=z(f,r,t,l.__n,void 0!==f.ownerSVGElement,null,u,null==o?x$1(r):o),A(u,r),i!=o&&m$1(r)));});}function g(n,l,u,t,i,r,o,f,s){var a,v,h,y,d,m,w,k=u&&u.__k||c$1,g=k.length;if(f==e$1&&(f=null!=r?r[0]:g?x$1(u,0):null),a=0,l.__k=_(l.__k,function(u){if(null!=u){if(u.__=l,u.__b=l.__b+1,null===(h=k[a])||h&&u.key==h.key&&u.type===h.type)k[a]=void 0;else for(v=0;v<g;v++){if((h=k[v])&&u.key==h.key&&u.type===h.type){k[v]=void 0;break}h=null;}if(y=z(n,u,h=h||e$1,t,i,r,o,f,s),(v=u.ref)&&h.ref!=v&&(w||(w=[]),h.ref&&w.push(h.ref,null,u),w.push(v,u.__c||y,u)),null!=y){var c;if(null==m&&(m=y),void 0!==u.__d)c=u.__d,u.__d=void 0;else if(r==h||y!=f||null==y.parentNode){n:if(null==f||f.parentNode!==n)n.appendChild(y),c=null;else {for(d=f,v=0;(d=d.nextSibling)&&v<g;v+=2)if(d==y)break n;n.insertBefore(y,f),c=f;}"option"==l.type&&(n.value="");}f=void 0!==c?c:y.nextSibling,"function"==typeof l.type&&(l.__d=f);}else f&&h.__e==f&&f.parentNode!=n&&(f=x$1(h));}return a++,u}),l.__e=m,null!=r&&"function"!=typeof l.type)for(a=r.length;a--;)null!=r[a]&&p$1(r[a]);for(a=g;a--;)null!=k[a]&&j(k[a],k[a]);if(w)for(a=0;a<w.length;a++)$(w[a],w[++a],w[++a]);}function _(n,l,u){if(null==u&&(u=[]),null==n||"boolean"==typeof n)l&&u.push(l(null));else if(Array.isArray(n))for(var t=0;t<n.length;t++)_(n[t],l,u);else u.push(l?l("string"==typeof n||"number"==typeof n?h$1(null,n,null,null,n):null!=n.__e||null!=n.__c?h$1(n.type,n.props,n.key,null,n.__v):n):n);return u}function b(n,l,u,t,i){var r;for(r in u)"children"===r||"key"===r||r in l||C(n,r,null,u[r],t);for(r in l)i&&"function"!=typeof l[r]||"children"===r||"key"===r||"value"===r||"checked"===r||u[r]===l[r]||C(n,r,l[r],u[r],t);}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]="number"==typeof u&&!1===s$1.test(l)?u+"px":null==u?"":u;}function C(n,l,u,t,i){var r,o,f,e,c;if(i?"className"===l&&(l="class"):"class"===l&&(l="className"),"style"===l)if(r=n.style,"string"==typeof u)r.cssText=u;else {if("string"==typeof t&&(r.cssText="",t=null),t)for(e in t)u&&e in u||P(r,e,"");if(u)for(c in u)t&&u[c]===t[c]||P(r,c,u[c]);}else "o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),f=l.toLowerCase(),l=(f in n?f:l).slice(2),u?(t||n.addEventListener(l,N,o),(n.l||(n.l={}))[l]=u):n.removeEventListener(l,N,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/^xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u));}function N(l){this.l[l.type](n$1.event?n$1.event(l):l);}function z(l,u,t,i,r,o,f,e,c){var s,p,v,h,x,m,w,k,_,b,P=u.type;if(void 0!==u.constructor)return null;(s=n$1.__b)&&s(u);try{n:if("function"==typeof P){if(k=u.props,_=(s=P.contextType)&&i[s.__c],b=s?_?_.props.value:s.__:i,t.__c?w=(p=u.__c=t.__c).__=p.__E:("prototype"in P&&P.prototype.render?u.__c=p=new P(k,b):(u.__c=p=new d$1(k,b),p.constructor=P,p.render=D),_&&_.sub(p),p.props=k,p.state||(p.state={}),p.context=b,p.__n=i,v=p.__d=!0,p.__h=[]),null==p.__s&&(p.__s=p.state),null!=P.getDerivedStateFromProps&&(p.__s==p.state&&(p.__s=a$1({},p.__s)),a$1(p.__s,P.getDerivedStateFromProps(k,p.__s))),h=p.props,x=p.state,v)null==P.getDerivedStateFromProps&&null!=p.componentWillMount&&p.componentWillMount(),null!=p.componentDidMount&&p.__h.push(p.componentDidMount);else {if(null==P.getDerivedStateFromProps&&k!==h&&null!=p.componentWillReceiveProps&&p.componentWillReceiveProps(k,b),!p.__e&&null!=p.shouldComponentUpdate&&!1===p.shouldComponentUpdate(k,p.__s,b)||u.__v===t.__v&&!p.__){for(p.props=k,p.state=p.__s,u.__v!==t.__v&&(p.__d=!1),p.__v=u,u.__e=t.__e,u.__k=t.__k,p.__h.length&&f.push(p),s=0;s<u.__k.length;s++)u.__k[s]&&(u.__k[s].__=u);break n}null!=p.componentWillUpdate&&p.componentWillUpdate(k,p.__s,b),null!=p.componentDidUpdate&&p.__h.push(function(){p.componentDidUpdate(h,x,m);});}p.context=b,p.props=k,p.state=p.__s,(s=n$1.__r)&&s(u),p.__d=!1,p.__v=u,p.__P=l,s=p.render(p.props,p.state,p.context),u.__k=null!=s&&s.type==y$1&&null==s.key?s.props.children:Array.isArray(s)?s:[s],null!=p.getChildContext&&(i=a$1(a$1({},i),p.getChildContext())),v||null==p.getSnapshotBeforeUpdate||(m=p.getSnapshotBeforeUpdate(h,x)),g(l,u,t,i,r,o,f,e,c),p.base=u.__e,p.__h.length&&f.push(p),w&&(p.__E=p.__=null),p.__e=!1;}else null==o&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=T$1(t.__e,u,t,i,r,o,f,c);(s=n$1.diffed)&&s(u);}catch(l){u.__v=null,n$1.__e(l,u,t);}return u.__e}function A(l,u){n$1.__c&&n$1.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u);});}catch(l){n$1.__e(l,u.__v);}});}function T$1(n,l,u,t,i,r,o,f){var s,a,p,v,h,y=u.props,d=l.props;if(i="svg"===l.type||i,null!=r)for(s=0;s<r.length;s++)if(null!=(a=r[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,r[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),r=null,f=!1;}if(null===l.type)y!==d&&n.data!=d&&(n.data=d);else {if(null!=r&&(r=c$1.slice.call(n.childNodes)),p=(y=u.props||e$1).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,!f){if(y===e$1)for(y={},h=0;h<n.attributes.length;h++)y[n.attributes[h].name]=n.attributes[h].value;(v||p)&&(v&&p&&v.__html==p.__html||(n.innerHTML=v&&v.__html||""));}b(n,d,y,i,f),v?l.__k=[]:(l.__k=l.props.children,g(n,l,u,t,"foreignObject"!==l.type&&i,r,o,e$1,f)),f||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&C(n,"value",s,y.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&C(n,"checked",s,y.checked,!1));}return n}function $(l,u,t){try{"function"==typeof l?l(u):l.current=u;}catch(l){n$1.__e(l,t);}}function j(l,u,t){var i,r,o;if(n$1.unmount&&n$1.unmount(l),(i=l.ref)&&(i.current&&i.current!==l.__e||$(i,null,u)),t||"function"==typeof l.type||(t=null!=(r=l.__e)),l.__e=l.__d=void 0,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount();}catch(l){n$1.__e(l,u);}i.base=i.__P=null;}if(i=l.__k)for(o=0;o<i.length;o++)i[o]&&j(i[o],u,t);null!=r&&p$1(r);}function D(n,l,u){return this.constructor(n,u)}function E(l,u,t){var i,r,f;n$1.__&&n$1.__(l,u),r=(i=t===o$1)?null:t&&t.__k||u.__k,l=v$1(y$1,null,[l]),f=[],z(u,(i?u:t||u).__k=l,r||e$1,e$1,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:c$1.slice.call(u.childNodes),f,t||e$1,i),A(f,l);}n$1={__e:function(n,l){for(var u,t;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(t=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(t=!0,u.componentDidCatch(n)),t)return w(u.__E=u)}catch(l){n=l;}throw n}},l$1=function(n){return null!=n&&void 0===n.constructor},d$1.prototype.setState=function(n,l){var u;u=this.__s!==this.state?this.__s:this.__s=a$1({},this.state),"function"==typeof n&&(n=n(u,this.props)),n&&a$1(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),w(this));},d$1.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),w(this));},d$1.prototype.render=y$1,u$1=[],t$1=0,i$1="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,o$1=e$1,f$1=0,render = preact$1.render=E,hydrate = preact$1.hydrate=function(n,l){E(n,l,o$1);},createElement = preact$1.createElement=v$1,h_1 = preact$1.h=v$1,Fragment = preact$1.Fragment=y$1,createRef = preact$1.createRef=function(){return {}},isValidElement = preact$1.isValidElement=l$1,Component = preact$1.Component=d$1,cloneElement = preact$1.cloneElement=function(n,l){var u,t;for(t in l=a$1(a$1({},n.props),l),arguments.length>2&&(l.children=c$1.slice.call(arguments,2)),u={},l)"key"!==t&&"ref"!==t&&(u[t]=l[t]);return h$1(n.type,u,l.key||n.key,l.ref||n.ref,null)},createContext = preact$1.createContext=function(n){var l={},u={__c:"__cC"+f$1++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var t,i=this;return this.getChildContext||(t=[],this.getChildContext=function(){return l[u.__c]=i,l},this.shouldComponentUpdate=function(n){i.props.value!==n.value&&t.some(function(l){l.context=n.value,w(l);});},this.sub=function(n){t.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){t.splice(t.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Consumer.contextType=u,u.Provider.__=u,u},toChildArray = preact$1.toChildArray=_,_e = preact$1._e=j,options = preact$1.options=n$1;

var preact = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), preact$1, {
    'default': preact$1,
    get render () { return render; },
    get hydrate () { return hydrate; },
    get createElement () { return createElement; },
    get h () { return h_1; },
    get Fragment () { return Fragment; },
    get createRef () { return createRef; },
    get isValidElement () { return isValidElement; },
    get Component () { return Component; },
    get cloneElement () { return cloneElement; },
    get createContext () { return createContext; },
    get toChildArray () { return toChildArray; },
    get _e () { return _e; },
    get options () { return options; }
}));

var require$$1 = /*@__PURE__*/getAugmentedNamespace(preact);

var useErrorBoundary;
var useDebugValue;
var useContext;
var useCallback;
var useMemo;
var useImperativeHandle;
var useRef;
var useLayoutEffect;
var useEffect;
var useReducer;
var useState;
var n,t,r,u=require$$1,o=0,i=[],c=u.options.__r,e=u.options.diffed,f=u.options.__c,a=u.options.unmount;function p(n,r){u.options.__h&&u.options.__h(t,n,o||r),o=0;var i=t.__H||(t.__H={__:[],__h:[]});return n>=i.__.length&&i.__.push({}),i.__[n]}function v(n){return o=1,s(T,n)}function s(r,u,o){var i=p(n++,2);return i.__c||(i.__c=t,i.__=[o?o(u):T(void 0,u),function(n){var t=r(i.__[0],n);i.__[0]!==t&&(i.__[0]=t,i.__c.setState({}));}]),i.__}function x(r,o){var i=p(n++,4);!u.options.__s&&h(i.__H,o)&&(i.__=r,i.__H=o,t.__h.push(i));}function l(t,r){var u=p(n++,7);return h(u.__H,r)?(u.__H=r,u.__h=t,u.__=t()):u.__}function m(){i.some(function(n){if(n.__P)try{n.__H.__h.forEach(y),n.__H.__h.forEach(d),n.__H.__h=[];}catch(t){return n.__H.__h=[],u.options.__e(t,n.__v),!0}}),i=[];}function y(n){n.t&&n.t();}function d(n){var t=n.__();"function"==typeof t&&(n.t=t);}function h(n,t){return !n||t.some(function(t,r){return t!==n[r]})}function T(n,t){return "function"==typeof t?t(n):t}u.options.__r=function(r){c&&c(r),n=0,(t=r.__c).__H&&(t.__H.__h.forEach(y),t.__H.__h.forEach(d),t.__H.__h=[]);},u.options.diffed=function(n){e&&e(n);var t=n.__c;if(t){var o=t.__H;o&&o.__h.length&&(1!==i.push(t)&&r===u.options.requestAnimationFrame||((r=u.options.requestAnimationFrame)||function(n){var t,r=function(){clearTimeout(u),cancelAnimationFrame(t),setTimeout(n);},u=setTimeout(r,100);"undefined"!=typeof window&&(t=requestAnimationFrame(r));})(m));}},u.options.__c=function(n,t){t.some(function(n){try{n.__h.forEach(y),n.__h=n.__h.filter(function(n){return !n.__||d(n)});}catch(r){t.some(function(n){n.__h&&(n.__h=[]);}),t=[],u.options.__e(r,n.__v);}}),f&&f(n,t);},u.options.unmount=function(n){a&&a(n);var t=n.__c;if(t){var r=t.__H;if(r)try{r.__.forEach(function(n){return n.t&&n.t()});}catch(n){u.options.__e(n,t.__v);}}},useState = hooks$1.useState=v,useReducer = hooks$1.useReducer=s,useEffect = hooks$1.useEffect=function(r,o){var i=p(n++,3);!u.options.__s&&h(i.__H,o)&&(i.__=r,i.__H=o,t.__H.__h.push(i));},useLayoutEffect = hooks$1.useLayoutEffect=x,useRef = hooks$1.useRef=function(n){return o=5,l(function(){return {current:n}},[])},useImperativeHandle = hooks$1.useImperativeHandle=function(n,t,r){o=6,x(function(){"function"==typeof n?n(t()):n&&(n.current=t());},null==r?r:r.concat(n));},useMemo = hooks$1.useMemo=l,useCallback = hooks$1.useCallback=function(n,t){return o=8,l(function(){return n},t)},useContext = hooks$1.useContext=function(r){var u=t.context[r.__c],o=p(n++,9);return o.__c=r,u?(null==o.__&&(o.__=!0,u.sub(t)),u.props.value):r.__},useDebugValue = hooks$1.useDebugValue=function(n,t){u.options.useDebugValue&&u.options.useDebugValue(t?t(n):n);},useErrorBoundary = hooks$1.useErrorBoundary=function(r){var u=p(n++,10),o=v();return u.__=r,t.componentDidCatch||(t.componentDidCatch=function(n){u.__&&u.__(n),o[1](n);}),[o[0],function(){o[1](void 0);}]};

var hooks = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), hooks$1, {
    'default': hooks$1,
    get useState () { return useState; },
    get useReducer () { return useReducer; },
    get useEffect () { return useEffect; },
    get useLayoutEffect () { return useLayoutEffect; },
    get useRef () { return useRef; },
    get useImperativeHandle () { return useImperativeHandle; },
    get useMemo () { return useMemo; },
    get useCallback () { return useCallback; },
    get useContext () { return useContext; },
    get useDebugValue () { return useDebugValue; },
    get useErrorBoundary () { return useErrorBoundary; }
}));

var require$$0 = /*@__PURE__*/getAugmentedNamespace(hooks);

(function (exports) {
var n=require$$0,t=require$$1;function e(n,t){for(var e in t)n[e]=t[e];return n}function r(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}var o=function(n){var t,e;function o(t){var e;return (e=n.call(this,t)||this).isPureReactComponent=!0,e}return e=n,(t=o).prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e,o.prototype.shouldComponentUpdate=function(n,t){return r(this.props,n)||r(this.state,t)},o}(t.Component);function u(n,o){function u(n){var t=this.props.ref,e=t==n.ref;return !e&&t&&(t.call?t(null):t.current=null),o?!o(this.props,n)||!e:r(this.props,n)}function i(r){return this.shouldComponentUpdate=u,t.createElement(n,e({},r))}return i.prototype.isReactComponent=!0,i.displayName="Memo("+(n.displayName||n.name)+")",i.t=!0,i}var i=t.options.__b;function f(n){function t(t){var r=e({},t);return delete r.ref,n(r,t.ref)}return t.prototype.isReactComponent=t.t=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}t.options.__b=function(n){n.type&&n.type.t&&n.ref&&(n.props.ref=n.ref,n.ref=null),i&&i(n);};var c=function(n,e){return n?t.toChildArray(n).reduce(function(n,t,r){return n.concat(e(t,r))},[]):null},l={map:c,forEach:c,count:function(n){return n?t.toChildArray(n).length:0},only:function(n){if(1!==(n=t.toChildArray(n)).length)throw new Error("Children.only() expects only one child.");return n[0]},toArray:t.toChildArray},a=t.options.__e;function s(n){return n&&((n=e({},n)).__c=null,n.__k=n.__k&&n.__k.map(s)),n}function p(){this.__u=0,this.o=null,this.__b=null;}function v(n){var t=n.__.__c;return t&&t.u&&t.u(n)}function h(n){var e,r,o;function u(u){if(e||(e=n()).then(function(n){r=n.default||n;},function(n){o=n;}),o)throw o;if(!r)throw e;return t.createElement(r,u)}return u.displayName="Lazy",u.t=!0,u}function d(){this.i=null,this.l=null;}t.options.__e=function(n,t,e){if(n.then)for(var r,o=t;o=o.__;)if((r=o.__c)&&r.__c)return r.__c(n,t.__c);a(n,t,e);},(p.prototype=new t.Component).__c=function(n,t){var e=this;null==e.o&&(e.o=[]),e.o.push(t);var r=v(e.__v),o=!1,u=function(){o||(o=!0,r?r(i):i());};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){u(),t.__c&&t.__c();};var i=function(){var n;if(!--e.__u)for(e.__v.__k[0]=e.state.u,e.setState({u:e.__b=null});n=e.o.pop();)n.forceUpdate();};e.__u++||e.setState({u:e.__b=e.__v.__k[0]}),n.then(u,u);},p.prototype.render=function(n,e){return this.__b&&(this.__v.__k[0]=s(this.__b),this.__b=null),[t.createElement(t.Component,null,e.u?null:n.children),e.u&&n.fallback]};var x=function(n,t,e){if(++e[1]===e[0]&&n.l.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.l.size))for(e=n.i;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.i=e=e[2];}};(d.prototype=new t.Component).u=function(n){var t=this,e=v(t.__v),r=t.l.get(n);return r[0]++,function(o){var u=function(){t.props.revealOrder?(r.push(o),x(t,n,r)):o();};e?e(u):u();}},d.prototype.render=function(n){this.i=null,this.l=new Map;var e=t.toChildArray(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&e.reverse();for(var r=e.length;r--;)this.l.set(e[r],this.i=[1,0,this.i]);return n.children},d.prototype.componentDidUpdate=d.prototype.componentDidMount=function(){var n=this;n.l.forEach(function(t,e){x(n,e,t);});};var m=function(){function n(){}var t=n.prototype;return t.getChildContext=function(){return this.props.context},t.render=function(n){return n.children},n}();function y(n){var e=this,r=n.container,o=t.createElement(m,{context:e.context},n.vnode);return e.s&&e.s!==r&&(e.p.parentNode&&e.s.removeChild(e.p),t._e(e.v),e.h=!1),n.vnode?e.h?(r.__k=e.__k,t.render(o,r),e.__k=r.__k):(e.p=document.createTextNode(""),t.hydrate("",r),r.appendChild(e.p),e.h=!0,e.s=r,t.render(o,r,e.p),e.__k=e.p.__k):e.h&&(e.p.parentNode&&e.s.removeChild(e.p),t._e(e.v)),e.v=o,e.componentWillUnmount=function(){e.p.parentNode&&e.s.removeChild(e.p),t._e(e.v);},null}function b(n,e){return t.createElement(y,{vnode:n,container:e})}var g=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;t.Component.prototype.isReactComponent={};var w="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103;function E(n,e,r){if(null==e.__k)for(;e.firstChild;)e.removeChild(e.firstChild);return t.render(n,e),"function"==typeof r&&r(),n?n.__c:null}var _=t.options.event;function A(n,t){n["UNSAFE_"+t]&&!n[t]&&Object.defineProperty(n,t,{configurable:!1,get:function(){return this["UNSAFE_"+t]},set:function(n){this["UNSAFE_"+t]=n;}});}t.options.event=function(n){_&&(n=_(n)),n.persist=function(){};var t=!1,e=!1,r=n.stopPropagation;n.stopPropagation=function(){r.call(n),t=!0;};var o=n.preventDefault;return n.preventDefault=function(){o.call(n),e=!0;},n.isPropagationStopped=function(){return t},n.isDefaultPrevented=function(){return e},n.nativeEvent=n};var C={configurable:!0,get:function(){return this.class}},S=t.options.vnode;function k(n){return t.createElement.bind(null,n)}function N(n){return !!n&&n.$$typeof===w}function R(n){return N(n)?t.cloneElement.apply(null,arguments):n}function U(n){return !!n.__k&&(t.render(null,n),!0)}function F(n){return n&&(n.base||1===n.nodeType&&n)||null}t.options.vnode=function(n){n.$$typeof=w;var e=n.type,r=n.props;if(e){if(r.class!=r.className&&(C.enumerable="className"in r,null!=r.className&&(r.class=r.className),Object.defineProperty(r,"className",C)),"function"!=typeof e){var o,u,i;for(i in r.defaultValue&&void 0!==r.value&&(r.value||0===r.value||(r.value=r.defaultValue),delete r.defaultValue),Array.isArray(r.value)&&r.multiple&&"select"===e&&(t.toChildArray(r.children).forEach(function(n){-1!=r.value.indexOf(n.props.value)&&(n.props.selected=!0);}),delete r.value),r)if(o=g.test(i))break;if(o)for(i in u=n.props={},r)u[g.test(i)?i.replace(/[A-Z0-9]/,"-$&").toLowerCase():i]=r[i];}!function(t){var e=n.type,r=n.props;if(r&&"string"==typeof e){var o={};for(var u in r)/^on(Ani|Tra|Tou)/.test(u)&&(r[u.toLowerCase()]=r[u],delete r[u]),o[u.toLowerCase()]=u;if(o.ondoubleclick&&(r.ondblclick=r[o.ondoubleclick],delete r[o.ondoubleclick]),o.onbeforeinput&&(r.onbeforeinput=r[o.onbeforeinput],delete r[o.onbeforeinput]),o.onchange&&("textarea"===e||"input"===e.toLowerCase()&&!/^fil|che|ra/i.test(r.type))){var i=o.oninput||"oninput";r[i]||(r[i]=r[o.onchange],delete r[o.onchange]);}}}(),"function"==typeof e&&!e.m&&e.prototype&&(A(e.prototype,"componentWillMount"),A(e.prototype,"componentWillReceiveProps"),A(e.prototype,"componentWillUpdate"),e.m=!0);}S&&S(n);};var M=function(n,t){return n(t)},O={useState:n.useState,useReducer:n.useReducer,useEffect:n.useEffect,useLayoutEffect:n.useLayoutEffect,useRef:n.useRef,useImperativeHandle:n.useImperativeHandle,useMemo:n.useMemo,useCallback:n.useCallback,useContext:n.useContext,useDebugValue:n.useDebugValue,version:"16.8.0",Children:l,render:E,hydrate:E,unmountComponentAtNode:U,createPortal:b,createElement:t.createElement,createContext:t.createContext,createFactory:k,cloneElement:R,createRef:t.createRef,Fragment:t.Fragment,isValidElement:N,findDOMNode:F,Component:t.Component,PureComponent:o,memo:u,forwardRef:f,unstable_batchedUpdates:M,Suspense:p,SuspenseList:d,lazy:h};Object.keys(n).forEach(function(t){exports[t]=n[t];}),exports.createElement=t.createElement,exports.createContext=t.createContext,exports.createRef=t.createRef,exports.Fragment=t.Fragment,exports.Component=t.Component,exports.version="16.8.0",exports.Children=l,exports.render=E,exports.hydrate=function(n,e,r){return t.hydrate(n,e),"function"==typeof r&&r(),n?n.__c:null},exports.unmountComponentAtNode=U,exports.createPortal=b,exports.createFactory=k,exports.cloneElement=R,exports.isValidElement=N,exports.findDOMNode=F,exports.PureComponent=o,exports.memo=u,exports.forwardRef=f,exports.unstable_batchedUpdates=M,exports.Suspense=p,exports.SuspenseList=d,exports.lazy=h,exports.default=O;

}(compat$1));

var compat = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), compat$1, {
    'default': compat$1
}));

var require$$3 = /*@__PURE__*/getAugmentedNamespace(compat);

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var legacyUtils = require$$0$a;
var QRCode = _interopDefault(require$$1$1);
var copy = _interopDefault(require$$2$K);
var React = require$$3;

function open(uri) {
  QRCode.toString(uri, {
    type: "terminal"
  }).then(console.log);
}

var WALLETCONNECT_STYLE_SHEET = ":root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, \"SF Pro Rounded\", \"SF Pro Text\", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell,\n    \"Open Sans\", \"Helvetica Neue\", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url(\"images/wc-logo.svg\") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n";

// A type of promise-like that resolves synchronously and supports only one observer
typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator"; // Asynchronously iterate through an object's values
typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
} // Asynchronously await a promise and pass the result to a finally continuation

var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='300px' height='185px' viewBox='0 0 300 185' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3EWalletConnect%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='walletconnect-logo-alt' fill='%233B99FC' fill-rule='nonzero'%3E %3Cpath d='M61.4385429,36.2562612 C110.349767,-11.6319051 189.65053,-11.6319051 238.561752,36.2562612 L244.448297,42.0196786 C246.893858,44.4140867 246.893858,48.2961898 244.448297,50.690599 L224.311602,70.406102 C223.088821,71.6033071 221.106302,71.6033071 219.883521,70.406102 L211.782937,62.4749541 C177.661245,29.0669724 122.339051,29.0669724 88.2173582,62.4749541 L79.542302,70.9685592 C78.3195204,72.1657633 76.337001,72.1657633 75.1142214,70.9685592 L54.9775265,51.2530561 C52.5319653,48.8586469 52.5319653,44.9765439 54.9775265,42.5821357 L61.4385429,36.2562612 Z M280.206339,77.0300061 L298.128036,94.5769031 C300.573585,96.9713 300.573599,100.85338 298.128067,103.247793 L217.317896,182.368927 C214.872352,184.763353 210.907314,184.76338 208.461736,182.368989 C208.461726,182.368979 208.461714,182.368967 208.461704,182.368957 L151.107561,126.214385 C150.496171,125.615783 149.504911,125.615783 148.893521,126.214385 C148.893517,126.214389 148.893514,126.214393 148.89351,126.214396 L91.5405888,182.368927 C89.095052,184.763359 85.1300133,184.763399 82.6844276,182.369014 C82.6844133,182.369 82.684398,182.368986 82.6843827,182.36897 L1.87196327,103.246785 C-0.573596939,100.852377 -0.573596939,96.9702735 1.87196327,94.5758653 L19.7936929,77.028998 C22.2392531,74.6345898 26.2042918,74.6345898 28.6498531,77.028998 L86.0048306,133.184355 C86.6162214,133.782957 87.6074796,133.782957 88.2188704,133.184355 C88.2188796,133.184346 88.2188878,133.184338 88.2188969,133.184331 L145.571,77.028998 C148.016505,74.6345347 151.981544,74.6344449 154.427161,77.028798 C154.427195,77.0288316 154.427229,77.0288653 154.427262,77.028899 L211.782164,133.184331 C212.393554,133.782932 213.384814,133.782932 213.996204,133.184331 L271.350179,77.0300061 C273.79574,74.6355969 277.760778,74.6355969 280.206339,77.0300061 Z' id='WalletConnect'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E";

var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
var ANIMATION_DURATION = 300;
var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";

function Header(props) {
  return React.createElement("div", {
    className: "walletconnect-modal__header"
  }, React.createElement("img", {
    src: WALLETCONNECT_LOGO_SVG_URL,
    className: "walletconnect-modal__headerLogo"
  }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
    className: "walletconnect-modal__close__wrapper",
    onClick: props.onClose
  }, React.createElement("div", {
    id: WALLETCONNECT_CLOSE_BUTTON_ID,
    className: "walletconnect-modal__close__icon"
  }, React.createElement("div", {
    className: "walletconnect-modal__close__line1"
  }), React.createElement("div", {
    className: "walletconnect-modal__close__line2"
  }))));
}

function ConnectButton$1(props) {
  return React.createElement("a", {
    className: "walletconnect-connect__button",
    href: props.href,
    id: (WALLETCONNECT_CONNECT_BUTTON_ID + "-" + (props.name)),
    onClick: props.onClick,
    rel: "noopener noreferrer",
    style: {
      backgroundColor: props.color
    },
    target: "_blank"
  }, props.name);
}

var CARET_SVG_URL = "data:image/svg+xml,%3Csvg width='8' height='18' viewBox='0 0 8 18' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0.586301 0.213898C0.150354 0.552968 0.0718197 1.18124 0.41089 1.61719L5.2892 7.88931C5.57007 8.25042 5.57007 8.75608 5.2892 9.11719L0.410889 15.3893C0.071819 15.8253 0.150353 16.4535 0.586301 16.7926C1.02225 17.1317 1.65052 17.0531 1.98959 16.6172L6.86791 10.3451C7.7105 9.26174 7.7105 7.74476 6.86791 6.66143L1.98959 0.38931C1.65052 -0.0466374 1.02225 -0.125172 0.586301 0.213898Z' fill='%233C4252'/%3E %3C/svg%3E";

function WalletButton(props) {
  var color = props.color;
  var href = props.href;
  var name = props.name;
  var logo = props.logo;
  var onClick = props.onClick;
  return React.createElement("a", {
    className: "walletconnect-modal__base__row",
    href: href,
    onClick: onClick,
    rel: "noopener noreferrer",
    target: "_blank"
  }, React.createElement("h3", {
    className: "walletconnect-modal__base__row__h3"
  }, name), React.createElement("div", {
    className: "walletconnect-modal__base__row__right"
  }, React.createElement("div", {
    className: "walletconnect-modal__base__row__right__app-icon",
    style: {
      background: ("url('" + logo + "') " + color),
      backgroundSize: "100%"
    }
  }), React.createElement("img", {
    src: CARET_SVG_URL,
    className: "walletconnect-modal__base__row__right__caret"
  })));
}

function WalletIcon(props) {
  var color = props.color;
  var href = props.href;
  var name = props.name;
  var logo = props.logo;
  var onClick = props.onClick;
  var fontSize = window.innerWidth < 768 ? ((name.length > 8 ? 2.5 : 2.7) + "vw") : "inherit";
  return React.createElement("a", {
    className: "walletconnect-connect__button__icon_anchor",
    href: href,
    onClick: onClick,
    rel: "noopener noreferrer",
    target: "_blank"
  }, React.createElement("div", {
    className: "walletconnect-connect__button__icon",
    style: {
      background: ("url('" + logo + "') " + color),
      backgroundSize: "100%"
    }
  }), React.createElement("div", {
    style: {
      fontSize: fontSize
    },
    className: "walletconnect-connect__button__text"
  }, name));
}

var GRID_MIN_COUNT = 5;
var LINKS_PER_PAGE = 12;

function LinkDisplay(props) {
  var android = legacyUtils.isAndroid();
  var ref = React.useState("");
  var input = ref[0];
  var setInput = ref[1];
  var ref$1 = React.useState("");
  var filter = ref$1[0];
  var setFilter = ref$1[1];
  var ref$2 = React.useState(1);
  var page = ref$2[0];
  var setPage = ref$2[1];
  var links = filter ? props.links.filter(function (link) { return link.name.toLowerCase().includes(filter.toLowerCase()); }) : props.links;
  var errorMessage = props.errorMessage;
  var grid = filter || links.length > GRID_MIN_COUNT;
  var pages = Math.ceil(links.length / LINKS_PER_PAGE);
  var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
  var pageLinks = links.length ? links.filter(function (_, index) { return index + 1 >= range[0] && index + 1 <= range[1]; }) : [];
  var hasPaging = !!(!android && pages > 1);
  var filterTimeout = undefined;

  function handleInput(e) {
    setInput(e.target.value);
    clearTimeout(filterTimeout);

    if (e.target.value) {
      filterTimeout = setTimeout(function () {
        setFilter(e.target.value);
        setPage(1);
      }, 1000);
    } else {
      setInput("");
      setFilter("");
      setPage(1);
    }
  }

  return React.createElement("div", null, React.createElement("p", {
    id: WALLETCONNECT_CTA_TEXT_ID,
    className: "walletconnect-qrcode__text"
  }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
    className: "walletconnect-search__input",
    placeholder: "Search",
    value: input,
    onChange: handleInput
  }), React.createElement("div", {
    className: ("walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : ""))
  }, !android ? pageLinks.length ? pageLinks.map(function (entry) {
    var color = entry.color;
    var name = entry.name;
    var shortName = entry.shortName;
    var logo = entry.logo;
    var href = legacyUtils.formatIOSMobile(props.uri, entry);
    var handleClickIOS = React.useCallback(function () {
      legacyUtils.saveMobileLinkInfo({
        name: name,
        href: href
      });
    }, [pageLinks]);
    return !grid ? React.createElement(WalletButton, {
      color: color,
      href: href,
      name: name,
      logo: logo,
      onClick: handleClickIOS
    }) : React.createElement(WalletIcon, {
      color: color,
      href: href,
      name: shortName,
      logo: logo,
      onClick: handleClickIOS
    });
  }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton$1, {
    name: props.text.connect,
    color: DEFAULT_BUTTON_COLOR,
    href: props.uri,
    onClick: React.useCallback(function () {
      legacyUtils.saveMobileLinkInfo({
        name: "Unknown",
        href: props.uri
      });
    }, [])
  })), hasPaging && React.createElement("div", {
    className: "walletconnect-modal__footer"
  }, Array(pages).fill(0).map(function (_, index) {
    var pageNumber = index + 1;
    var selected = page === pageNumber;
    return React.createElement("a", {
      style: {
        margin: "auto 10px",
        fontWeight: selected ? "bold" : "normal"
      },
      onClick: function () { return setPage(pageNumber); }
    }, pageNumber);
  })));
}

function Notification(props) {
  var show = !!props.message.trim();
  return React.createElement("div", {
    className: ("walletconnect-qrcode__notification" + (show ? " notification__show" : ""))
  }, props.message);
}

var formatQRCodeImage = function (data) {
  try {
    var result = "";
    return Promise.resolve(QRCode.toString(data, {
      margin: 0,
      type: "svg"
    })).then(function (dataString) {
      if (typeof dataString === "string") {
        result = dataString.replace("<svg", "<svg class=\"walletconnect-qrcode__image\"");
      }

      return result;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function QRCodeDisplay(props) {
  var ref = React.useState("");
  var notification = ref[0];
  var setNotification = ref[1];
  var ref$1 = React.useState("");
  var svg = ref$1[0];
  var setSvg = ref$1[1];
  React.useEffect(function () {
    try {
      return Promise.resolve(formatQRCodeImage(props.uri)).then(function (_formatQRCodeImage) {
        setSvg(_formatQRCodeImage);
      });
    } catch (e) {
      Promise.reject(e);
    }
  }, []);

  var copyToClipboard = function () {
    var success = copy(props.uri);

    if (success) {
      setNotification(props.text.copied_to_clipboard);
      setInterval(function () { return setNotification(""); }, 1200);
    } else {
      setNotification("Error");
      setInterval(function () { return setNotification(""); }, 1200);
    }
  };

  return React.createElement("div", null, React.createElement("p", {
    id: WALLETCONNECT_CTA_TEXT_ID,
    className: "walletconnect-qrcode__text"
  }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: svg
    }
  }), React.createElement("div", {
    className: "walletconnect-modal__footer"
  }, React.createElement("a", {
    onClick: copyToClipboard
  }, props.text.copy_to_clipboard)), React.createElement(Notification, {
    message: notification
  }));
}

function Modal(props) {
  var android = legacyUtils.isAndroid();
  var mobile = legacyUtils.isMobile();
  var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : undefined : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : undefined;
  var ref = React.useState(false);
  var loading = ref[0];
  var setLoading = ref[1];
  var ref$1 = React.useState(false);
  var fetched = ref$1[0];
  var setFetched = ref$1[1];
  var ref$2 = React.useState(!mobile);
  var displayQRCode = ref$2[0];
  var setDisplayQRCode = ref$2[1];
  var displayProps = {
    mobile: mobile,
    text: props.text,
    uri: props.uri,
    qrcodeModalOptions: props.qrcodeModalOptions
  };
  var ref$3 = React.useState("");
  var singleLinkHref = ref$3[0];
  var setSingleLinkHref = ref$3[1];
  var ref$4 = React.useState(false);
  var hasSingleLink = ref$4[0];
  var setHasSingleLink = ref$4[1];
  var ref$5 = React.useState([]);
  var links = ref$5[0];
  var setLinks = ref$5[1];
  var ref$6 = React.useState("");
  var errorMessage = ref$6[0];
  var setErrorMessage = ref$6[1];

  var getLinksIfNeeded = function () {
    if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
      return;
    }

    React.useEffect(function () {
      var initLinks = function () {
        try {
          if (android) { return Promise.resolve(); }
          setLoading(true);

          var _temp = _catch(function () {
            var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : legacyUtils.getWalletRegistryUrl();
            return Promise.resolve(fetch(url).then(function (x) { return x.json(); })).then(function (registry) {
              var platform = mobile ? "mobile" : "desktop";

              var _links = legacyUtils.getMobileLinkRegistry(legacyUtils.formatMobileRegistry(registry, platform), whitelist);

              setLoading(false);
              setFetched(true);
              setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
              setLinks(_links);
              var hasSingleLink = _links.length === 1;

              if (hasSingleLink) {
                setSingleLinkHref(legacyUtils.formatIOSMobile(props.uri, _links[0]));
                setDisplayQRCode(true);
              }

              setHasSingleLink(hasSingleLink);
            });
          }, function (e) {
            setLoading(false);
            setFetched(true);
            setErrorMessage(props.text.something_went_wrong);
            console.error(e);
          });

          return Promise.resolve(_temp && _temp.then ? _temp.then(function () {}) : void 0);
        } catch (e) {
          return Promise.reject(e);
        }
      };

      initLinks();
    });
  };

  getLinksIfNeeded();
  var rightSelected = mobile ? displayQRCode : !displayQRCode;
  return React.createElement("div", {
    id: WALLETCONNECT_MODAL_ID,
    className: "walletconnect-qrcode__base animated fadeIn"
  }, React.createElement("div", {
    className: "walletconnect-modal__base"
  }, React.createElement(Header, {
    onClose: props.onClose
  }), hasSingleLink && displayQRCode ? React.createElement("div", {
    className: "walletconnect-modal__single_wallet"
  }, React.createElement("a", {
    onClick: function () { return legacyUtils.saveMobileLinkInfo({
      name: links[0].name,
      href: singleLinkHref
    }); },
    href: singleLinkHref,
    rel: "noopener noreferrer",
    target: "_blank"
  }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " ›")) : android || loading || !loading && links.length ? React.createElement("div", {
    className: ("walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : ""))
  }, React.createElement("div", {
    className: "walletconnect-modal__mobile__toggle_selector"
  }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
    onClick: function () { return (setDisplayQRCode(false), getLinksIfNeeded()); }
  }, props.text.mobile), React.createElement("a", {
    onClick: function () { return setDisplayQRCode(true); }
  }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
    onClick: function () { return setDisplayQRCode(true); }
  }, props.text.qrcode), React.createElement("a", {
    onClick: function () { return (setDisplayQRCode(false), getLinksIfNeeded()); }
  }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
    links: links,
    errorMessage: errorMessage
  })))));
}

var de = {
  choose_preferred_wallet: "Wähle bevorzugte Wallet",
  connect_mobile_wallet: "Verbinde mit Mobile Wallet",
  scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
  connect: "Verbinden",
  qrcode: "QR-Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "In die Zwischenablage kopieren",
  copied_to_clipboard: "In die Zwischenablage kopiert!",
  connect_with: "Verbinden mit Hilfe von",
  loading: "Laden...",
  something_went_wrong: "Etwas ist schief gelaufen",
  no_supported_wallets: "Es gibt noch keine unterstützten Wallet",
  no_wallets_found: "keine Wallet gefunden"
};

var en = {
  choose_preferred_wallet: "Choose your preferred wallet",
  connect_mobile_wallet: "Connect to Mobile Wallet",
  scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
  connect: "Connect",
  qrcode: "QR Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "Copy to clipboard",
  copied_to_clipboard: "Copied to clipboard!",
  connect_with: "Connect with",
  loading: "Loading...",
  something_went_wrong: "Something went wrong",
  no_supported_wallets: "There are no supported wallets yet",
  no_wallets_found: "No wallets found"
};

var es = {
  choose_preferred_wallet: "Elige tu billetera preferida",
  connect_mobile_wallet: "Conectar a billetera móvil",
  scan_qrcode_with_wallet: "Escanea el código QR con una billetera compatible con WalletConnect",
  connect: "Conectar",
  qrcode: "Código QR",
  mobile: "Móvil",
  desktop: "Desktop",
  copy_to_clipboard: "Copiar",
  copied_to_clipboard: "Copiado!",
  connect_with: "Conectar mediante",
  loading: "Cargando...",
  something_went_wrong: "Algo salió mal",
  no_supported_wallets: "Todavía no hay billeteras compatibles",
  no_wallets_found: "No se encontraron billeteras"
};

var fr = {
  choose_preferred_wallet: "Choisissez votre portefeuille préféré",
  connect_mobile_wallet: "Se connecter au portefeuille mobile",
  scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
  connect: "Se connecter",
  qrcode: "QR Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "Copier",
  copied_to_clipboard: "Copié!",
  connect_with: "Connectez-vous à l'aide de",
  loading: "Chargement...",
  something_went_wrong: "Quelque chose a mal tourné",
  no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
  no_wallets_found: "Aucun portefeuille trouvé"
};

var ko = {
  choose_preferred_wallet: "원하는 지갑을 선택하세요",
  connect_mobile_wallet: "모바일 지갑과 연결",
  scan_qrcode_with_wallet: "WalletConnect 지원 지갑에서 QR코드를 스캔하세요",
  connect: "연결",
  qrcode: "QR 코드",
  mobile: "모바일",
  desktop: "데스크탑",
  copy_to_clipboard: "클립보드에 복사",
  copied_to_clipboard: "클립보드에 복사되었습니다!",
  connect_with: "와 연결하다",
  loading: "로드 중...",
  something_went_wrong: "문제가 발생했습니다.",
  no_supported_wallets: "아직 지원되는 지갑이 없습니다",
  no_wallets_found: "지갑을 찾을 수 없습니다"
};

var pt = {
  choose_preferred_wallet: "Escolha sua carteira preferida",
  connect_mobile_wallet: "Conectar-se à carteira móvel",
  scan_qrcode_with_wallet: "Ler o código QR com uma carteira compatível com WalletConnect",
  connect: "Conectar",
  qrcode: "Código QR",
  mobile: "Móvel",
  desktop: "Desktop",
  copy_to_clipboard: "Copiar",
  copied_to_clipboard: "Copiado!",
  connect_with: "Ligar por meio de",
  loading: "Carregamento...",
  something_went_wrong: "Algo correu mal",
  no_supported_wallets: "Ainda não há carteiras suportadas",
  no_wallets_found: "Nenhuma carteira encontrada"
};

var zh = {
  choose_preferred_wallet: "选择你的钱包",
  connect_mobile_wallet: "连接至移动端钱包",
  scan_qrcode_with_wallet: "使用兼容 WalletConnect 的钱包扫描二维码",
  connect: "连接",
  qrcode: "二维码",
  mobile: "移动",
  desktop: "桌面",
  copy_to_clipboard: "复制到剪贴板",
  copied_to_clipboard: "复制到剪贴板成功！",
  connect_with: "通过以下方式连接",
  loading: "正在加载...",
  something_went_wrong: "出了问题",
  no_supported_wallets: "目前还没有支持的钱包",
  no_wallets_found: "没有找到钱包"
};

var fa = {
  choose_preferred_wallet: "کیف پول مورد نظر خود را انتخاب کنید",
  connect_mobile_wallet: "به کیف پول موبایل وصل شوید",
  scan_qrcode_with_wallet: "کد QR را با یک کیف پول سازگار با WalletConnect اسکن کنید",
  connect: "اتصال",
  qrcode: "کد QR",
  mobile: "سیار",
  desktop: "دسکتاپ",
  copy_to_clipboard: "کپی به کلیپ بورد",
  copied_to_clipboard: "در کلیپ بورد کپی شد!",
  connect_with: "ارتباط با",
  loading: "...بارگذاری",
  something_went_wrong: "مشکلی پیش آمد",
  no_supported_wallets: "هنوز هیچ کیف پول پشتیبانی شده ای وجود ندارد",
  no_wallets_found: "هیچ کیف پولی پیدا نشد"
};

var languages = {
  de: de,
  en: en,
  es: es,
  fr: fr,
  ko: ko,
  pt: pt,
  zh: zh,
  fa: fa
};

function injectStyleSheet() {
  var doc = legacyUtils.getDocumentOrThrow();
  var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);

  if (prev) {
    doc.head.removeChild(prev);
  }

  var style = doc.createElement("style");
  style.setAttribute("id", WALLETCONNECT_STYLE_ID);
  style.innerText = WALLETCONNECT_STYLE_SHEET;
  doc.head.appendChild(style);
}

function renderWrapper() {
  var doc = legacyUtils.getDocumentOrThrow();
  var wrapper = doc.createElement("div");
  wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
  doc.body.appendChild(wrapper);
  return wrapper;
}

function triggerCloseAnimation() {
  var doc = legacyUtils.getDocumentOrThrow();
  var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);

  if (modal) {
    modal.className = modal.className.replace("fadeIn", "fadeOut");
    setTimeout(function () {
      var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);

      if (wrapper) {
        doc.body.removeChild(wrapper);
      }
    }, ANIMATION_DURATION);
  }
}

function getWrappedCallback(cb) {
  return function () {
    triggerCloseAnimation();

    if (cb) {
      cb();
    }
  };
}

function getText() {
  var lang = legacyUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
  return languages[lang] || languages["en"];
}

function open$1(uri, cb, qrcodeModalOptions) {
  injectStyleSheet();
  var wrapper = renderWrapper();
  React.render(React.createElement(Modal, {
    text: getText(),
    uri: uri,
    onClose: getWrappedCallback(cb),
    qrcodeModalOptions: qrcodeModalOptions
  }), wrapper);
}
function close$1() {
  triggerCloseAnimation();
}

var isNode = function () { return typeof browser$1$1 !== "undefined" && typeof browser$1$1.versions !== "undefined" && typeof browser$1$1.versions.node !== "undefined"; };

function open$2(uri, cb, qrcodeModalOptions) {
  console.log(uri);

  if (isNode()) {
    open(uri);
  } else {
    open$1(uri, cb, qrcodeModalOptions);
  }
}

function close$2() {
  if (isNode()) ; else {
    close$1();
  }
}

var index = {
  open: open$2,
  close: close$2
};

var cjs = index;

var DEFAULT_APP_METADATA = {
    name: 'dApp example',
    description: 'dApp example',
    url: 'https://ternoa.com',
    icons: ['https://www.ternoa.com/favicon.ico'],
};
var TERNOA_ALPHANET_CHAIN = 'ternoa:18bcdb75a0bba577b084878db2dc2546';
var requiredNamespaces = {
    ternoa: {
        chains: [TERNOA_ALPHANET_CHAIN],
        events: ['event_test'],
        methods: ['sign_message'],
    },
};
var useWalletConnect = function () {
    var _a = useState$1(), client = _a[0], setClient = _a[1];
    var _b = useState$1([]), pairings = _b[0], setPairings = _b[1];
    var _c = useState$1(), session = _c[0], setSession = _c[1];
    var _d = useState$1(), address = _d[0], setAddress = _d[1];
    var _e = useState$1(false), isLoading = _e[0], setIsLoading = _e[1];
    var _f = useState$1(false), isInitializing = _f[0], setIsInitializing = _f[1];
    var _g = useState$1(false), isAccountCertified = _g[0], setIsAccountCertified = _g[1];
    var onSessionConnected = useCallback$1(function (_session) {
        var _pubKey = Object.values(_session.namespaces)
            .map(function (namespace) { return namespace.accounts; })
            .flat()[0]
            .split(':')[2];
        setSession(_session);
        setAddress(_pubKey);
    }, []);
    var subscribeToEvents = useCallback$1(function (_client) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (typeof _client === 'undefined') {
                throw new Error('WalletConnect is not initialized');
            }
            _client.on('session_update', function (_a) {
                var topic = _a.topic, params = _a.params;
                var namespaces = params.namespaces;
                var _session = _client.session.get(topic);
                var updatedSession = __assign(__assign({}, _session), { namespaces: namespaces });
                onSessionConnected(updatedSession);
            });
            _client.on('session_delete', function () {
                reset();
            });
            return [2 /*return*/];
        });
    }); }, [onSessionConnected]);
    var checkPersistedState = useCallback$1(function (_client) { return __awaiter(void 0, void 0, void 0, function () {
        var lastKeyIndex, _session;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (typeof _client === 'undefined') {
                        throw new Error('WalletConnect is not initialized');
                    }
                    // populates existing pairings to state
                    setPairings(_client.pairing.values);
                    if (typeof session !== 'undefined')
                        return [2 /*return*/];
                    if (!_client.session.length) return [3 /*break*/, 2];
                    lastKeyIndex = _client.session.keys.length - 1;
                    _session = _client.session.get(_client.session.keys[lastKeyIndex]);
                    return [4 /*yield*/, onSessionConnected(_session)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, _session];
                case 2: return [2 /*return*/];
            }
        });
    }); }, [session, onSessionConnected]);
    var createClient = useCallback$1(function () { return __awaiter(void 0, void 0, void 0, function () {
        var _client, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 4, 5, 6]);
                    setIsInitializing(true);
                    return [4 /*yield*/, Client.init({
                            relayUrl: 'wss://wallet-connectrelay.ternoa.network/',
                            projectId: 'e8f6f7d41ff88cd96a21ce580f018401',
                            metadata: DEFAULT_APP_METADATA,
                        })];
                case 1:
                    _client = _a.sent();
                    return [4 /*yield*/, subscribeToEvents(_client)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, checkPersistedState(_client)];
                case 3:
                    _a.sent();
                    setClient(_client);
                    return [3 /*break*/, 6];
                case 4:
                    err_1 = _a.sent();
                    throw err_1;
                case 5:
                    setIsInitializing(false);
                    return [7 /*endfinally*/];
                case 6: return [2 /*return*/];
            }
        });
    }); }, [checkPersistedState, subscribeToEvents]);
    var connect = useCallback$1(function (pairing) { return __awaiter(void 0, void 0, void 0, function () {
        var _a, uri, approval, session_1, e_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (typeof client === 'undefined') {
                        throw new Error('WalletConnect is not initialized');
                    }
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 4, 5, 6]);
                    return [4 /*yield*/, client.connect({
                            pairingTopic: pairing === null || pairing === void 0 ? void 0 : pairing.topic,
                            requiredNamespaces: requiredNamespaces,
                        })];
                case 2:
                    _a = _b.sent(), uri = _a.uri, approval = _a.approval;
                    if (uri) {
                        cjs.open(uri, function () { });
                    }
                    return [4 /*yield*/, approval()];
                case 3:
                    session_1 = _b.sent();
                    onSessionConnected(session_1);
                    return [2 /*return*/, session_1];
                case 4:
                    e_1 = _b.sent();
                    console.error(e_1);
                    return [2 /*return*/, null
                        // ignore rejection
                    ];
                case 5:
                    cjs.close();
                    return [7 /*endfinally*/];
                case 6: return [2 /*return*/];
            }
        });
    }); }, [client, onSessionConnected]);
    useCallback$1(function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (typeof client === 'undefined') {
                throw new Error('WalletConnect is not initialized');
            }
            if (typeof session === 'undefined') {
                throw new Error('Session is not connected');
            }
            // await client.disconnect({
            //   topic: session.topic,
            //   reason: getSdkError('USER_DISCONNECTED'),
            // })
            reset();
            return [2 /*return*/];
        });
    }); }, [client, session]);
    var reset = function () {
        setPairings([]);
        setSession(undefined);
        setAddress(undefined);
    };
    var signMessage = useCallback$1(function () { return __awaiter(void 0, void 0, void 0, function () {
        var message, response, responseObj, isValid;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (typeof client === 'undefined') {
                        throw new Error('WalletConnect is not initialized');
                    }
                    if (typeof address === 'undefined') {
                        throw new Error('Not connected');
                    }
                    if (typeof session === 'undefined') {
                        throw new Error('Session not connected');
                    }
                    setIsLoading(true);
                    message = 'Confirm Account';
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 4, 5, 6]);
                    return [4 /*yield*/, client.request({
                            chainId: TERNOA_ALPHANET_CHAIN,
                            topic: session.topic,
                            request: {
                                method: 'sign_message',
                                params: {
                                    pubKey: address,
                                    request: {
                                        message: message,
                                    },
                                },
                            },
                        })];
                case 2:
                    response = _b.sent();
                    responseObj = JSON.parse(response);
                    return [4 /*yield*/, cryptoWaitReady()];
                case 3:
                    _b.sent();
                    isValid = isValidSignaturePolkadot(message, responseObj.signedMessageHash, address);
                    setIsAccountCertified(isValid);
                    return [3 /*break*/, 6];
                case 4:
                    _b.sent();
                    console.log('ERROR: invalid signature');
                    return [3 /*break*/, 6];
                case 5:
                    setIsLoading(false);
                    return [7 /*endfinally*/];
                case 6: return [2 /*return*/];
            }
        });
    }); }, [client, session, address]);
    var isValidSignaturePolkadot = function (signedMessage, signature, address) {
        var publicKey = decodeAddress(address);
        var hexPublicKey = u8aToHex(publicKey);
        return signatureVerify(signedMessage, signature, hexPublicKey).isValid;
    };
    useEffect$1(function () {
        if (!client) {
            createClient();
        }
    }, [client, createClient]);
    return {
        client: client,
        pairings: pairings,
        session: session,
        address: address,
        isLoading: isLoading,
        isInitializing: isInitializing,
        isAccountCertified: isAccountCertified,
        signMessage: signMessage,
        connect: connect,
    };
};

var DAPP_NAME = 'NFT Manager';
var defaultTernoaConnectValues = {
    isAccountConnected: false,
    extensions: null,
    currentActiveExtension: null,
    accounts: null,
    currentActiveAccount: null,
    currentActiveWallet: null,
    connect: function () { },
    toggleModal: function () { },
    selectNewActiveAccount: function (_account) { },
    selectWallet: function (_walletKey) { },
    sign: function (_txHex) { },
    signAndSubmit: function (_txHex, _waitUntil) { },
};
var TernoaConnectContext = createContext$2(defaultTernoaConnectValues);
function TernoaConnectProvider(_a) {
    var _this = this;
    var children = _a.children;
    var _b = useState$1(null), extensions = _b[0], setExtensions = _b[1];
    var _c = useState$1(null), currentActiveExtension = _c[0], setCurrentActiveExtension = _c[1];
    var _d = useState$1(null), accounts = _d[0], setAccounts = _d[1];
    var _e = useState$1(null), currentActiveAccount = _e[0], setCurrentActiveAccount = _e[1];
    var _f = useState$1(null), currentActiveWallet = _f[0]; _f[1];
    var connectWC = useWalletConnect().connect;
    var _g = useState$1(false), isModalOpen = _g[0], setIsModalOpen = _g[1];
    var connect = function () { return __awaiter(_this, void 0, void 0, function () {
        var _extensions, _accounts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, web3Enable(DAPP_NAME)];
                case 1:
                    _extensions = _a.sent();
                    console.log('_extensions', _extensions);
                    setExtensions(_extensions);
                    return [4 /*yield*/, web3Accounts()];
                case 2:
                    _accounts = _a.sent();
                    console.log('_accounts', _accounts);
                    setAccounts(_accounts);
                    setIsModalOpen(true);
                    return [2 /*return*/];
            }
        });
    }); };
    var selectNewActiveAccount = function (_account) {
        if (_account.address === (currentActiveAccount === null || currentActiveAccount === void 0 ? void 0 : currentActiveAccount.address))
            return;
        console.log('_account', _account);
        setCurrentActiveAccount(_account);
        var _currentExtension = (extensions === null || extensions === void 0 ? void 0 : extensions.find(function (_extension) { return _extension.name === (_account === null || _account === void 0 ? void 0 : _account.meta.source); })) || null;
        console.log('_currentExtension', _currentExtension);
        setCurrentActiveExtension(_currentExtension);
    };
    var selectWallet = function (walletKey) {
        switch (walletKey) {
            case 'ternoa': {
                connectWC(null);
            }
        }
    };
    var sign = function (_txHex) { return __awaiter(_this, void 0, void 0, function () {
        var api, nonce, signedTxHex, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 3, , 4]);
                    if (!(currentActiveExtension === null || currentActiveExtension === void 0 ? void 0 : currentActiveExtension.signer))
                        throw new Error('Signer not found!');
                    if (!currentActiveAccount)
                        throw new Error('No current account found!');
                    if (!isApiConnected)
                        throw new Error('Blockchain API not connected!');
                    api = getRawApi();
                    return [4 /*yield*/, query('system', 'account', [
                            currentActiveAccount.address,
                        ])];
                case 1:
                    nonce = (_a.sent()).nonce.toNumber();
                    return [4 /*yield*/, api.tx(_txHex).signAsync(currentActiveAccount.address, {
                            nonce: nonce,
                            signer: currentActiveExtension.signer,
                        })];
                case 2:
                    signedTxHex = (_a.sent()).toHex();
                    return [2 /*return*/, signedTxHex];
                case 3:
                    err_1 = _a.sent();
                    throw new Error(err_1);
                case 4: return [2 /*return*/];
            }
        });
    }); };
    var signAndSubmit = function (_txHex, _waitUntil) {
        if (_waitUntil === void 0) { _waitUntil = WaitUntil.BlockFinalization; }
        return __awaiter(_this, void 0, void 0, function () {
            var signedTxHex, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, sign(_txHex)];
                    case 1:
                        signedTxHex = _a.sent();
                        return [4 /*yield*/, submitTxBlocking(signedTxHex, _waitUntil)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        err_2 = _a.sent();
                        throw new Error(err_2);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    var toggleModal = function () {
        setIsModalOpen(!isModalOpen);
    };
    return (jsxs(TernoaConnectContext.Provider, __assign({ value: {
            isAccountConnected: (accounts && (accounts === null || accounts === void 0 ? void 0 : accounts.length) > 0) || false,
            extensions: extensions,
            currentActiveExtension: currentActiveExtension,
            accounts: accounts,
            currentActiveAccount: currentActiveAccount,
            currentActiveWallet: currentActiveWallet,
            connect: connect,
            toggleModal: toggleModal,
            selectNewActiveAccount: selectNewActiveAccount,
            selectWallet: selectWallet,
            sign: sign,
            signAndSubmit: signAndSubmit,
        } }, { children: [jsx(Modal$1, { isModalVisible: isModalOpen }, void 0), children] }), void 0));
}

function useTernoaConnect() {
    var context = useContext$1(TernoaConnectContext);
    if (context === undefined) {
        throw new Error('useTernoaConnect must be used within TernoaConnectProvider');
    }
    return context;
}

var styles = {
    container: {
        display: 'block',
        alignItems: 'center',
        justifyContent: 'center',
        borderRadius: 4,
        cursor: 'pointer',
        minWidth: 32,
        minHeight: 32,
        maxWidth: 200,
        backgroundColor: '#3817E8',
        padding: '4px 8px',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
    },
};

function ConnectButton() {
    var _a = useState$1(false), isHover = _a[0], setIsHover = _a[1];
    var _b = useTernoaConnect(), toggleModal = _b.toggleModal, currentActiveAccount = _b.currentActiveAccount, extensions = _b.extensions, connect = _b.connect;
    var onClick = extensions && extensions.length > 0 ? toggleModal : connect;
    return jsx("button", __assign({ type: "button", style: __assign(__assign({}, styles.container), { backgroundColor: isHover ? '#3817B8' : '#3817E8' }), onMouseEnter: function () {
            setIsHover(true);
        }, onMouseLeave: function () {
            setIsHover(false);
        }, onClick: onClick }, { children: currentActiveAccount ? (currentActiveAccount === null || currentActiveAccount === void 0 ? void 0 : currentActiveAccount.meta.name) + " - " + currentActiveAccount.address : 'Connect Wallet' }), void 0);
}

export { ConnectButton, Modal$1 as Modal, TernoaConnectContext, TernoaConnectProvider, useTernoaConnect };
//# sourceMappingURL=index.js.map
